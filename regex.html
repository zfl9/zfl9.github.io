<!doctype html>
<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">
<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">
<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">
  <meta name="keywords" content="正则表达式 RegExp regex BRE ERE PCRE">
  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1">
<meta name="description" content="正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。许多程序设计语言都支持利用正则表达式进行字符串操作。例如，">
<meta name="keywords" content="正则表达式">
<meta property="og:type" content="article">
<meta property="og:title" content="正则表达式">
<meta property="og:url" content="https://www.zfl9.com/regex.html">
<meta property="og:site_name" content="Otokaze's Blog">
<meta property="og:description" content="正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。许多程序设计语言都支持利用正则表达式进行字符串操作。例如，">
<meta property="og:image" content="http://qiniu-img.zjmainstay.cn/regex.zjmainstay.cn.jpg">
<meta property="og:image" content="http://qiniu-img.zjmainstay.cn/regex.zjmainstay.cn-usage-demo.gif">
<meta property="og:image" content="https://www.zfl9.com/images/regex-web-1.png">
<meta property="og:image" content="https://www.zfl9.com/images/regex-web-2.png">
<meta property="og:image" content="http://qiniu-img.zjmainstay.cn/regexbuddy/regexbuddy_view_options.gif">
<meta property="og:image" content="http://qiniu-img.zjmainstay.cn/regexbuddy/regexbuddy_view_match.gif">
<meta property="og:image" content="http://qiniu-img.zjmainstay.cn/regexbuddy/regexbuddy_view_replace.gif">
<meta property="og:image" content="http://qiniu-img.zjmainstay.cn/regexbuddy/regexbuddy_view_debug.gif">
<meta property="og:updated_time" content="2019-02-18T12:42:42.390Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="正则表达式">
<meta name="twitter:description" content="正则表达式，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。许多程序设计语言都支持利用正则表达式进行字符串操作。例如，">
<meta name="twitter:image" content="http://qiniu-img.zjmainstay.cn/regex.zjmainstay.cn.jpg">
<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
  <link rel="canonical" href="https://www.zfl9.com/regex.html">
<link href="/js/prism/prism.css" rel="stylesheet">
  <title>正则表达式 | Otokaze's Blog</title>
</head>
<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-97872912-1', 'auto');
  ga('send', 'pageview');
</script>
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3d58f51dbb2496a0e6d17b85065a5ae5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Otokaze's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">拼一年春夏秋冬，搏一生无怨无悔</h1>
  </div>
  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>
<nav class="site-nav">
    <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            首页
          </a>
        </li>
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            分类
          </a>
        </li>
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            标签
          </a>
        </li>
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            归档
          </a>
        </li>
    </ul>
</nav>
 </div>
    </header>
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
  <div id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.zfl9.com/regex.html">
    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Otokaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>
    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Otokaze's Blog">
    </span>
      <header class="post-header">
          <h2 class="post-title" itemprop="name headline">
                正则表达式
          </h2>
        <div class="post-meta">
          <span class="post-time">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
                <span class="post-meta-item-text">发表于</span>
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-10-23T09:17:11+08:00">
                2016-10-23
              </time>
          </span>
            <span class="post-category">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
                <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/正则表达式/" itemprop="url" rel="index">
                    <span itemprop="name">正则表达式</span>
                  </a>
                </span>
            </span>
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/regex.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="regex.html" itemprop="commentCount"></span>
                </a>
              </span>
             <span id="/regex.html" class="leancloud_visitors" data-flag-title="正则表达式">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
                 <span class="post-meta-item-text">阅读次数 </span>
                 <span class="leancloud-visitors-count"></span>
             </span>
        </div>
      </header>
    <div class="post-body" itemprop="articleBody">
        <p><strong>正则表达式</strong>，又称正规表示式、正规表示法、正规表达式、规则表达式、常规表示法（英语：Regular Expression，在代码中常简写为 regex、regexp 或 RE），是计算机科学的一个概念。正则表达式使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。在很多文本编辑器里，正则表达式通常被用来检索、替换那些匹配某个模式的文本。许多程序设计语言都支持利用正则表达式进行字符串操作。例如，在 Perl 中就内建了一个功能强大的正则表达式引擎。正则表达式这个概念最初是由 Unix 中的工具软件（例如 sed 和 grep）普及开的。正则表达式通常缩写成“regex”，单数有 regexp、regex，复数有 regexps、regexes、regexen。</p>
<a id="more"></a>
<h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><p><strong>正则是什么</strong>？<br>正则表达式不是编程语言，而是实际字符序列的<strong>抽象表示方法</strong>，比如字符串<code>www</code>，三个连续的<code>w</code>字符，因此我们可以抽象的表示为<code>w{3}</code>，正则表达式就是这么演变而来的。</p>
<p><strong>正则派别</strong><br>相信大家对于正则表达式都不陌生，在文本处理中或多或少的都会使用到它。但是，我们在使用 linux 下的文本处理工具如 awk、sed 时，正则表达式的语法貌似还不一样，在 awk 中能正常工作的正则，在 sed 中总是不起作用，这是为什么呢？这个问题产生的缘由是因为正则表达式不断演变的结果，目前的主要”派别”有 3 个：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Regular_expression#POSIX_basic_and_extended" rel="external nofollow noopener noreferrer" target="_blank">BRE（Basic Regular Expressions）</a>：POSIX 基本正则，grep、sed 等都属于 BRE；</li>
<li><a href="https://en.wikipedia.org/wiki/Regular_expression#POSIX_extended" rel="external nofollow noopener noreferrer" target="_blank">ERE（Extended Regular Expressions）</a>：POSIX 扩展正则，egrep、awk 等都属于 ERE；</li>
<li><a href="https://en.wikipedia.org/wiki/Regular_expression#Perl" rel="external nofollow noopener noreferrer" target="_blank">PCRE（Perl Compatible Regular Expressions）</a>：Perl 兼容正则，Perl、Python、Java 等都属于 PCRE。</li>
</ul>
<p>BRE、ERE 与 PCRE 并不存在明显的语法差异，从总体上讲，BRE/ERE 属于 PCRE 的子集。因此本文主要讨论 PCRE 正则（Java 为背景，但正则是通用的），因为它是最强大、最灵活的一个正则派别，并且大多数编程语言的正则库都是 PCRE 风格的。</p>
<p><strong>正则引擎</strong><br><strong>正则表达式引擎</strong>有两种：<code>非确定型有穷自动机（NFA）</code>和<code>确定型有穷自动机（DFA）</code></p>
<ul>
<li>DFA：<strong>文本主导</strong>、<strong>确保获得最长的匹配文本</strong>、<strong>预编译复杂</strong>、<strong>匹配简单快速</strong>、<strong>特性较少</strong></li>
<li>传统型NFA：<strong>模式主导</strong>、<strong>找到匹配后丢弃其它分支</strong>、<strong>预编译简单</strong>、<strong>匹配复杂</strong>、<strong>特性多</strong></li>
<li>POSIX NFA：与传统型NFA差别不大，最大的区别是它会尝试所有分支，确保获得最长的匹配文本，速度略慢</li>
</ul>
<p>大多数编程语言都是使用<strong>传统型NFA引擎</strong>，如 Java、Perl、PHP、Python、.NET；而 grep、awk 则使用 DFA。</p>
<p>两类正则引擎要顺利工作，都必须有一个正则式和一个文本串，一个捏在手里，一个吃下去：</p>
<ul>
<li>DFA 捏着文本串去比较正则式，看到一个子正则式，就把可能的匹配串全标注出来，然后再看正则式的下一个部分，根据新的匹配结果更新标注。</li>
<li>NFA 则捏着正则式去比文本，吃掉一个字符，就把它跟正则式比较，匹配就记下来：“某年某月某日在某处匹配上了！”，然后接着往下干。一旦不匹配，就把刚吃的这个字符吐出来，一个个的吐，直到回到上一次匹配的地方。</li>
</ul>
<p>DFA 与 NFA 机制上的不同带来 5 个影响：</p>
<ol>
<li>DFA 对于文本串里的每一个字符只需扫描一次，比较快，但特性较少；NFA 要翻来覆去吃字符、吐字符，速度慢，但是特性丰富，因此应用广泛，当今主要的正则表达式引擎，如 Perl、Ruby、Python、Java 和 .NET 的 regex 库，都是 NFA 的。</li>
<li>只有 NFA 才支持 lazy（懒惰量词）和 backreference（反向引用）等特性。</li>
<li>NFA 急于邀功请赏，所以最左子正则式优先匹配成功，因此偶尔会错过最佳匹配结果；DFA 则是最长的左子正则式优先匹配成功。</li>
<li>NFA 缺省采用 greedy（贪婪量词），使用相应的修饰符可将贪婪量词转换为懒惰量词、占有量词。</li>
<li>NFA 可能会陷入递归调用的陷阱而表现得性能极差。</li>
</ol>
<p><strong>输入序列的组成</strong><br>对于字符串<code>&quot;abc&quot;</code>来说，除了存在<strong>三个字符</strong>外，它还存在<strong>四个位置</strong>，即<code>&quot;0a1b2c3&quot;</code>；这四个位置分别为：a 的左边、a 的右边、b 的右边、c 的右边，也就是每个字符的边界位置。</p>
<p>不过我们通常都会使用一个数字来表示一个位置，它们的表示规则为<code>&quot;0a1b2c3&quot;</code>。位置总是从 0 开始，最大值为字符串的长度，而每个位置的数值其实就是它后面的字符的索引值。如位置 0 就是字符 a 的索引值，位置 2 就是字符 c 的索引值。</p>
<p><strong>正则模式的组成</strong><br>对于模式<code>www\d+.*+</code>来说，存在 5 个子表达式（模式的最小单位称为子表达式），它们分别为：<code>w</code>、<code>w</code>、<code>w</code>、<code>\d+</code>、<code>.*+</code>。<strong>一个子表达式是不可再分的最小单位</strong>。</p>
<p><strong>占有字符和零宽度</strong><br>如果一个子表达式匹配的是<strong>字符</strong>，并且<strong>所匹配的字符会保存到最终结果中</strong>，那么该子表达式就是<strong>占有字符</strong>的。<br>如果一个子表达式匹配的是<strong>位置</strong>，或者<strong>匹配的字符不会保存到最终结果中</strong>，那么该子表达式就是<strong>零宽度</strong>的。</p>
<p><strong>占有字符的表达式</strong>称为<strong>占宽表达式</strong>，<strong>零宽度的表达式</strong>称为<strong>零宽表达式</strong>。<strong>占宽表达式是互斥的，零宽表达式是非互斥的</strong>。也就是说：同一个字符在同一时间只能被一个占宽表达式匹配；而同一个位置在同一时间却能被多个零宽表达式匹配。</p>
<p>在 Java 的正则中，只有<code>边界匹配符</code>、<code>顺序环视</code>、<code>逆序环视</code>是零宽表达式，其它的都是非零宽（占宽）表达式。</p>
<h2 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h2><p><strong>控制权</strong><br>如果正则引擎当前所执行的子表达式为 A，那么我们说子表达式 A 取得控制权。A 执行完后，它会将控制权转交给下一个子表达式 B，子表达式 B 则从 A 匹配成功的结束位置开始进行匹配，以此类推。</p>
<p>对于正则模式<code>ABCDEF</code>来说，控制权总是先交给 A，然后再交给 B，最后交给 F。即按照<strong>从左到右</strong>的顺序依次传递控制权（逆序环视中的子表达式例外，它是从右到左的）。</p>
<p><strong>匹配细节</strong><br>除了<code>逆序环视</code>外，其它的所有子表达式都是匹配<strong>当前位置右侧</strong>的字符序列。比如，字符序列<code>&quot;ABCDEFG&quot;</code>，假设子表达式 A 从位置 3 开始匹配（即字符 D 前面），它只会从位置 3 往后看，看看能不能匹配后面的 DEFG 字符序列。<br>而对于逆序环视子表达式 B 来说，假设它从位置 3 开始匹配，它只会从位置 3 往前看，看看能不能匹配前面的 ABC 字符序列。</p>
<p><strong>分支与回溯</strong><br>对于模式<code>(?:g|f)ood</code>来说，它存在两条分支（或者叫做执行路径），一条是<code>good</code>，另一条是<code>food</code>。而正则引擎总是按照<strong>从左到右的顺序选择分支</strong>的，因此<code>good</code>分支首先被执行，只有当该分支在某一位置无法继续匹配时才会进入下一个分支<code>food</code>。这个进入下一个分支的行为叫做<code>回溯（backtrack）</code>，也就是说，当前这条路已经走不通了，只能尝试下一条路了。</p>
<p>分支是可以有多个的，比如模式<code>(?:a|b)X(?:c|d)Y</code>，第一个岔路口<code>a|b</code>，第二个岔路口<code>c|d</code>，因此它有四条分支：<code>aXcY</code>、<code>aXdY</code>、<code>bXcY</code>、<code>bXdY</code>。正则引擎会先选择 aXcY 分支，如果该分支可以将整个正则模式匹配完毕（即整个模式匹配成功），那么其它的所有分支将被丢弃，开始进入下一轮匹配（如果启用了 global 标志位）或者结束匹配并报告该轮匹配成功；如果该分支走到某个地方匹配失败了，则进行回溯，开始进入<strong>离它最近的下一个分支</strong>，即 aXdY 分支。以此类推。</p>
<p><strong>量词与回溯</strong><br>对于模式<code>\d{1,3}www</code>来说，它存在三条分支，即<code>\d\d\dwww</code>、<code>\d\dwww</code>、<code>\dwww</code>。为什么是倒着排呢？因为<strong>量词默认都是贪婪的</strong>，它总是会先尝试匹配 max 次（在这里就是 3 次咯），而如果给量词加上修饰符 ? 即<code>\d{1,3}?</code>，则三条分支依次为：<code>\dwww</code>、<code>\d\dwww</code>、<code>\d\d\dwww</code>，加上 ? 后贪婪量词就会变成懒惰量词，而懒惰量词总是先尝试匹配 min 次（在这里就是 1 次咯）。具体的回溯过程就不再复述了，在上面的”分支与回溯”中已进行讲解。</p>
<p><strong>向前传动</strong><br>如果当前选择的分支匹配失败了，则正则引擎会进行回溯，进入下一条分支再次尝试，但是如果当前的所有分支都匹配失败了或者当前根本就没有任何分支可用的情况下会怎么样呢？答案是进行向前传动。</p>
<p>我们将上面的这种<strong>无分支可用或全部分支都匹配失败</strong>的情况称为<strong>本轮匹配失败</strong>，那么就要进入”下一轮匹配”。那么要怎么进入下一轮呢？</p>
<p>别急，首先，<strong>正则引擎第一轮匹配总是从输入序列的位置 0 开始的</strong>，因此，进入第二轮就是说从输入序列的位置 1 开始重新匹配整个模式，而进入第三轮就是从输入序列的位置 2 开始重新匹配整个模式，以此类推，直到输入序列的最后一个位置 n，如果到了最后一轮还是失败，那么正则引擎将报告模式匹配失败。这个<strong>进入下一轮的过程就称为向前传动</strong>，简称传动。也就是说，将输入序列往前挪动一个字符长度，最前面的一个字符将会被丢弃，后续匹配不会再考虑被丢弃的字符序列。</p>
<p>最后再说一下 global 匹配的过程，默认情况下，正则引擎匹配成功了一次之后，就会返回，不会再管剩下的字符序列；但如果启用了 global 全局匹配标志，则匹配成功一次后，不会立即返回，而是接着从本次匹配成功的结束位置开始重新匹配整个模式，即：将本次匹配成功的结束位置前的字符都丢弃掉（向前传动），然后重新开始匹配整个模式，直到整个字符序列都被传动完毕（消耗完毕，导致没有字符可匹配）为止，引擎才会返回。</p>
<p><strong>正则匹配过程总结</strong><br>每开始新的一轮匹配，控制权都是先交给正则模式中的第一个子表达式，当遇到分支结构时，如<code>X|Y</code>，正则引擎会记录下 Y 分支，并首先进入 X 分支，如果在 X 分支中走不动了，就会进行回溯，即回到<code>X|Y</code>处，选择 Y 分支继续尝试匹配，如果这条路走通了，则正则引擎报告第一次匹配成功并返回（如果启用了全局标志，则还会继续搜索）；如果这条路依旧失败了，则进行向前传动，即丢弃当前字符序列的头一个字符，重新开始匹配整个正则模式，以此类推，直到字符序列全部被消耗完毕。</p>
<h2 id="字符"><a href="#字符" class="headerlink" title="字符"></a>字符</h2><blockquote>
<p>宽度为 1</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>x</code></td>
<td style="text-align:center">匹配字符<code>x</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\\</code></td>
<td style="text-align:center">匹配字符<code>\</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\0n</code></td>
<td style="text-align:center">匹配八进制值为<code>0n</code>的 ASCII 字符 (0 &lt;= n &lt;= 7)</td>
</tr>
<tr>
<td style="text-align:center"><code>\0nn</code></td>
<td style="text-align:center">匹配八进制值为<code>0nn</code>的 ASCII 字符 (0 &lt;= n &lt;= 7)</td>
</tr>
<tr>
<td style="text-align:center"><code>\0mnn</code></td>
<td style="text-align:center">匹配八进制值为<code>0mnn</code>的 ASCII 字符 (0 &lt;= m &lt;= 3, 0 &lt;= n &lt;= 7)</td>
</tr>
<tr>
<td style="text-align:center"><code>\xhh</code></td>
<td style="text-align:center">匹配十六进制值为<code>0xhh</code>的 ASCII 字符</td>
</tr>
<tr>
<td style="text-align:center"><code>\uhhhh</code></td>
<td style="text-align:center">匹配十六进制值为<code>0xhhhh</code>的 Unicode BMP 字符</td>
</tr>
<tr>
<td style="text-align:center"><code>\x{h...h}</code></td>
<td style="text-align:center">匹配十六进制值为<code>0xh...h</code>的 Uncode 字符 (0x0000 &lt;= 0xh…h &lt;= 0x10FFFF)</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">匹配水平制表符 HT (<code>&#39;\u0009&#39;</code>)</td>
</tr>
<tr>
<td style="text-align:center"><code>\v</code></td>
<td style="text-align:center">匹配垂直制表符 VT (<code>&#39;\u000B&#39;</code>)</td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td style="text-align:center">匹配回车符 CR (<code>&#39;\u000D&#39;</code>)</td>
</tr>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">匹配换行符 LF (<code>&#39;\u000A&#39;</code>)</td>
</tr>
<tr>
<td style="text-align:center"><code>\f</code></td>
<td style="text-align:center">匹配换页符 FF (<code>&#39;\u000C&#39;</code>)</td>
</tr>
<tr>
<td style="text-align:center"><code>\a</code></td>
<td style="text-align:center">匹配警铃符 BEL (<code>&#39;\u0007&#39;</code>)</td>
</tr>
<tr>
<td style="text-align:center"><code>\b</code></td>
<td style="text-align:center">匹配退格符 BS (<code>&#39;\u0008&#39;</code>)</td>
</tr>
<tr>
<td style="text-align:center"><code>\e</code></td>
<td style="text-align:center">匹配 ESC 符 (<code>&#39;\u001B&#39;</code>)</td>
</tr>
<tr>
<td style="text-align:center"><code>\cX</code></td>
<td style="text-align:center">匹配控制字符 X，如 \cC 匹配 Control-C</td>
</tr>
</tbody>
</table>
<h2 id="自定义字符集合"><a href="#自定义字符集合" class="headerlink" title="自定义字符集合"></a>自定义字符集合</h2><blockquote>
<p>宽度为 1</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>[abc]</code></td>
<td style="text-align:center">匹配集合中的单个字符 (枚举)</td>
</tr>
<tr>
<td style="text-align:center"><code>[a-z]</code></td>
<td style="text-align:center">匹配集合中的单个字符 (范围)</td>
</tr>
<tr>
<td style="text-align:center"><code>[^abc]</code></td>
<td style="text-align:center">[逻辑非] 匹配不在集合中的单个字符 (枚举)</td>
</tr>
<tr>
<td style="text-align:center"><code>[^a-z]</code></td>
<td style="text-align:center">[逻辑非] 匹配不在集合中的单个字符 (范围)</td>
</tr>
<tr>
<td style="text-align:center"><code>[a-z[A-Z]]</code></td>
<td style="text-align:center">[逻辑或] 表达式 a-z 和表达式 A-Z 只要有一个匹配则整个表达式匹配（仅 Java）</td>
</tr>
<tr>
<td style="text-align:center"><code>[a-zA-Z]</code></td>
<td style="text-align:center">[逻辑或] 可以省略嵌套中括号，但如果后一个表达式为否定则不能省略（常用/通用）</td>
</tr>
<tr>
<td style="text-align:center"><code>[a-z[^0-9]]</code></td>
<td style="text-align:center">[逻辑或] 表达式 a-z 和表达式 ^0-9 只要有一个匹配则整个表达式匹配（仅 Java）</td>
</tr>
<tr>
<td style="text-align:center"><code>[a-z&amp;&amp;[def]]</code></td>
<td style="text-align:center">[逻辑与] 表达式 a-z 和表达式 def 只有两个都匹配时整个表达式才匹配（仅 Java）</td>
</tr>
<tr>
<td style="text-align:center"><code>[a-z&amp;&amp;[^bc]]</code></td>
<td style="text-align:center">[逻辑与] 表达式 a-z 和表达式 ^bc 只有两个都匹配时整个表达式才匹配（仅 Java）</td>
</tr>
<tr>
<td style="text-align:center"><code>[a-z&amp;&amp;[^m-p]]</code></td>
<td style="text-align:center">[逻辑与] 表达式 a-z 和表达式 ^m-p 只有两个都匹配时整个表达式才匹配（仅 Java）</td>
</tr>
</tbody>
</table>
<p>自定义字符集合的<code>[]</code>方括号中的特殊字符有 6 个：</p>
<ol>
<li><code>[</code>：表示一个字符集合的开始，如果需要匹配 [ 本身，请使用<code>\[</code></li>
<li><code>]</code>：表示一个字符集合的结束，如果需要匹配 ] 本身，请使用<code>\]</code></li>
<li><code>^</code>：只有位于字符集合的起始位置才有特殊意义，表示取反操作、排除语义</li>
<li><code>-</code>：只有位于字符集合的非边界位置才有特殊意义，表示一个字符范围（从小到大）</li>
<li><code>&amp;</code>：用于连接前后两个字符集合（逻辑与），并且必须是两个连续的 &amp; 才有特殊意义</li>
<li><code>\</code>：表示一个转义序列的开始，本身不匹配任何字符，如果要匹配 \ 本身，请使用<code>\\</code></li>
</ol>
<p>除了这六个字符外，其它字符都是普通字符，比如 <code>.?*+$|(){}</code> 等都属于普通字面意义字符。</p>
<h2 id="预定义字符集合"><a href="#预定义字符集合" class="headerlink" title="预定义字符集合"></a>预定义字符集合</h2><blockquote>
<p>宽度为 1</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center">匹配除行结束符外的任意字符（单行模式匹配任意字符）</td>
</tr>
<tr>
<td style="text-align:center"><code>\d</code></td>
<td style="text-align:center">匹配数字<code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\D</code></td>
<td style="text-align:center">匹配非数字<code>[^0-9]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\w</code></td>
<td style="text-align:center">匹配单词字符<code>[a-zA-Z_0-9]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\W</code></td>
<td style="text-align:center">匹配非单词字符<code>[^\w]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\s</code></td>
<td style="text-align:center">匹配空白符<code>[ \t\n\x0B\f\r]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\S</code></td>
<td style="text-align:center">匹配非空白符<code>[^\s]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\h</code></td>
<td style="text-align:center">匹配水平空白符<code>[ \t\xA0\u1680\u180e\u2000-\u200a\u202f\u205f\u3000]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\H</code></td>
<td style="text-align:center">匹配非水平空白符<code>[^\h]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\v</code></td>
<td style="text-align:center">匹配垂直空白符<code>[\n\x0B\f\r\x85\u2028\u2029]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\V</code></td>
<td style="text-align:center">匹配非垂直空白符<code>[^\v]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\R</code></td>
<td style="text-align:center">匹配任何行结束序列，如<code>\r\n</code>、<code>\n</code>、<code>\f</code>，等同于<code>\u000D\u000A｜[\u000A\u000B\u000C\u000D\u0085\u2028\u2029]</code></td>
</tr>
</tbody>
</table>
<p>小技巧：在不启用单行模式的情况下，可以利用一对预定义字符集合来匹配任意字符（包括行结束符），比如 <code>[\d\D]</code>、<code>[\w\W]</code>、<code>[\s\S]</code>、<code>[\h\H]</code>、<code>[\v\V]</code></p>
<h2 id="POSIX-字符集合"><a href="#POSIX-字符集合" class="headerlink" title="POSIX 字符集合"></a>POSIX 字符集合</h2><blockquote>
<p>宽度为 1、<code>ASCII only</code>（大写的 P 表示取反匹配）</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\p{Lower}</code></td>
<td style="text-align:center">匹配小写字母<code>[a-z]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\p{Upper}</code></td>
<td style="text-align:center">匹配大写字母<code>[A-Z]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\p{Alpha}</code></td>
<td style="text-align:center">匹配所有字母<code>[\p{Lower}\p{Upper}]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\p{Digit}</code></td>
<td style="text-align:center">匹配所有数字<code>[0-9]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\p{Alnum}</code></td>
<td style="text-align:center">匹配数字字母<code>[\p{Alpha}\p{Digit}]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\p{Punct}</code></td>
<td style="text-align:center">匹配标点符号<code>!&quot;#$%&amp;&#39;()*+,-./:;&lt;=&gt;?@[\]^_`{｜}~</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\p{Graph}</code></td>
<td style="text-align:center">匹配可见字符<code>[\p{Alnum}\p{Punct}]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\p{Print}</code></td>
<td style="text-align:center">匹配可打印字符<code>[\p{Graph}\x20]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\p{Cntrl}</code></td>
<td style="text-align:center">匹配控制字符<code>[\x00-\x1F\x7F]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\p{Blank}</code></td>
<td style="text-align:center">匹配空格符<code>[ \t]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\p{Space}</code></td>
<td style="text-align:center">匹配空白符<code>[ \t\n\x0B\f\r]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\p{XDigit}</code></td>
<td style="text-align:center">匹配十六进制数字<code>[0-9a-fA-F]</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\p{ASCII}</code></td>
<td style="text-align:center">匹配所有 ASCII 字符<code>[\x00-\x7F]</code></td>
</tr>
</tbody>
</table>
<h2 id="Java-字符集合"><a href="#Java-字符集合" class="headerlink" title="Java 字符集合"></a>Java 字符集合</h2><blockquote>
<p>宽度为 1（仅适用于 Java，大写的 P 表示取反匹配）</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\p{javaLowerCase}</code></td>
<td style="text-align:center">等价于 Character.isLowerCase()</td>
</tr>
<tr>
<td style="text-align:center"><code>\p{javaUpperCase}</code></td>
<td style="text-align:center">等价于 Character.isUpperCase()</td>
</tr>
<tr>
<td style="text-align:center"><code>\p{javaWhitespace}</code></td>
<td style="text-align:center">等价于 Character.isWhitespace()</td>
</tr>
<tr>
<td style="text-align:center"><code>\p{javaMirrored}</code></td>
<td style="text-align:center">等价于 Character.isMirrored() 镜像字符，如 () [] {}</td>
</tr>
</tbody>
</table>
<h2 id="Unicode-字符集合"><a href="#Unicode-字符集合" class="headerlink" title="Unicode 字符集合"></a>Unicode 字符集合</h2><blockquote>
<p>宽度为 1（花括号中的属性仅适用于 Java，大写的 P 表示取反匹配）</p>
</blockquote>
<p>注：Java 对 Uncode 属性的支持不完整，建议使用 Perl 的正则来体验。在 Perl 中，花括号中的是 Unicode 属性名（Unicode Property），每个 Unicode Property 都对应一类 Unicode 字符（比如 Number 这个属性类，它代表 Unicode 中的所有“数字”字符，不仅限于 0-9 这 10 个阿拉伯数字，比如 <code>①</code> 也会被匹配）。</p>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\p{IsLatin}</code></td>
<td style="text-align:center">拉丁字符 (script)</td>
</tr>
<tr>
<td style="text-align:center"><code>\p{InGreek}</code></td>
<td style="text-align:center">希腊字符 (block)</td>
</tr>
<tr>
<td style="text-align:center"><code>\p{Lu}</code></td>
<td style="text-align:center">大写字母 (category)</td>
</tr>
<tr>
<td style="text-align:center"><code>\p{IsAlphabetic}</code></td>
<td style="text-align:center">字母字符 (binary property)</td>
</tr>
<tr>
<td style="text-align:center"><code>\p{Sc}</code></td>
<td style="text-align:center">货币符号</td>
</tr>
<tr>
<td style="text-align:center"><code>\P{InGreek}</code></td>
<td style="text-align:center">除希腊字符外的任意字符 (negation)</td>
</tr>
<tr>
<td style="text-align:center"><code>[\p{L}&amp;&amp;[^\p{Lu}]]</code></td>
<td style="text-align:center">除大写字母外的任意字母 (subtraction)</td>
</tr>
</tbody>
</table>
<h2 id="边界匹配符"><a href="#边界匹配符" class="headerlink" title="边界匹配符"></a>边界匹配符</h2><blockquote>
<p>宽度为 0，<code>零宽断言</code>，匹配位置而非字符</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">匹配输入序列的起始位置（默认模式），如果为多行模式，同时还会匹配行结束符之后的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:center">匹配输入序列的结束位置（默认模式），如果为多行模式，同时还会匹配行结束符之前的位置</td>
</tr>
<tr>
<td style="text-align:center"><code>\b</code></td>
<td style="text-align:center">匹配单词的边界</td>
</tr>
<tr>
<td style="text-align:center"><code>\B</code></td>
<td style="text-align:center">匹配非单词边界</td>
</tr>
<tr>
<td style="text-align:center"><code>\A</code></td>
<td style="text-align:center">匹配输入序列的起始位置</td>
</tr>
<tr>
<td style="text-align:center"><code>\G</code></td>
<td style="text-align:center">匹配上一次成功 match 的结束位置</td>
</tr>
<tr>
<td style="text-align:center"><code>\z</code></td>
<td style="text-align:center">匹配输入序列的结束位置</td>
</tr>
<tr>
<td style="text-align:center"><code>\Z</code></td>
<td style="text-align:center">匹配输入序列的结束位置，如果输入序列以行结束符结尾，则匹配这个行结束符之前的位置</td>
</tr>
</tbody>
</table>
<p><strong><code>\b</code>单词边界</strong><br>很多人都知道<code>\b</code>是匹配单词边界，但是关于”单词”的范围，却很少提及。正则中所指的单词就是<code>\w</code>定义的字符组成的序列。<br><code>\w</code>是一个<strong>预定义字符集合</strong>，它等价于<code>[a-zA-Z0-9_]</code>，即<strong>由<code>字母</code>、<code>数字</code>、<code>下划线</code>组成的字符序列被称为单词</strong>。如果启用了 Unicode 字符支持，则<code>\w</code>还会匹配 Unicode 中定义的单词字符，如汉字、全角数字。</p>
<p><code>\b</code>是一个零宽子表达式，它只<strong>匹配位置</strong>，因此单词边界就是<strong>一侧是<code>\w</code>而另一侧不是<code>\w</code>的这样一个位置</strong>，因此<code>\b</code>等价于<code>(?&lt;=\w)(?!\w)|(?&lt;!\w)(?=\w)</code>。<br>而<code>\B</code>则表示<strong>非单词边界</strong>，所谓的非单词边界就是指<strong>一侧是<code>\w</code>且另一侧也是<code>\w</code>的这样一个位置</strong>，因此<code>\B</code>等价于<code>(?&lt;=\w)(?=\w)</code>。</p>
<p>最后还有一点要说明，位于字符集合中的<code>\b</code>（如<code>[0-9\b]</code>）不是表示单词边界，而是代表 <strong>退格键</strong>（Backspace）！</p>
<p><strong><code>\z</code> 与 <code>\Z</code> 的区别</strong><br>其实上面说的很明显了，不过最好还是实际测试一下，才能有更深刻的认识：<br><code>\z</code>：匹配输入序列的末尾</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ java com.zfl9.regex.MatchTest '\A[\s\S]+?\z' $'www.zfl9.com\n'
regex: "\A[\s\S]+?\z"
input: "www.zfl9.com
"
[result-1]
    group0: "www.zfl9.com
"

$ java com.zfl9.regex.MatchTest '\A[\s\S]+?\z' $'www.zfl9.com\n\n'
regex: "\A[\s\S]+?\z"
input: "www.zfl9.com

"
[result-1]
    group0: "www.zfl9.com

"
</script></code></pre>
<p><code>\Z</code>：匹配输入序列的末尾，如果序列以行结束符结尾，则匹配该行结束符的前面的位置</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ java com.zfl9.regex.MatchTest '\A[\s\S]+?\Z' $'www.zfl9.com\n'
regex: "\A[\s\S]+?\Z"
input: "www.zfl9.com
"
[result-1]
    group0: "www.zfl9.com"

$ java com.zfl9.regex.MatchTest '\A[\s\S]+?\Z' $'www.zfl9.com\n\n'
regex: "\A[\s\S]+?\Z"
input: "www.zfl9.com

"
[result-1]
    group0: "www.zfl9.com
"
</script></code></pre>
<p><strong><code>\G</code> 匹配符的用处</strong><br><code>\G</code>：匹配上一次成功 match 的结束位置。上一次成功 match 是什么意思？【匹配过程】一节中其实已经提到过，如果你不懂请回去细读一遍。假设输入序列为 <code>match,match,match,no-match,match</code>（match 表示期望匹配的字符串，逗号请忽略，只不过是为了好区分而已）。如果正则模式为 <code>match</code>（启用 global 全局匹配 flag），那么模式匹配的字符串分别为：<code>match</code>、<code>match</code>、<code>match</code>、<code>match</code>，即 4 个 match 都被匹配到了。如果正则模式为 <code>\Gmatch</code>（启用 global 全局匹配 flag），那么模式匹配的字符串分别为：<code>match</code>、<code>match</code>、<code>match</code>，即前 3 个连续的 match，引擎到了 no-match 就会停止匹配，所以最后一个 match 不会被模式匹配到。先看个实际的例子，等会再进行解释：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ java com.zfl9.regex.MatchTest 'www.zfl9.com' $'www.zfl9.comwww.zfl9.comwww.zfl9.comwww.zfl8.comwww.zfl9.com'
regex: "www.zfl9.com"
input: "www.zfl9.comwww.zfl9.comwww.zfl9.comwww.zfl8.comwww.zfl9.com"
[result-1]
    group0: "www.zfl9.com"
[result-2]
    group0: "www.zfl9.com"
[result-3]
    group0: "www.zfl9.com"
[result-4]
    group0: "www.zfl9.com"

$ java com.zfl9.regex.MatchTest '\Gwww.zfl9.com' $'www.zfl9.comwww.zfl9.comwww.zfl9.comwww.zfl8.comwww.zfl9.com'
regex: "\Gwww.zfl9.com"
input: "www.zfl9.comwww.zfl9.comwww.zfl9.comwww.zfl8.comwww.zfl9.com"
[result-1]
    group0: "www.zfl9.com"
[result-2]
    group0: "www.zfl9.com"
[result-3]
    group0: "www.zfl9.com"

$ java com.zfl9.regex.MatchTest '\Gwww.zfl9.com' $'www.zfl9.com'
regex: "\Gwww.zfl9.com"
input: "www.zfl9.com"
[result-1]
    group0: "www.zfl9.com"

$ java com.zfl9.regex.MatchTest '\Gwww.zfl9.com' $' www.zfl9.com'
regex: "\Gwww.zfl9.com"
input: " www.zfl9.com"
</script></code></pre>
<p>我只解释一下最后一个例子：<br>正则模式：<code>\Gwww.zfl9.com</code><br>输入序列：<code>&#39; www.zfl9.com&#39;</code><br>匹配过程：<code>\G</code> 首先获得控制权，因为这是第一次开始匹配，所以 <code>\G</code> 总是会匹配成功（没有消耗字符）；然后控制权由 <code>w</code> 接手，开始匹配输入序列的第一个字符（空格），很显然匹配失败，而又因为当前不存在分支，所以本轮匹配失败，进入下一轮，丢弃第一个字符（空格）；第二轮匹配中，控制权又是先被 <code>\G</code> 获得，<code>\G</code> 首先尝试与第一个 w 前面的位置进行匹配，因为上次匹配成功的结束位置位于被丢弃的空格字符的前面，所以毫无疑问匹配失败，进入下一轮，丢弃第一个字符（w）；然后此轮匹配又是失败的，丢弃头一个字符，这个过程持续到输入序列的最后一个字符，所以最终整个模式匹配失败。</p>
<h2 id="贪婪量词"><a href="#贪婪量词" class="headerlink" title="贪婪量词"></a>贪婪量词</h2><blockquote>
<p><code>greedy</code>、贪婪量词会尽量将所修饰的子表达式应用 max 次、贪婪量词会进行回溯、<strong>量词默认都是贪婪的</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>X?</code></td>
<td style="text-align:center">匹配模式 X 0~1 次（含 0、1）</td>
</tr>
<tr>
<td style="text-align:center"><code>X*</code></td>
<td style="text-align:center">匹配模式 X 0+ 次（含 0）</td>
</tr>
<tr>
<td style="text-align:center"><code>X+</code></td>
<td style="text-align:center">匹配模式 X 1+ 次（含 1）</td>
</tr>
<tr>
<td style="text-align:center"><code>X{n}</code></td>
<td style="text-align:center">匹配模式 X n 次</td>
</tr>
<tr>
<td style="text-align:center"><code>X{n,}</code></td>
<td style="text-align:center">匹配模式 X n+ 次（含 n）</td>
</tr>
<tr>
<td style="text-align:center"><code>X{n,m}</code></td>
<td style="text-align:center">匹配模式 X n~m 次（含 n、m）</td>
</tr>
</tbody>
</table>
<h2 id="懒惰量词"><a href="#懒惰量词" class="headerlink" title="懒惰量词"></a>懒惰量词</h2><blockquote>
<p><code>reluctant</code>、懒惰量词会尽量将所修饰的子表达式应用 min 次、懒惰量词会进行回溯</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>X??</code></td>
<td style="text-align:center">匹配模式 X 0~1 次（含 0、1）</td>
</tr>
<tr>
<td style="text-align:center"><code>X*?</code></td>
<td style="text-align:center">匹配模式 X 0+ 次（含 0）</td>
</tr>
<tr>
<td style="text-align:center"><code>X+?</code></td>
<td style="text-align:center">匹配模式 X 1+ 次（含 1）</td>
</tr>
<tr>
<td style="text-align:center"><code>X{n}?</code></td>
<td style="text-align:center">匹配模式 X n 次</td>
</tr>
<tr>
<td style="text-align:center"><code>X{n,}?</code></td>
<td style="text-align:center">匹配模式 X n+ 次（含 n）</td>
</tr>
<tr>
<td style="text-align:center"><code>X{n,m}?</code></td>
<td style="text-align:center">匹配模式 X n~m 次（含 n、m）</td>
</tr>
</tbody>
</table>
<h2 id="占有量词"><a href="#占有量词" class="headerlink" title="占有量词"></a>占有量词</h2><blockquote>
<p><code>possessive</code>、占有量词会尽量将所修饰的子表达式应用 max 次、占有量词不进行回溯</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>X?+</code></td>
<td style="text-align:center">匹配模式 X 0~1 次（含 0、1）</td>
</tr>
<tr>
<td style="text-align:center"><code>X*+</code></td>
<td style="text-align:center">匹配模式 X 0+ 次（含 0）</td>
</tr>
<tr>
<td style="text-align:center"><code>X++</code></td>
<td style="text-align:center">匹配模式 X 1+ 次（含 1）</td>
</tr>
<tr>
<td style="text-align:center"><code>X{n}+</code></td>
<td style="text-align:center">匹配模式 X n 次</td>
</tr>
<tr>
<td style="text-align:center"><code>X{n,}+</code></td>
<td style="text-align:center">匹配模式 X n+ 次（含 n）</td>
</tr>
<tr>
<td style="text-align:center"><code>X{n,m}+</code></td>
<td style="text-align:center">匹配模式 X n~m 次（含 n、m）</td>
</tr>
</tbody>
</table>
<h2 id="逻辑连接符"><a href="#逻辑连接符" class="headerlink" title="逻辑连接符"></a>逻辑连接符</h2><table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>XY</code></td>
<td style="text-align:center">[逻辑与] 最普通的一种形式</td>
</tr>
<tr>
<td style="text-align:center"><code>X｜Y</code></td>
<td style="text-align:center">[逻辑或]，比如<code>g｜food</code>匹配<code>g</code>或<code>food</code>，<code>(g｜f)ood</code>匹配<code>good</code>或<code>food</code>，不过为了不被当作捕获组，我一般都会使用<code>(?:g｜f)ood</code>来消除这一副作用</td>
</tr>
</tbody>
</table>
<h2 id="捕获组"><a href="#捕获组" class="headerlink" title="捕获组"></a>捕获组</h2><table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>(X)</code></td>
<td style="text-align:center">将 X 匹配的序列存储起来，作为一个捕获组，后续可引用该捕获组的内容</td>
</tr>
<tr>
<td style="text-align:center"><code>(?&lt;name&gt;X)</code></td>
<td style="text-align:center">定义命名捕获组，必须以字母开头，后面可接数字和字母。即使是命名捕获组，我们依旧可以根据组号 N 来引用它。给它定义名字只不过是为了方便引用而已</td>
</tr>
</tbody>
</table>
<h2 id="非捕获组"><a href="#非捕获组" class="headerlink" title="非捕获组"></a>非捕获组</h2><table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>(?:X)</code></td>
<td style="text-align:center">逻辑上的括号，一般用于限定一个范围，或者将表达式 X 作为一个整体</td>
</tr>
<tr>
<td style="text-align:center"><code>(?&gt;X)</code></td>
<td style="text-align:center">原子组，原子组中的子表达式的任何回溯点都会被丢弃（即不保存任何分支）</td>
</tr>
</tbody>
</table>
<p><strong>非捕获组</strong><br>比如<code>(?:\d{3})+</code>表示长度为 3N (N &gt;= 1) 的连续数字序列，而<code>\d{3}+</code>的意义却完全不同了，我们来解析一下，这里存在三个元素<code>\d</code>、<code>{3}</code>、<code>+</code>，元素二和元素三都属于量词，但是在正则模式中，如果存在两个连续的量词，则会将 “贪婪量词” -&gt; “懒惰量词”/“占有量词”，而两个以上的连续量词是不允许的，会导致语法错误！这一点要十分清楚，刚开始时我也稀里糊涂的：</p>
<ul>
<li><code>.*</code>：为 “贪婪属性”</li>
<li><code>.*?</code>：为 “懒惰属性”</li>
<li><code>.*+</code>：为 “占有属性”</li>
<li><code>.*??</code>：非法，语法错误</li>
<li><code>.*++</code>：非法，语法错误</li>
</ul>
<p><strong>原子组</strong><br><strong>原子组中的子表达式的任何回溯点都会被丢弃（即不保存任何分支）</strong>，因此位于原子组中的<code>贪婪量词</code>、<code>懒惰量词</code>、<code>分支语句</code>都不会被执行回溯操作：</p>
<ul>
<li><code>贪婪量词</code>：吃完了当前能够吃的所有字符后，它将不会再吐出来了；</li>
<li><code>懒惰量词</code>：吃完了 min 次能够吃掉的字符后，它将不会再吃进去了；</li>
<li><code>分支语句</code>：对于模式 (?&gt;X|Y|Z) 只会执行 X 分支，其它分支被丢弃。</li>
</ul>
<h2 id="反向引用"><a href="#反向引用" class="headerlink" title="反向引用"></a>反向引用</h2><p>对于 Java：如果是在正则模式中使用则语法为 <code>\n</code>，如果是在替换文本中使用则语法为 <code>$n</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">引用捕获组 n (0 &lt;= n &lt;= 9)，在 Java 中，N 的第一位数字总是会被解释为第 N 组，而不管模式中有没有这个组，当然如果模式中的捕获组有 10+ 以上，那么 $10、$11 之类的引用也是合法的，可以被 Java 正则引擎解释</td>
</tr>
<tr>
<td style="text-align:center"><code>\k&lt;name&gt;</code></td>
<td style="text-align:center">引用捕获组 name，即引用具名捕获组，当然，即使是有名字的捕获组，我们也是可以根据组号来引用它，给它命名只不过为了好记而已</td>
</tr>
</tbody>
</table>
<h2 id="字面引用"><a href="#字面引用" class="headerlink" title="字面引用"></a>字面引用</h2><blockquote>
<p>宽度为 0</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\</code></td>
<td style="text-align:center">用于转义随后的字符，它本身不匹配任何内容，除非使用<code>\\</code></td>
</tr>
<tr>
<td style="text-align:center"><code>\Q</code></td>
<td style="text-align:center">用于表示一个普通字符序列的开始，它本身不匹配任何内容</td>
</tr>
<tr>
<td style="text-align:center"><code>\E</code></td>
<td style="text-align:center">用于表示一个普通字符序列的结束，它本身不匹配任何内容</td>
</tr>
</tbody>
</table>
<h2 id="环视-预查"><a href="#环视-预查" class="headerlink" title="环视/预查"></a>环视/预查</h2><blockquote>
<p>宽度为 0、<code>零宽断言</code>、<strong>逆序环视中不允许存在不定长量词</strong></p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>(?=X)</code></td>
<td style="text-align:center"><strong>顺序肯定环视</strong>，表示所在位置的右侧能够匹配子表达式 X</td>
</tr>
<tr>
<td style="text-align:center"><code>(?!X)</code></td>
<td style="text-align:center"><strong>顺序否定环视</strong>，表示所在位置的右侧不能匹配子表达式 X</td>
</tr>
<tr>
<td style="text-align:center"><code>(?&lt;=X)</code></td>
<td style="text-align:center"><strong>逆序肯定环视</strong>，表示所在位置的左侧能够匹配子表达式 X</td>
</tr>
<tr>
<td style="text-align:center"><code>(?&lt;!X)</code></td>
<td style="text-align:center"><strong>逆序否定环视</strong>，表示所在位置的左侧不能匹配子表达式 X</td>
</tr>
</tbody>
</table>
<h2 id="正则-flags"><a href="#正则-flags" class="headerlink" title="正则 flags"></a>正则 flags</h2><table>
<thead>
<tr>
<th style="text-align:center">表达式</th>
<th style="text-align:center">解释说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>(?idmsuxU-idmsuxU)</code></td>
<td style="text-align:center">不匹配任何字符，而是打开或关闭给定的正则模式标志位，其作用范围是从该模式位置到模式结束位置，可以理解为全局。<code>-</code>前面的表示要打开的标志位，<code>-</code>后面的表示要关闭的标志位</td>
</tr>
<tr>
<td style="text-align:center"><code>(?idmsux-idmsux:X)</code></td>
<td style="text-align:center">同上，但是作用范围仅限于圆括号内部，即仅针对表达式 X 设置</td>
</tr>
</tbody>
</table>
<h2 id="其它说明"><a href="#其它说明" class="headerlink" title="其它说明"></a>其它说明</h2><pre><code class="language-java line-numbers"><script type="text/plain">/* 转义字符 */
// 在非转义字母字符前添加 \，会导致 PatternSyntaxException 异常，如 \j
// 允许在非字母字符前添加 \，正则模式在编译时不会报错，没有影响，如 \@
// 因为 Java 本身的字符串转义，因此正则模式中的 \ 须表示为 \\，如模式 \[ 须写做 \\[
// Java 的正则库支持中文，不需要像 PCRE 库那样添加前缀 (*UTF8) 来启用 Unicode 支持

/* 行结束符 */
// 行结束符是一个单字符或双字符序列，用于标记输入字符序列的一行的结尾。以下是公认的行结束符：
// 1. LF 换行符（Unix）：'\n'
// 2. CRLF 回车换行（Windows）："\r\n"
// 3. CR 回车符：'\r'
// 4. NEL 符（下一行符）：'\u0085'
// 5. LS 符（行分隔符）：'\u2028'
// 6. PS 符（段落分隔符）：'\u2029'

"如果启用 UNIX_LINES 标志，则只有 '\n' 换行符是被正则认可的行结束符"
"正则模式 . 默认匹配除行结束符外的任意字符，除非启用 DOTALL 单行模式"
"默认情况下，^、$ 匹配输入字符序列的起始和结束位置，即忽略行结束符"
"如果启用 MULTILINE 标志，则 ^ 还会匹配行结束符之后的位置，$ 还会匹配行结束符之前的位置"

/* 捕获组 */
// 捕获组通过从左到右数起的左括号数进行编号，如模式 ((A)(B(C))) 有这四个组：
// 1. ((A)(B(C)))
// 2. (A)
// 3. (B(C))
// 4. (C)

"组号为 0 总是代表整个匹配的表达式" "在替换模式中，不使用 \N 来引用捕获组，而是使用 $N 来引用"
"捕获组可以有名字，组名必须以字母开头，后可接大小写字母和数字。命名捕获组依旧按照组号进行编号。"

/* Unicode 字符支持 */
// 如果启用 UNICODE_CHARACTER_CLASS 标志，则"预定义字符集合"和"POSIX字符集合"将支持 Unicode 字符
// 比如模式 "\w+" 只能匹配 "world" 而不能匹配 "世界"，但是模式 "(?U)\w+" 对于两种情况都会匹配成功

/* 对比 Perl 5 的正则 */
// Java 和 Perl 5 都是使用 "传统型 NFA 引擎" 进行正则匹配的。
//
// "Perl 支持而 Java 不支持的语法"
// - 预定义的字符类(Unicode 字符)："\X" 匹配 Unicode 扩展字形群集
// - 使用反向引用 "\g{N}"、"\g{name}" 来引用匿名捕获组、具名捕获组
// - 字符结构 "\N{name}" 表示名为 name 的 Unicode 字符
// - 条件结构 "(?(condition)X)"、"(?(condition)X|Y)"
// - 嵌入代码结构 "(?{code})"、"(??{code})"
// - 嵌入注释语法 (?#comment)
// - 预处理操作 "\l"、"\u"、"\L"、"\U"
//
// "Java 支持而 Perl 不支持的语法"
// - "自定义字符集合" 中的 "逻辑或"、"逻辑与" 语法
//
// "Java 与 Perl 正则的显著差异"
// - 在 Perl 中，\1 ~ \9 总是被解释为反向引用，如果存在 10+ 个子捕获组，则 \10+ 也会被解释
//   为反向引用，否则将被尝试解释为八进制数值转义。
// - 在 Java 中，\1 ~ \9 总是被解释为反向引用，如果存在 10+ 个子捕获组，则 \10+ 也会被解释
//   为反向引用，否则解释器将丢弃数字，直到数字小于或等于现有的子捕获组数，或者为单个数字。
//   而对于八进制数值转义，数值部分必须以 0 开头，否则不会被当作八进制数值来解释。
// - 在 Perl 中，使用 g 标志来启用全局匹配（即匹配了第一次后不会立即返回，而是一直尝试匹配，
//   直到当前字符序列被传动完毕）。而在 Java 中，该功能由 Matcher.find() 方法提供，它将会一
//   直匹配模式，直到当前字符序列被转动完毕。
// - 在 Perl 中，正则模式顶级的嵌入式标志会影响整个表达式的匹配属性。而在 Java 中，嵌入式标
//   志总是从定义的地方开始生效，如果是 (?flags-flags:X)，则嵌入式标志只在圆括号范围内生效。
</script></code></pre>
<h2 id="环视常见用法"><a href="#环视常见用法" class="headerlink" title="环视常见用法"></a>环视常见用法</h2><ol>
<li>顺序肯定常规<code>[a-z]+(?=;)</code>：字母序列后面跟着<code>;</code></li>
<li>顺序肯定变种<code>(?=[a-z]+$).+$</code>：字母序列</li>
<li>顺序否定常规<code>[a-z]+\b(?!;)</code>：不以<code>;</code>结尾的字母序列</li>
<li>顺序否定变种<code>(?!.*?[lo0])\b[a-z0-9]+\b</code>：不包含<code>l/o/0</code>的字母数字序列</li>
<li>逆序肯定常规<code>(?&lt;=:)[0-9]+</code>：<code>:</code>后面的数字序列</li>
<li>逆序肯定变种<code>\b[0-9]\b(?&lt;=[13579])</code>：0~9 中的奇数</li>
<li>逆序否定常规<code>(?&lt;!age)=([0-9]+)</code>：参数名不为 age 的数据</li>
<li>逆序否定变种<code>\b[a-z]+(?&lt;!z)\b</code>：不以 z 结尾的单词</li>
</ol>
<h2 id="正则测试工具"><a href="#正则测试工具" class="headerlink" title="正则测试工具"></a>正则测试工具</h2><p>正则测试工具[在线工具] -&gt; <a href="http://regex.zjmainstay.cn/" rel="external nofollow noopener noreferrer" target="_blank">正则表达式测试工具在线调试与分享 - Zjmainstay</a></p>
<p><strong>使用图解 - 图片</strong><br><img src="http://qiniu-img.zjmainstay.cn/regex.zjmainstay.cn.jpg" alt="正则在线测试"></p>
<p><strong>使用图解 - gif</strong><br><img src="http://qiniu-img.zjmainstay.cn/regex.zjmainstay.cn-usage-demo.gif" alt="正则在线测试"></p>
<p><strong>个人截图 - 千分位格式化</strong><br><img src="/images/regex-web-1.png" alt="正则在线测试"></p>
<p><strong>个人截图 - 千分位格式化(正则匹配过程)</strong><br><img src="/images/regex-web-2.png" alt="正则在线测试"></p>
<p>正则测试工具[Windows版] -&gt; <a href="https://www.regexbuddy.com/" rel="external nofollow noopener noreferrer" target="_blank">Learn, Create, Understand, Test, Use and Save Regular Expressions with RegexBuddy</a></p>
<p><strong>主界面详细介绍</strong><br><img src="http://qiniu-img.zjmainstay.cn/regexbuddy/regexbuddy_view_options.gif" alt="主界面详细介绍"></p>
<p><strong>如何使用匹配功能</strong><br><img src="http://qiniu-img.zjmainstay.cn/regexbuddy/regexbuddy_view_match.gif" alt="如何使用匹配功能"></p>
<p><strong>如何使用替换功能</strong><br><img src="http://qiniu-img.zjmainstay.cn/regexbuddy/regexbuddy_view_replace.gif" alt="如何使用替换功能"></p>
<p><strong>如何进行 debug 调试</strong><br><img src="http://qiniu-img.zjmainstay.cn/regexbuddy/regexbuddy_view_debug.gif" alt="如何进行 debug 调试"></p>
<h2 id="正则练习题"><a href="#正则练习题" class="headerlink" title="正则练习题"></a>正则练习题</h2><p>正则掌握程度测试题（Zjmainstay 学习笔记） -&gt; <a href="https://www.zybuluo.com/Zjmainstay/note/709093" rel="external nofollow noopener noreferrer" target="_blank">正则练习题</a></p>
    </div>
    <div>
    </div>
    <div>
    </div>
    <div>
    </div>
    <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/正则表达式/" rel="tag"># 正则表达式</a>
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/centos7-change-summary.html" rel="next" title="CentOS/RHEL7 变化汇总">
                <i class="fa fa-chevron-left"></i> CentOS/RHEL7 变化汇总
              </a>
          </div>
          <span class="post-nav-divider"></span>
          <div class="post-nav-prev post-nav-item">
              <a href="/vsftpd.html" rel="prev" title="vsftpd 被动模式">
                vsftpd 被动模式 <i class="fa fa-chevron-right"></i>
              </a>
          </div>
        </div>
    </footer>
  </article>
    <div class="post-spread">
    </div>
  </div>
          </div>
  <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer" target="_blank">comments powered by Disqus.</a>
        </noscript>
      </div>
  </div>
        </div>
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>
  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Otokaze">
          <p class="site-author-name" itemprop="name">Otokaze</p>
              <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">170</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
        </nav>
        <div class="links-of-author motion-element">
              <span class="links-of-author-item">
                <a href="https://github.com/zfl9" target="_blank" title="GitHub rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-github"></i>
                  GitHub
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="mailto:zfl9.com@gmail.com" target="_blank" title="Email rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-envelope"></i>
                  Email
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://gitlab.com/zfl9" target="_blank" title="GitLab rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-gitlab"></i>
                  GitLab
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://t.me/Otokaze" target="_blank" title="Telegram rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-telegram"></i>
                  Telegram
                </a>
              </span>
        </div>
      </section>
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#预备知识"><span class="nav-number">1.</span> <span class="nav-text">预备知识</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匹配过程"><span class="nav-number">2.</span> <span class="nav-text">匹配过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字符"><span class="nav-number">3.</span> <span class="nav-text">字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#自定义字符集合"><span class="nav-number">4.</span> <span class="nav-text">自定义字符集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#预定义字符集合"><span class="nav-number">5.</span> <span class="nav-text">预定义字符集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#POSIX-字符集合"><span class="nav-number">6.</span> <span class="nav-text">POSIX 字符集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-字符集合"><span class="nav-number">7.</span> <span class="nav-text">Java 字符集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Unicode-字符集合"><span class="nav-number">8.</span> <span class="nav-text">Unicode 字符集合</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#边界匹配符"><span class="nav-number">9.</span> <span class="nav-text">边界匹配符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#贪婪量词"><span class="nav-number">10.</span> <span class="nav-text">贪婪量词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#懒惰量词"><span class="nav-number">11.</span> <span class="nav-text">懒惰量词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#占有量词"><span class="nav-number">12.</span> <span class="nav-text">占有量词</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#逻辑连接符"><span class="nav-number">13.</span> <span class="nav-text">逻辑连接符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#捕获组"><span class="nav-number">14.</span> <span class="nav-text">捕获组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非捕获组"><span class="nav-number">15.</span> <span class="nav-text">非捕获组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#反向引用"><span class="nav-number">16.</span> <span class="nav-text">反向引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#字面引用"><span class="nav-number">17.</span> <span class="nav-text">字面引用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环视-预查"><span class="nav-number">18.</span> <span class="nav-text">环视/预查</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则-flags"><span class="nav-number">19.</span> <span class="nav-text">正则 flags</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#其它说明"><span class="nav-number">20.</span> <span class="nav-text">其它说明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#环视常见用法"><span class="nav-number">21.</span> <span class="nav-text">环视常见用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则测试工具"><span class="nav-number">22.</span> <span class="nav-text">正则测试工具</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#正则练习题"><span class="nav-number">23.</span> <span class="nav-text">正则练习题</span></a></li></ol></div>
          </div>
        </section>
      <!--/noindex-->
    </div>
  </aside>
      </div>
    </main>
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Otokaze</span>
</div>
<script src="/js/clipboard.min.js"></script>
<script src="/js/prism/prism.js" async></script>
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
  </div>
<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>
      <script id="dsq-count-scr" src="https://otokaze.disqus.com/count.js" async></script>
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://www.zfl9.com/regex.html';
          this.page.identifier = 'regex.html';
          this.page.title = '正则表达式';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://otokaze.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("3hhdw6gOg9wavsharVwVjqI3-gzGzoHsz", "O5WfDffqFsgmAVPwNY9of3QU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");
      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });
      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';
          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);
            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);
      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }
    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</body>
</html>
