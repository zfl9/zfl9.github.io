<!doctype html>
<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">
<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">
<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">
  <meta name="keywords" content="java,">
  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1">
<meta name="description" content="MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或 Java 注解来配置和映射原生信息，将接口和 Java 的 POJOs（Plain Old Java Objects，普通 Java 对象）映射成数据库中的记录。">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="MyBatis 笔记">
<meta property="og:url" content="https://www.zfl9.com/mybatis.html">
<meta property="og:site_name" content="Otokaze's Blog">
<meta property="og:description" content="MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或 Java 注解来配置和映射原生信息，将接口和 Java 的 POJOs（Plain Old Java Objects，普通 Java 对象）映射成数据库中的记录。">
<meta property="og:image" content="https://www.zfl9.com/images/mysql-last-insert-id.png">
<meta property="og:image" content="https://www.zfl9.com/images/mysql-last-insert-id-result1.png">
<meta property="og:image" content="https://www.zfl9.com/images/mysql-last-insert-id-result2.png">
<meta property="og:image" content="https://www.zfl9.com/images/mybatis-crud-table.png">
<meta property="og:image" content="https://www.zfl9.com/images/mybatis-first-level-cache.png">
<meta property="og:image" content="https://www.zfl9.com/images/mybatis-first-level-cache-class.png">
<meta property="og:image" content="https://www.zfl9.com/images/mybatis-first-level-cache-yuanli.png">
<meta property="og:image" content="https://www.zfl9.com/images/mybatis-second-level-cache.png">
<meta property="og:image" content="https://www.zfl9.com/images/mybatis-enum-typehandler.png">
<meta property="og:image" content="https://www.zfl9.com/images/mybatis-yuanli.png">
<meta property="og:updated_time" content="2020-07-04T13:10:25.265Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MyBatis 笔记">
<meta name="twitter:description" content="MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或 Java 注解来配置和映射原生信息，将接口和 Java 的 POJOs（Plain Old Java Objects，普通 Java 对象）映射成数据库中的记录。">
<meta name="twitter:image" content="https://www.zfl9.com/images/mysql-last-insert-id.png">
<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
  <link rel="canonical" href="https://www.zfl9.com/mybatis.html">
<link href="/js/prism/prism.css" rel="stylesheet">
  <title>MyBatis 笔记 | Otokaze's Blog</title>
</head>
<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-97872912-1', 'auto');
  ga('send', 'pageview');
</script>
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3d58f51dbb2496a0e6d17b85065a5ae5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Otokaze's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">拼一年春夏秋冬，搏一生无怨无悔</h1>
  </div>
  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>
<nav class="site-nav">
    <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            首页
          </a>
        </li>
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            分类
          </a>
        </li>
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            标签
          </a>
        </li>
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            归档
          </a>
        </li>
    </ul>
</nav>
 </div>
    </header>
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
  <div id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.zfl9.com/mybatis.html">
    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Otokaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>
    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Otokaze's Blog">
    </span>
      <header class="post-header">
          <h2 class="post-title" itemprop="name headline">
                MyBatis 笔记
          </h2>
        <div class="post-meta">
          <span class="post-time">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
                <span class="post-meta-item-text">发表于</span>
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-12-19T08:00:00+08:00">
                2018-12-19
              </time>
          </span>
            <span class="post-category">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
                <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/mybatis.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="mybatis.html" itemprop="commentCount"></span>
                </a>
              </span>
             <span id="/mybatis.html" class="leancloud_visitors" data-flag-title="MyBatis 笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
                 <span class="post-meta-item-text">阅读次数 </span>
                 <span class="leancloud-visitors-count"></span>
             </span>
        </div>
      </header>
    <div class="post-body" itemprop="articleBody">
        <p>MyBatis 是一款优秀的持久层框架，它支持定制化 SQL、存储过程以及高级映射。MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或 Java 注解来配置和映射原生信息，将接口和 Java 的 POJOs（Plain Old Java Objects，普通 Java 对象）映射成数据库中的记录。</p>
<a id="more"></a>
<h2 id="插曲"><a href="#插曲" class="headerlink" title="插曲"></a>插曲</h2><p>学习 MyBatis 之前先来个小插曲，即如何在 JDBC 中获取 MySQL 自增主键的值（插入一条新纪录的时候），有两种方法，一种是使用原生的 SQL 语句，即 <code>select last_insert_id()</code>，另一种方法则是使用 JDBC 3.0 提供的 <code>getGeneratedKeys()</code> API，推荐使用后者，少了一次 SQL 查询，效率更高。</p>
<p>我们先来看看 <code>select last_insert_id()</code> 方式，在使用它之前，我们先说一下它的几个特点：</p>
<ul>
<li>insert 和 select 语句所使用的 Connection 必须是同一个，否则返回值是不可预料的。</li>
<li>LAST_INSERT_ID() 与表无关，如果向表 A 插入数据后再向表 B 插入数据，LAST_INSERT_ID 返回表 B 的 id。</li>
<li>假如你使用一条 INSERT 语句插入多个行，LAST_INSERT_ID() 只返回插入第一行数据时产生的 id 值（需要特别注意）。</li>
<li>假如你使用 INSERT IGNORE，则 AUTO_INCREMENT 计数器不会增量，而 LAST_INSERT_ID() 返回 0，表示没有插入新纪录。</li>
</ul>
<p>select last_insert_id() 的原理大概是这样的，mysql 会在每个 connection 中将上一次自增出来的 id 值保存到一个 connection 变量中，而 last_insert_id() 函数其实就是读取的这个变量而已，因为是保存在每个 connection 中，所以不同 connection（mybatis 中就是不同的 sqlSession）中保存的 last_insert_id 是不一样的，互不影响。所以只要每个线程拥有的 sqlSession/connection 不同，select last_insert_id() 就是安全的，只是需要注意一下，如果一次性插入多行，如 <code>insert into employee(name, email) values(A, B), (C, D), (E, F)</code>，那么实际上 last_insert_id() 返回的只是 <code>(A, B)</code> 这条记录的自增 ID 值！这时候就需要在程序中处理一下，加上个 2 才是 <code>(E, F)</code> 记录的自增 ID 值。</p>
<p>我们来在 mysql 中测试一下，看看是否符合我们上面的定义：<br><img src="/images/mysql-last-insert-id.png" alt="MySQL Last Insert Id"><br><img src="/images/mysql-last-insert-id-result1.png" alt="MySQL Last Insert Id Result 1"><br><img src="/images/mysql-last-insert-id-result2.png" alt="MySQL Last Insert Id Result 2"></p>
<p>OK，接下来我们来看下 JDBC 3.0 提供的 getGeneratedKeys() 方法如何使用，看看是否有插入多条记录的问题：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9;

import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import org.junit.Test;

public class JdbcGenKeyTest {
    @Test
    public void test() {
        Connection connection = null;
        Statement statement = null;
        ResultSet resultSet = null;
        try {
            connection = DriverManager.getConnection("jdbc:mysql://localhost/test?serverTimezone=UTC", "root", "123456");
            statement = connection.createStatement();
            statement.executeUpdate("insert into test(name) values('zfl9'),('baidu'),('google')", Statement.RETURN_GENERATED_KEYS);
            resultSet = statement.getGeneratedKeys();
            while (resultSet.next()) {
                int jdbcGenKey = resultSet.getInt(1);
                System.out.println("jdbc gen key: " + jdbcGenKey);
            }
        } catch (SQLException e) {
            e.printStackTrace();
        } finally {
            if (resultSet != null) {
                try {
                    resultSet.close();
                } catch (SQLException e) {
                }
            }
            if (statement != null) {
                try {
                    statement.close();
                } catch (SQLException e) {
                }
            }
            if (connection != null) {
                try {
                    connection.close();
                } catch (SQLException e) {
                }
            }
        }
    }
}
</script></code></pre>
<p>执行结果：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
jdbc gen key: 1
jdbc gen key: 2
jdbc gen key: 3
</script></code></pre>
<p>没有问题，JDBC 提供的 getGeneratedKeys() API 可以返回多个自增生成的 ID，只要使用 while 去遍历结果集就行。</p>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p>使用 mybatis 很简单，只需要一个 <code>mybatis-x.x.x.jar</code> 依赖包，当然为了连接数据库，我们还需要一个 <code>mysql-connector-java-x.x.x.jar</code> 依赖包，使用 maven 构建项目的话，只需添加以下 dependency 到 pom.xml：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<dependency>
  <groupId>mysql</groupId>
  <artifactId>mysql-connector-java</artifactId>
  <version>8.0.13</version>
  <scope>runtime</scope>
</dependency>

<dependency>
  <groupId>org.mybatis</groupId>
  <artifactId>mybatis</artifactId>
  <version>3.4.6</version>
</dependency>
</script></code></pre>
<p><strong>mybatis 的四大核心概念</strong><br>即 <code>SqlSessionFactoryBuilder</code>、<code>SqlSessionFactory</code>、<code>SqlSession</code>、<code>Mapper</code>，只要了解了这几大概念，就可知 MyBatis 八九。</p>
<p><strong>SqlSessionFactoryBuilder</strong><br>从命名上可以看出，这是一个 Builder 模式的，用于创建 SqlSessionFactory 的类。SqlSessionFactoryBuilder 根据配置来构造 SqlSessionFactory。配置方式有两种，一种是常用的 XML 文件方式，另一种则是 Java Config 方式，如下：</p>
<p>1、XML 配置</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
String resource = "org/mybatis/example/mybatis-config.xml";
InputStream inputStream = Resources.getResourceAsStream(resource);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);
</script></code></pre>
<p>mybatis-config.xml 就是 MyBatis 的主配置文件：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration
  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <environments default="development">
    <environment id="development">
      <transactionManager type="JDBC"/>
      <dataSource type="POOLED">
        <property name="driver" value="${driver}"/>
        <property name="url" value="${url}"/>
        <property name="username" value="${username}"/>
        <property name="password" value="${password}"/>
      </dataSource>
    </environment>
  </environments>
  <mappers>
    <mapper resource="org/mybatis/example/BlogMapper.xml"/>
  </mappers>
</configuration>
</script></code></pre>
<p>2、Java Config</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
DataSource dataSource = BlogDataSourceFactory.getBlogDataSource();
TransactionFactory transactionFactory = new JdbcTransactionFactory();
Environment environment = new Environment("development", transactionFactory, dataSource);
Configuration configuration = new Configuration(environment);
configuration.addMapper(BlogMapper.class);
SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(configuration);
</script></code></pre>
<p>Java Config 相比较 XML 文件的方式而言，会有一些限制。比如修改了配置文件需要重新编译，注解方式没有 XML 配置项多等。所以，业界大多数情况下是选择 XML 文件的方式。但到底选择哪种方式，这个要取决与自己团队的需要。比如，项目的 SQL 语句不复杂，也不需要一些高级的 SQL 特性，那么 Java Config 则会更加简洁一点；反之，则可以选择 XML 文件的方式。</p>
<p><strong>SqlSessionFactory</strong><br>SqlSessionFactory 顾名思义，就是用于生产 SqlSession 的工厂。通过 SqlSessionFactory 的 openSession() 方法来获取 sqlSession 实例：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
SqlSession session = sqlSessionFactory.openSession();
</script></code></pre>
<p><strong>SqlSession</strong><br>SqlSession 包含了执行 SQL 的所有方法，基本上你可以将其看作为 JDBC 中的 Connection，例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
SqlSession session = sqlSessionFactory.openSession();
try {
  Blog blog = session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);
} finally {
  session.close();
}
</script></code></pre>
<p>当然上面这种是 mybatis 旧版本中使用的方式，不能做到类型安全，因为全是字符串，新版可以这样做：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
SqlSession session = sqlSessionFactory.openSession();
try {
  BlogMapper mapper = session.getMapper(BlogMapper.class);
  Blog blog = mapper.selectBlog(101);
} finally {
  session.close();
}
</script></code></pre>
<p><strong>Mapper</strong><br>Mapper 顾名思义，是用做 Java 与 SQL 之间的映射的。包括了 Java 映射为 SQL 语句，以及 SQL 返回结果映射为 Java。比如这是一个常见的 Mapper 接口映射文件，注意 namespace 不要乱取，它是这个 mapper.xml 对应的 Mapper 接口的全限定类名，而里面的 select、insert、update、delete 语句的 id 就是这个 Mapper 接口里面的方法名，mybatis 会自动将这个 Mapper 接口和 Mapper.xml 映射文件对应起来，然后我们就能直接像上面那样，直接调用 Mapper 接口中的方法来执行底层的数据库操作了，比如 session.selectOne(id, arg)，做到类型安全。</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
  "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="org.mybatis.example.BlogMapper">
  <select id="selectBlog" resultType="Blog">
    select * from Blog where id = #{id}
  </select>
</mapper>
</script></code></pre>
<p>当然即使存在一对 Mapper 接口和 Mapper 映射文件，我们也还可以使用旧版本中的非类型安全方式，但更建议使用类型安全方式：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
Blog blog = (Blog) session.selectOne("org.mybatis.example.BlogMapper.selectBlog", 101);
</script></code></pre>
<pre><code class="language-java line-numbers"><script type="text/plain">
BlogMapper mapper = session.getMapper(BlogMapper.class);
Blog blog = mapper.selectBlog(101);
</script></code></pre>
<p>当然，mybatis 3 也支持注解形式的 mapper.xml 配置，和 spring 有点像，即我们可以直接在 BlogMapper 接口中写上我们的 sql 语句：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package org.mybatis.example;
public interface BlogMapper {
  @Select("SELECT * FROM blog WHERE id = #{id}")
  Blog selectBlog(int id);
}
</script></code></pre>
<p>这种情况下，就不需要对应的 mapper.xml 映射文件了，但是由于 Java 注解的局限性，很多映射选项我们不能用在注解形式的配置上，所以用的最多的还是映射文件形式，这个和 Spring 基本是相反的，因为 Spring 的话，貌似全部使用 Java Annotation 形式会更简洁（但我自己不太喜欢全部用注解）。</p>
<p><strong>官方文档中关于这四大概念的解释</strong><br>每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为中心的（静态单例模式）。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。</p>
<p>从 XML 文件中构建 SqlSessionFactory 的实例非常简单，建议使用类路径下的资源文件进行配置。但是也可以使用任意的输入流（InputStream）实例，包括相对于 classpath 的路径（resource）或者相对于文件系统的绝对路径（<code>file://</code>，url）来配置。MyBatis 包含一个名叫 Resources 的实用工具类，它包含一些实用方法，能够让我们更加容易的从 classpath 或文件系统中加载资源文件。</p>
<p>XML 配置文件（configuration XML）中包含了对 MyBatis 的核心设置，包含获取数据库连接实例的数据源（DataSource）和决定事务作用域和控制方式的事务管理器（TransactionManager）。XML 配置文件的详细内容后面再探讨，上面也给出了对应的配置文件例子。当然，还有很多配置项可以在 XML 文件中进行配置，上面的示例指出的则是最关键的部分。要注意 XML 头部的声明，用来验证 XML 文档正确性。environment 元素中包含了 <strong>事务管理</strong> 和 <strong>数据库连接池</strong> 的配置。mappers 元素则是包含一组 mapper <strong>映射器</strong>（这些 mapper 的 XML 文件包含了 SQL 代码和映射定义信息）。</p>
<p>当然也可以不使用任何 XML 配置文件（包括配置文件和映射文件），而是全部使用 Java 代码 + Java 注解的形式来进行 MyBatis 系统的配置。注意到我们上面的 Java Config 代码中，添加了一个 BlogMapper 映射接口，这样做的目的是为了完全脱离 Mapper.xml 映射文件。不过，由于 Java 注解的一些限制加之某些 MyBatis 映射的复杂性，XML 映射对于大多数高级映射（比如：嵌套 Join 映射）来说仍然是必须的。有鉴于此，如果存在一个对等的 XML 配置文件的话，MyBatis 会自动查找并加载它（这种情况下，BlogMapper.xml 将会基于类路径和 BlogMapper.class 的类名被加载进来，举个例子就是如果类路径的同一个目录中，存在 BlogMapper.class 和 BlogMapper.xml 两个文件，那么即使是纯 Java 形式，MyBatis 也会加载这个 XML 文件）。</p>
<p><strong>四个核心对象的作用域与生命周期</strong><br>1、SqlSessionFactoryBuilder<br>这个类可以被实例化、使用和丢弃，一旦创建了 SqlSessionFactory，就不再需要它了。因此 SqlSessionFactoryBuilder 实例的最佳作用域是方法作用域（也就是局部方法变量）。你可以重用 SqlSessionFactoryBuilder 来创建多个 SqlSessionFactory 实例，但是最好还是不要让其一直存在以保证所有的 XML 解析资源开放给更重要的事情。</p>
<p>2、SqlSessionFactory<br>SqlSessionFactory 一旦被创建就应该在应用的运行期间一直存在，没有任何理由对它进行清除或重建。使用 SqlSessionFactory 的最佳实践是在应用运行期间不要重复创建多次，多次重建 SqlSessionFactory 被视为一种代码“坏味道（bad smell）”。因此 SqlSessionFactory 的最佳作用域是应用作用域。有很多方法可以做到，最简单的就是使用单例模式或者静态单例模式。</p>
<p>3、SqlSession<br>每个线程都应该有它自己的 SqlSession 实例。SqlSession 的实例不是线程安全的，因此是不能被共享的，所以它的最佳的作用域是请求或方法作用域。绝对不能将 SqlSession 实例的引用放在一个类的静态域，甚至一个类的实例变量也不行。也绝不能将 SqlSession 实例的引用放在任何类型的管理作用域中，比如 Servlet 架构中的 HttpSession。如果你现在正在使用一种 Web 框架，要考虑 SqlSession 放在一个和 HTTP 请求对象相似的作用域中。换句话说，每次收到的 HTTP 请求，就可以打开一个 SqlSession，返回一个响应，就关闭它。这个关闭操作是很重要的，你应该把这个关闭操作放到 finally 块中以确保每次都能执行关闭。下面的示例就是一个确保 SqlSession 关闭的标准模式：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
SqlSession session = sqlSessionFactory.openSession();
try {
  // do work
} finally {
  session.close();
}
</script></code></pre>
<p>4、映射器实例（Mapper Instances）<br>映射器是一个你创建来绑定你映射的语句的接口。映射器接口的实例是从 SqlSession 中获得的。因此从技术层面讲，任何映射器实例的最大作用域是和请求它们的 SqlSession 相同的。尽管如此，映射器实例的最佳作用域是方法作用域。也就是说，映射器实例应该在调用它们的方法中被请求，用过之后即可废弃。并不需要显式地关闭映射器实例，尽管在整个请求作用域（request scope）保持映射器实例也不会有什么问题，但是很快你会发现，像 SqlSession 一样，在这个作用域上管理太多的资源的话会难于控制。所以要保持简单，最好把映射器放在方法作用域（method scope）内。如：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
SqlSession session = sqlSessionFactory.openSession();
try {
  BlogMapper mapper = session.getMapper(BlogMapper.class);
  // do work
} finally {
  session.close();
}
</script></code></pre>
<p><strong>小结</strong><br>SqlSessionFactoryBuilder 是用来根据 XML 文件或 Configuration 对象构建出一个 SqlSessionFactory 工厂对象的，构建完之后这个 Builder 对象就不需要用了，然后这个 SqlSessionFactory 工厂对象通常在一个应用程序中，都只有一个，即单例模式，是线程安全的，通过 SqlSessionFactory 的 openSession() 方法可以获取一个非线程安全的 SqlSession 实例，注意是非线程安全的哦，然后我们又可以通过这个 SqlSession 对象获取一个 Mapper 接口实例，SqlSession 对象和 Mapper 接口对象应该看作一对，作用域和生命周期也应该相同，不能共享给其他线程，所以最好就放在方法内部。其实到后面你会知道，这个 Mapper 接口的对象其实是 MyBatis 通过 JDK 动态代理来生成的，你自己打印一下它的全限定类名就能看得出，最后就是，sqlSession 对象一定要记得关闭，最好的方法就是在 finally 块中写上 sqlSession.close() 调用，最后还有一点就是默认的 openSession() 方法获取的 session 实例是不会自动提交的，所以要记得在 insert、update、delete 之后调用 session.commit() 方法来提交到数据库中。</p>
<p>然后就是 mybatis 的配置文件，为了不混淆，在后面我将使用 <strong>配置文件</strong>（主配置文件）、<strong>映射文件</strong> 来分别表示 mybatis-config.xml 和 mybatis-mapper.xml。config.xml 中就是 mybatis 的一些环境设置，如数据源、事务管理方式、别名设置、映射文件设置等，而映射文件则建议与对应的 Mapper 接口一一对应，且最好与 Mapper 接口放在一起，当然为了好看，我们可以直接在 resources 目录下创建一个 package 层次结构，然后将 mapper.xml 放到这里面去，什么意思呢？即假设我现在有一个 com.zfl9.mapper.EmployeeMapper 映射接口（放在 src/main/java 目录下），则我们将其对应的映射文件放到 src/main/resources/com/zfl9/mapper/EmployeeMapper.xml 位置，因为最终运行时，它们都会合并到一个 classpath 路径中，所以就是同一个路径下了，这样做的目的是更加简洁，不用将 java 文件和 xml 文件混在一起，不便于管理和维护。</p>
<p>其实本质上，你可以将 mapper 文件看作是 mapper 接口的实现类，只不过这个实现类是使用 xml 形式来定义的，mybatis 运行时会根据这个 mapper 文件动态生成一个 mapper 实例。这也是为什么我们喜欢将它们放在同一个类路径下的原因，而且我们通常也会给它们起一样的名字，即 EmployeeMapper.class、EmployeeMapper.xml。当然前面的官方文档中也说了，我们可以直接在 mapper 接口中直接实现它自己，也就是用对应的 <code>@Select</code>、<code>@Insert</code>、<code>@Update</code>、<code>@Delete</code> 注解来标注对应的接口方法，在上面写我们的 sql 语句。但是官方文档还说了，即使是这种方式，也会查找对应目录下的 mapper 文件，我们来测试一下：</p>
<p>具体代码就不贴出来了，先说下结论吧，官方文档说的没错，因为普通情况下，我们需要一个 mybatis-config.xml 文件，不过现在我们使用 Java Config 的形式来配置它而已（Configuration 对象），然后我们在类路径下放了 EmployeeMapper.class 和 EmployeeMapper.xml，测试结果如下，首先我没有在 EmployeeMapper 接口中定义注解，全部都是使用对应的 xml 形式实现，运行没问题，然后我对其中一个方法使用注解标注，然后运行报错，因为 mybatis 会找到两个实现版本，一个是注解实现，一个是 xml 实现，所以就报错了，然后我把同名的那个 xml 定义给他删了，运行起来就没问题，运行其它没用注解替换的方法也是正常的，所以结论是，mybatis 会结合 EmployeeMapper.class 中的注解和 EmployeeMapper.xml 文件来共同实现 EmployeeMapper 接口。</p>
<h2 id="CRUD"><a href="#CRUD" class="headerlink" title="CRUD"></a>CRUD</h2><p><strong>pom.xml</strong></p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<project>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.zfl9</groupId>
  <artifactId>JavaSE_HelloWorld</artifactId>
  <version>1.0-SNAPSHOT</version>

  <properties>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>

  <dependencies>
    <dependency>
      <groupId>junit</groupId>
      <artifactId>junit</artifactId>
      <version>4.12</version>
      <scope>test</scope>
    </dependency>

    <dependency>
      <groupId>mysql</groupId>
      <artifactId>mysql-connector-java</artifactId>
      <version>8.0.13</version>
      <scope>runtime</scope>
    </dependency>

    <dependency>
      <groupId>org.mybatis</groupId>
      <artifactId>mybatis</artifactId>
      <version>3.4.6</version>
    </dependency>
  </dependencies>
</project>
</script></code></pre>
<p><strong>Employee.java</strong></p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.bean;

public class Employee {
    private Integer id;
    private String name;
    private String email;
    private String address;
    private String telephone;

    public Employee() {
    }

    public Employee(String name, String email, String address, String telephone) {
        this.name = name;
        this.email = email;
        this.address = address;
        this.telephone = telephone;
    }

    public Employee(Integer id, String name, String email, String address, String telephone) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.address = address;
        this.telephone = telephone;
    }

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public String getAddress() {
        return address;
    }

    public void setAddress(String address) {
        this.address = address;
    }

    public String getTelephone() {
        return telephone;
    }

    public void setTelephone(String telephone) {
        this.telephone = telephone;
    }

    @Override
    public String toString() {
        return String.format("Employee [ id = %s, name = %s, email = %s, address = %s, telephone = %s ]", id, name, email, address, telephone);
    }
}
</script></code></pre>
<p><strong>mybatis-config.xml</strong></p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <environments default="development">
    <environment id="development">
      <transactionManager type="JDBC"/>

      <dataSource type="POOLED">
        <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost/test?serverTimezone=UTC"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
      </dataSource>
    </environment>
  </environments>

  <mappers>
    <mapper resource="com/zfl9/mapper/EmployeeMapper.xml"/>
  </mappers>
</configuration>
</script></code></pre>
<p><strong>EmployeeMapper.java</strong></p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.mapper;

import java.util.List;
import com.zfl9.bean.Employee;

public interface EmployeeMapper {
    int addEmployee(Employee employee);

    Employee getEmployeeById(Integer id);

    List<Employee> getAllEmployees();

    int updateEmployee(Employee employee);

    int deleteEmployeeById(Integer id);

    int deleteAllEmployees();

    void truncateEmployeeTable();
}
</script></code></pre>
<p><strong>EmployeeMapper.xml</strong></p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.zfl9.mapper.EmployeeMapper">
  <insert id="addEmployee" useGeneratedKeys="true" keyProperty="id">
    insert into employee(name, email, address, telephone) values(#{name}, #{email}, #{address}, #{telephone})
  </insert>

  <select id="getEmployeeById" resultType="com.zfl9.bean.Employee">
    select * from employee where id = #{id}
  </select>

  <select id="getAllEmployees" resultType="com.zfl9.bean.Employee">
    select * from employee;
  </select>

  <update id="updateEmployee">
    update employee set name=#{name}, email=#{email}, address=#{address}, telephone=#{telephone} where id=#{id}
  </update>

  <delete id="deleteEmployeeById">
    delete from employee where id=#{id}
  </delete>

  <delete id="deleteAllEmployees">
    delete from employee
  </delete>

  <delete id="truncateEmployeeTable">
    truncate table employee
  </delete>
</mapper>
</script></code></pre>
<p><strong>EmployeeMapperTest.java</strong></p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.mapper;

import java.io.IOException;
import java.util.List;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Assert;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import com.zfl9.bean.Employee;

public class EmployeeMapperTest {
    private static SqlSessionFactory sqlSessionFactory;

    private SqlSession sqlSession;
    private EmployeeMapper employeeMapper;

    @BeforeClass
    public static void init() throws IOException {
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("mybatis-config.xml"));
    }

    @AfterClass
    public static void destroy() {
        sqlSessionFactory = null;
    }

    @Before
    public void setUp() {
        sqlSession = sqlSessionFactory.openSession();
        employeeMapper = sqlSession.getMapper(EmployeeMapper.class);
    }

    @After
    public void tearDown() {
        employeeMapper = null;
        sqlSession.close();
        sqlSession = null;
    }

    @Test
    public void testAddEmployee() {
        Employee employee = new Employee("Otokaze", "root@zfl9.com", "江西省赣州市", "+86 15307973676");
        int affectedRows = employeeMapper.addEmployee(employee);
        Assert.assertTrue(affectedRows > 0);
        System.out.println(affectedRows);
        System.out.println(employee);
        sqlSession.commit();
    }

    @Test
    public void testGetEmployeeById() {
        Employee employee = employeeMapper.getEmployeeById(1);
        Assert.assertNotNull(employee);
        System.out.println(employee);
    }

    @Test
    public void testGetAllEmployees() {
        List<Employee> employees = employeeMapper.getAllEmployees();
        Assert.assertFalse(employees.isEmpty());
        for (Employee employee : employees) {
            System.out.println(employee);
        }
    }

    @Test
    public void testUpdateEmployee() {
        Employee employee = employeeMapper.getEmployeeById(1);
        Assert.assertNotNull(employee);
        System.out.println(employee);
        employee.setTelephone("+86 18819342665");
        int affectedRows = employeeMapper.updateEmployee(employee);
        Assert.assertTrue(affectedRows > 0);
        System.out.println(affectedRows);
        System.out.println(employee);
        sqlSession.commit();
    }

    @Test
    public void testDeleteEmployeeById() {
        int affectedRows = employeeMapper.deleteEmployeeById(1);
        Assert.assertTrue(affectedRows > 0);
        System.out.println(affectedRows);
        sqlSession.commit();
    }

    @Test
    public void testDeleteAllEmployees() {
        int affectedRows = employeeMapper.deleteAllEmployees();
        Assert.assertTrue(affectedRows > 0);
        System.out.println(affectedRows);
        sqlSession.commit();
    }

    @Test
    public void testTruncateEmployeeTable() {
        employeeMapper.truncateEmployeeTable();
        sqlSession.commit();
    }
}
</script></code></pre>
<p><strong>MySQL - employee 表</strong><br><img src="/images/mybatis-crud-table.png" alt="employee 表"></p>
<h2 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h2><p>上一节演示了基本的 CRUD 数据库操作，所谓 CRUD 就是增删改查的缩写，增删改操作都比较简单，没什么可讲的，关键是查，很多 SQL 优化都是指的查询优化。因为 SQL 查询语句往往比增删改语句复杂的多，比如常见的多表查询，需要考虑到查询性能，如何优化查询语句以提高应用的响应速度等。</p>
<p>在这里我们就来讲解一下常见的进阶查询操作，即：<strong>一对一查询</strong>、<strong>一对多查询</strong>，也称为关联查询，本质上一对一查询和一对多查询都是差不多的。假设数据库中存在两张表，teacher、student，表示老师和学生，一个老师教多个学生（一对多），而一个学生只被一个老师教（一对一），表结构如下：</p>
<pre><code class="language-sql line-numbers"><script type="text/plain">
create table teacher (
    `id` int not null auto_increment,
    `name` varchar(30) not null,
    `phone` varchar(30) not null,
    primary key (`id`)
);

create table student (
    `id` int not null auto_increment,
    `name` varchar(30) not null,
    `score` int not null,
    `teacher_id` int not null,
    primary key (`id`)
);

insert into teacher(name, phone) values("钟国锋", "13389891234"); # id = 1
insert into teacher(name, phone) values("郭朝京", "13798120912"); # id = 2
insert into teacher(name, phone) values("林秦晖", "18190120924"); # id = 3

insert into student(name, score, teacher_id) values("曾飞龙", "80", 1);
insert into student(name, score, teacher_id) values("黄代伟", "85", 1);
insert into student(name, score, teacher_id) values("丁建文", "89", 1);

insert into student(name, score, teacher_id) values("邓欣婷", "90", 2);
insert into student(name, score, teacher_id) values("刘路遥", "91", 2);
insert into student(name, score, teacher_id) values("罗慧琳", "89", 2);

insert into student(name, score, teacher_id) values("谢素云", "109", 3);
insert into student(name, score, teacher_id) values("刘海群", "110", 3);
insert into student(name, score, teacher_id) values("钟素文", "102", 3);

commit;
</script></code></pre>
<p>通过 student 表的 teacher_id 字段可以找到对应的 teacher 记录。</p>
<p><strong>一对一查询，查询 student 表，并获取对应的 teacher 记录</strong></p>
<pre><code class="language-sql line-numbers"><script type="text/plain">
mysql> select * from student;
+----+-----------+-------+------------+
| id | name      | score | teacher_id |
+----+-----------+-------+------------+
|  1 | 曾飞龙    |    80 |          1 |
|  2 | 黄代伟    |    85 |          1 |
|  3 | 丁建文    |    89 |          1 |
|  4 | 邓欣婷    |    90 |          2 |
|  5 | 刘路遥    |    91 |          2 |
|  6 | 罗慧琳    |    89 |          2 |
|  7 | 谢素云    |   109 |          3 |
|  8 | 刘海群    |   110 |          3 |
|  9 | 钟素文    |   102 |          3 |
+----+-----------+-------+------------+
9 rows in set (0.00 sec)

mysql> select * from teacher;
+----+-----------+-------------+
| id | name      | phone       |
+----+-----------+-------------+
|  1 | 钟国锋    | 13389891234 |
|  2 | 郭朝京    | 13798120912 |
|  3 | 林秦晖    | 18190120924 |
+----+-----------+-------------+
3 rows in set (0.00 sec)

mysql> select s.*, t.name as teacher_name, t.phone as teacher_phone from student as s left outer join teacher as t on s.teacher_id = t.id;
+----+-----------+-------+------------+--------------+---------------+
| id | name      | score | teacher_id | teacher_name | teacher_phone |
+----+-----------+-------+------------+--------------+---------------+
|  1 | 曾飞龙    |    80 |          1 | 钟国锋       | 13389891234   |
|  2 | 黄代伟    |    85 |          1 | 钟国锋       | 13389891234   |
|  3 | 丁建文    |    89 |          1 | 钟国锋       | 13389891234   |
|  4 | 邓欣婷    |    90 |          2 | 郭朝京       | 13798120912   |
|  5 | 刘路遥    |    91 |          2 | 郭朝京       | 13798120912   |
|  6 | 罗慧琳    |    89 |          2 | 郭朝京       | 13798120912   |
|  7 | 谢素云    |   109 |          3 | 林秦晖       | 18190120924   |
|  8 | 刘海群    |   110 |          3 | 林秦晖       | 18190120924   |
|  9 | 钟素文    |   102 |          3 | 林秦晖       | 18190120924   |
+----+-----------+-------+------------+--------------+---------------+
9 rows in set (0.00 sec)
</script></code></pre>
<p>我们来看看如何使用 MyBatis 来实现这种一对一的查询操作，因为关联查询是比较复杂的一种查询，所以我们不能直接在 select 标签中使用 resultType 属性，而应该改用可以定制化的 resultMap 属性，这个属性指定的是一个 resultMap 标签的 id，而这个 resultMap 标签的 type 属性则是对应的 java bean 对象，其实我们之前直接使用的 resultType 属性就是 resultMap 的一种语法糖，在内部它依旧是一个 resultMap 标签。</p>
<p>Student 实体类：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.bean;

public class Student {
    private Integer id;
    private String name;
    private Integer score;
    private Teacher teacher;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getScore() {
        return score;
    }

    public void setScore(Integer score) {
        this.score = score;
    }

    public Teacher getTeacher() {
        return teacher;
    }

    public void setTeacher(Teacher teacher) {
        this.teacher = teacher;
    }

    @Override
    public String toString() {
        return String.format("Student [ id = %s, name = %s, score = %s, teacher = %s ]", id, name, score, teacher);
    }
}
</script></code></pre>
<p>Teacher 实体类：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.bean;

import java.util.List;

public class Teacher {
    private Integer id;
    private String name;
    private String phone;
    private List<Student> students;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPhone() {
        return phone;
    }

    public void setPhone(String phone) {
        this.phone = phone;
    }

    public List<Student> getStudents() {
        return students;
    }

    public void setStudents(List<Student> students) {
        this.students = students;
    }

    @Override
    public String toString() {
        return String.format("Teacher [ id = %s, name = %s, phone = %s, students = %s ]", id, name, phone, students);
    }
}
</script></code></pre>
<p>mybatis-config.xml 配置文件：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <environments default="development">
    <environment id="development">
      <transactionManager type="JDBC"/>

      <dataSource type="POOLED">
        <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost/test"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
      </dataSource>
    </environment>
  </environments>

  <mappers>
    <!--<mapper resource="com/zfl9/mapper/EmployeeMapper.xml"/>-->
    <package name="com.zfl9.mapper"/> <!-- 扫描指定包下的所有 mapper -->
  </mappers>
</configuration>
</script></code></pre>
<p>为了避免在 mappers 标签中编写很多重复的 mapper 映射（通常 mapper 接口和 mapper 文件都是放到同一个类路径/package下），所以直接使用 <code>&lt;package name=&quot;com.zfl9.mapper&quot;/&gt;</code> 来告诉 mybatis 扫描指定包下的所有 mapper 接口和对应的 mapper 文件，这样只要一行配置就行了。</p>
<p>StudentMapper.java 映射接口：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.mapper;

import com.zfl9.bean.Student;

public interface StudentMapper {
    Student getStudentById(int id);
}
</script></code></pre>
<p>StudentMapper.xml 映射文件：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.zfl9.mapper.StudentMapper">
  <select id="getStudentById" resultMap="Student">
    select s.*, t.name as teacher_name, t.phone as teacher_phone from student as s left outer join teacher as t on s.teacher_id = t.id where s.id = #{id};
  </select>

  <resultMap id="Student" type="com.zfl9.bean.Student">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    <result property="score" column="score"/>
    <association property="teacher" javaType="com.zfl9.bean.Teacher">
      <id property="id" column="teacher_id"/>
      <result property="name" column="teacher_name"/>
      <result property="phone" column="teacher_phone"/>
    </association>
  </resultMap>
</mapper>
</script></code></pre>
<p>resultMap 标签的 type 属性就是对应的实体类的全限定类名，即 Student，里面的 id 标签用来填写主键的 column，而 result 标签则用来填写普通的 column，id 和 result 标签都可以有多个，因为同一张表中主键虽然只能有一个，但是一个主键可以有多个 column。它们的 column 属性就是数据表中的列名，而 property 则是实体类中的属性名。然后我们需要关注的重点就是 association 标签，association 的中文意思就是关联，在 mybatis 中用来表示一对一关系，因为一个学生只于一个老师相关联，property 属性是实体类中的属性名（teacher），而 javaType 属性则是关联的实体类的全类名，也就是 Teacher，association 标签内部的 id 和 result 标签的意思与上面的 id 和 result 标签的意思是一样的，column 是当前结果表中的字段名，property 则是 Teacher 实体类中的属性名。</p>
<p>StudentMapperTest 测试类：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.mapper;

import java.io.IOException;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import com.zfl9.bean.Student;

public class StudentMapperTest {
    private static SqlSessionFactory sqlSessionFactory;
    private SqlSession sqlSession;
    private StudentMapper studentMapper;

    @BeforeClass
    public static void init() throws IOException {
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("mybatis-config.xml"));
    }

    @AfterClass
    public static void destroy() {
        sqlSessionFactory = null;
    }

    @Before
    public void setUp() {
        sqlSession = sqlSessionFactory.openSession();
        studentMapper = sqlSession.getMapper(StudentMapper.class);
    }

    @After
    public void tearDown() {
        studentMapper = null;
        sqlSession.close();
        sqlSession = null;
    }

    @Test
    public void testGetStudentById() {
        Student student = studentMapper.getStudentById(9);
        System.out.println(student);
    }
}
</script></code></pre>
<p>执行结果如下：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
Student [ id = 9, name = 钟素文, score = 102, teacher = Teacher [ id = 3, name = 林秦晖, phone = 18190120924, students = null ] ]
</script></code></pre>
<p>现在我们来看一下如何实现 <strong>一对多查询</strong>，比如查询 teacher 表的一条记录，因为一个老师对应多个学生，刚好符合我们的要求，原生 SQL：</p>
<pre><code class="language-sql line-numbers"><script type="text/plain">
mysql> select t.*, s.id as student_id, s.name as student_name, s.score as student_score from teacher as t right outer join student as s on t.id = s.teacher_id;
+------+-----------+-------------+------------+--------------+---------------+
| id   | name      | phone       | student_id | student_name | student_score |
+------+-----------+-------------+------------+--------------+---------------+
|    1 | 钟国锋    | 13389891234 |          1 | 曾飞龙       |            80 |
|    1 | 钟国锋    | 13389891234 |          2 | 黄代伟       |            85 |
|    1 | 钟国锋    | 13389891234 |          3 | 丁建文       |            89 |
|    2 | 郭朝京    | 13798120912 |          4 | 邓欣婷       |            90 |
|    2 | 郭朝京    | 13798120912 |          5 | 刘路遥       |            91 |
|    2 | 郭朝京    | 13798120912 |          6 | 罗慧琳       |            89 |
|    3 | 林秦晖    | 18190120924 |          7 | 谢素云       |           109 |
|    3 | 林秦晖    | 18190120924 |          8 | 刘海群       |           110 |
|    3 | 林秦晖    | 18190120924 |          9 | 钟素文       |           102 |
+------+-----------+-------------+------------+--------------+---------------+
9 rows in set (0.00 sec)

mysql> select t.*, s.id as student_id, s.name as student_name, s.score as student_score from teacher as t right outer join student as s on t.id = s.teacher_id where t.id = 3;
+------+-----------+-------------+------------+--------------+---------------+
| id   | name      | phone       | student_id | student_name | student_score |
+------+-----------+-------------+------------+--------------+---------------+
|    3 | 林秦晖    | 18190120924 |          7 | 谢素云       |           109 |
|    3 | 林秦晖    | 18190120924 |          8 | 刘海群       |           110 |
|    3 | 林秦晖    | 18190120924 |          9 | 钟素文       |           102 |
+------+-----------+-------------+------------+--------------+---------------+
3 rows in set (0.00 sec)
</script></code></pre>
<p>TeacherMapper.java 映射接口：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.mapper;

import com.zfl9.bean.Teacher;

public interface TeacherMapper {
    Teacher getTeacherById(int id);
}
</script></code></pre>
<p>TeacherMapper.xml 映射文件：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.zfl9.mapper.TeacherMapper">
  <select id="getTeacherById" resultMap="Teacher">
    select t.*, s.id as student_id, s.name as student_name, s.score as student_score from teacher as t right outer join student as s on t.id = s.teacher_id where t.id = #{id}
  </select>

  <resultMap id="Teacher" type="com.zfl9.bean.Teacher">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    <result property="phone" column="phone"/>
    <collection property="students" ofType="com.zfl9.bean.Student">
      <id property="id" column="student_id"/>
      <result property="name" column="student_name"/>
      <result property="score" column="student_score"/>
    </collection>
  </resultMap>
</mapper>
</script></code></pre>
<p>其实就是把 association 改为了 collection 标签，然后就是 javaType 属性改为了 ofType 属性（集合元素的类型），其它的没什么变化。</p>
<p>TeacherMapperTest 测试类：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.mapper;

import java.io.IOException;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import com.zfl9.bean.Teacher;

public class TeacherMapperTest {
    private static SqlSessionFactory sqlSessionFactory;
    private SqlSession sqlSession;
    private TeacherMapper teacherMapper;

    @BeforeClass
    public static void init() throws IOException {
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("mybatis-config.xml"));
    }

    @AfterClass
    public static void destroy() {
        sqlSessionFactory = null;
    }

    @Before
    public void setUp() {
        sqlSession = sqlSessionFactory.openSession();
        teacherMapper = sqlSession.getMapper(TeacherMapper.class);
    }

    @After
    public void tearDown() {
        teacherMapper = null;
        sqlSession.close();
        sqlSession = null;
    }

    @Test
    public void testGetTeacherById() {
        Teacher teacher = teacherMapper.getTeacherById(3);
        System.out.println(teacher);
    }
}
</script></code></pre>
<p>执行结果如下：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
Teacher [ id = 3, name = 林秦晖, phone = 18190120924, students = [Student [ id = 7, name = 谢素云, score = 109, teacher = null ], Student [ id = 8, name = 刘海群, score = 110, teacher = null ], Student [ id = 9, name = 钟素文, score = 102, teacher = null ]] ]
</script></code></pre>
<p><strong>一对一查询的另一种方式（分步查询）</strong></p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.zfl9.mapper.StudentMapper">
  <select id="getStudentById" resultMap="Student">
    select * from student where id = #{id}
  </select>

  <select id="getTeacherById" resultType="com.zfl9.bean.Teacher">
    select * from teacher where id = #{id}
  </select>

  <resultMap id="Student" type="com.zfl9.bean.Student">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    <result property="score" column="score"/>
    <association property="teacher" column="teacher_id" select="getTeacherById"/>
  </resultMap>
</mapper>
</script></code></pre>
<p>前面我们介绍的一对一查询和一对多查询都是只有一次 SQL 查询操作，而这里的则是两次 SQL 查询操作，通常情况下，不建议使用这种方式，因为多了一次 SQL 查询，当然针对这种分步查询的做法也有优化手段，那就是启用 mybatis 的延迟加载功能，当我们不需要用到 Student 实体类中的 teacher 属性时，这个 getTeacherById 语句就不会被执行，可以缓解数据库的压力，但是如果条件允许，还是使用 join 查询比较好。</p>
<p>当然也并不是说 join 查询就一定比分步查询好，比如这么一种场景，有一张用户表，还有一张聊天记录表。一个用户可能关联了 1000 条聊天记录。如果是关联查询，那么就一次性就把这 1000 条数据查出来了，但是可能程序仅仅想查询用户的一些信息，不需要用到聊天记录数据，那么就纯属浪费了；而分步查询 + 懒加载的目的就是在用户真正需要使用数据的时候才去查询数据库，而不是第一次就一下子全部给查询出来，所以它们都有各自适用的场合。</p>
<p><strong>一对多查询的另一种方式（分步查询）</strong></p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.zfl9.mapper.TeacherMapper">
  <select id="getTeacherById" resultMap="Teacher">
    select * from teacher where id = #{id}
  </select>

  <select id="getStudentById" resultType="com.zfl9.bean.Student">
    select id, name, score from student where teacher_id = #{id}
  </select>

  <resultMap id="Teacher" type="com.zfl9.bean.Teacher">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    <result property="phone" column="phone"/>
    <collection property="students" column="id" select="getStudentById"/>
  </resultMap>
</mapper>
</script></code></pre>
<p>稍微解释一下，无论是 association 还是 collection，分步查询的 resultMap 都是差不多的：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<association property="teacher"  column="teacher_id" select="getTeacherById"/>
<collection  property="students" column="id"         select="getStudentById"/>
</script></code></pre>
<p>property 是实体类的属性名，column 则是传递给 select 语句的查询参数，select 就是实际执行查询操作的语句 id。</p>
<p>而传统的 join 关联查询的 resultMap 则是这样的，注意多了一个 javaType、ofType，用来告诉 mybatis 对应的实体类类型，那为什么使用分步查询就不用指定这个类型呢？因为 select 语句上本身就有 resultType、resultMap 来指定对应的实体类类型，所以不需要重复指定它：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<association property="teacher"  javaType="com.zfl9.bean.Teacher">
<collection  property="students" ofType="com.zfl9.bean.Student">
</script></code></pre>
<p><strong>N + 1 问题</strong><br>所谓 N + 1 问题（我感觉叫做 1 + N 问题会比较合适）就是指这么一种情况：还是以上面的 student 表和 teacher 表为例，我现在想查询出所有 teacher 记录，并且查询出 teacher 记录相关联的 student 记录，并且使用“分步查询”，则可以简单表示为：</p>
<pre><code class="language-sql line-numbers"><script type="text/plain">
select * from teacher;  # 语句 1
select * from student where teacher_id = ${teacher_id};  # 语句 2
</script></code></pre>
<p>假设 teacher 表有 N 条记录，那么 ORM 框架（N + 1 问题是 ORM 框架中的问题）实际上就会执行 N 次语句 2，加上查询了一次语句 1，就是 N + 1 次查询，导致程序的效率非常低。当然要避免这个问题有两种常见的解决方法（在 mybatis 中），第一种方式就是使用 join 多表查询，这个前面已经演示过了；第二种方式就是使用 mybatis 的延迟加载技术，所谓延迟加载就是首次查询时不会先去查询语句 2，只有等我们的应用实际用到了 teacher 对象的 student 成员时才会去执行语句 2 去查询数据库，为了对应用程序透明化，mybatis 使用了动态代理技术（当然不是 jdk 动态代理，因为我们的实体类通常都没有去实现任何 java 接口，而 jdk 动态代理要求委托类至少实现一个接口，所以使用的是 cglib/javassit，v3.3 版本之前默认使用 cglib，v3.3 版本之后，含 v3.3 版本，默认使用的是 javassit），现在我们就来学习一下 mybatis 的延迟加载如何使用。</p>
<p>主要涉及到的是这三个 mybatis-config.xml 里面的 setting：</p>
<ul>
<li><code>lazyLoadingEnabled</code>：延迟查询的默认开关，默认为 <code>false</code>，注意是默认开关，association/collection 中的 fetchType 属性的优先级更高。</li>
<li><code>aggressiveLazyLoading</code>：激进模式的延迟加载，3.4.1 之前默认为 true，3.4.1 之后默认为 false。所谓激进模式是指当我们第一次访问代理对象（注意是代理对象）的任何方法时就会去查询数据库，把里面的延迟加载对象的数据都加载出来，而当我们设置为 false 时，表示只有我们第一次访问代理对象内部的延迟对象的时候才会去数据库中加载对应的对象数据，后者应该才是我们想要的值，所以请尽量设置为 false。</li>
<li><code>lazyLoadTriggerMethods</code>：关闭激进模式的延迟加载对象后（即 aggressiveLazyLoading 为 false），但又希望在调用代理对象的某些方法之前就把所有的延迟加载对象都从数据库加载出来，怎么办呢？这个时候我们就可以通过 lazyLoadTriggerMethods 参数来指定这些代理对象的方法的名称。默认是 equals、hashCode、clone 和 toString，当我们访问代理对象的这些方法时通常都需要将内部的所有数据成员给加载出来，所以基本上我们也不需要动它，默认值很合理。</li>
</ul>
<p>即使 lazyLoadingEnabled 属性为 false，也可以通过 association/collection 元素的 fetchType 属性来指定是否进行延迟加载，该属性有两个取值：<code>eager</code>（立即加载）、<code>lazy</code>（延迟加载）。很多时候我们并不希望给全部关联查询都启用延迟加载，毕竟不是都需要，所以单独设置可能会好一些。</p>
<p>首先配置 mybatis-config.xml 里面的 settings 元素，添加 lazy loading 相关的配置项：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">
<configuration>
  <settings>
    <setting name="lazyLoadingEnabled" value="true"/>
    <setting name="aggressiveLazyLoading" value="false"/>
  </settings>

  <environments default="development">
    <environment id="development">
      <transactionManager type="JDBC"/>
      <dataSource type="POOLED">
        <property name="driver" value="com.mysql.cj.jdbc.Driver"/>
        <property name="url" value="jdbc:mysql://localhost/test"/>
        <property name="username" value="root"/>
        <property name="password" value="123456"/>
      </dataSource>
    </environment>
  </environments>

  <mappers>
    <package name="com.zfl9.mapper"/>
  </mappers>
</configuration>
</script></code></pre>
<p>修改我们的测试方法，打印一下实体类是不是代理对象：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetStudentById() {
    Student student = studentMapper.getStudentById(9);
    System.out.println(student);
    System.out.println(student.getClass());
}
</script></code></pre>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetTeacherById() {
    Teacher teacher = teacherMapper.getTeacherById(3);
    System.out.println(teacher);
    System.out.println(teacher.getClass());
}
</script></code></pre>
<p>运行结果：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
Student [ id = 9, name = 钟素文, score = 102, teacher = Teacher [ id = 3, name = 林秦晖, phone = 18190120924, students = null ] ]
class com.zfl9.bean.Student_$$_jvstdd0_0

Teacher [ id = 3, name = 林秦晖, phone = 18190120924, students = [Student [ id = 7, name = 谢素云, score = 109, teacher = null ], Student [ id = 8, name = 刘海群, score = 110, teacher = null ], Student [ id = 9, name = 钟素文, score = 102, teacher = null ]] ]
class com.zfl9.bean.Teacher_$$_jvstdd0_0
</script></code></pre>
<p><strong>discriminator 鉴别器</strong><br>discriminator 既不是一对一查询也不是一对多查询，它类似 Java 中的 switch 语句，根据一个 column 值来确定使用哪个 resultMap。例子：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<resultMap id="vehicleResult" type="Vehicle">
  <id property="id" column="id"/>
  <result property="vin" column="vin"/>
  <result property="year" column="year"/>
  <result property="make" column="make"/>
  <result property="model" column="model"/>
  <result property="color" column="color"/>
  <discriminator javaType="int" column="vehicle_type">
    <case value="1" resultMap="carResult"/>
    <case value="2" resultMap="truckResult"/>
    <case value="3" resultMap="vanResult"/>
    <case value="4" resultMap="suvResult"/>
  </discriminator>
</resultMap>
</script></code></pre>
<p>它的具体含义是这样的，mybatis 从 select 语句的执行结果中，获取一条记录，然后取出 <code>vehicle_type</code> 这个字段，将它的值看作一个 <code>int</code> 类型，然后与里面的 1、2、3、4 进行比对，如果匹配成功，则使用对应的 resultMap 来封装该条记录为一个 pojo，如果一个都没有匹配上，则使用 discriminator 标签外部的 resultMap 来封装该条记录为一个 pojo（即 vehicleResult 这个 resultMap）。discriminator 里面的 4 个 type 都是 Vehicle 的子类，discriminator 的作用大多数也是这种，根据某个列的值来动态的选择实例化哪个 pojo（存在继承关系的 pojo）。</p>
<p>注意，默认情况下，discriminator 是具有“排他性”的，即如果当前记录的 vehicle_type 为 1，那么就使用 case 为 1 的那个 resultMap 来封装记录为 pojo，而它外部的 vin、year、make、model、color 都不会被封装上（除非你在 carResult 里面封装这些属性），只有当 vehicle_type 的值没有匹配到任何一个 case 时才会使用外部的 resultMap；很多时候这并不是我们想要的，我们想要的是让 discriminator 内部的 resultMap 继承外部的 resultMap，而不是排他性的。那这种情况该怎么办呢？也简单，在 carResult 这个 resultMap 标签上添加一个属性就可以继承 vehicleResult 标签了，这个属性就是 <code>extends=&quot;vehicleResult&quot;</code>，即从上面这个变为下面这个：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<resultMap id="carResult" type="Car">
  <result property="doorCount" column="door_count"/>
</resultMap>
</script></code></pre>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<resultMap id="carResult" type="Car" extends="vehicleResult">
  <result property="doorCount" column="door_count"/>
</resultMap>
</script></code></pre>
<p>当然我们也可以直接将这个外部 resultMap 内联进来，直接放到 case 标签内部，反正它也是继承的，基本无法重用，还不如放到一起，增加可读性。</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<resultMap id="vehicleResult" type="Vehicle">
  <id property="id" column="id"/>
  <result property="vin" column="vin"/>
  <result property="year" column="year"/>
  <result property="make" column="make"/>
  <result property="model" column="model"/>
  <result property="color" column="color"/>
  <discriminator javaType="int" column="vehicle_type">
    <case value="1" resultType="carResult">
      <result property="doorCount" column="door_count"/>
    </case>
    <case value="2" resultType="truckResult">
      <result property="boxSize" column="box_size"/>
      <result property="extendedCab" column="extended_cab"/>
    </case>
    <case value="3" resultType="vanResult">
      <result property="powerSlidingDoor" column="power_sliding_door"/>
    </case>
    <case value="4" resultType="suvResult">
      <result property="allWheelDrive" column="all_wheel_drive"/>
    </case>
  </discriminator>
</resultMap>
</script></code></pre>
<p>这种写法和上面的分开写且加了 extends 属性的写法是一样的，推荐使用这种写法，可读性强。case 标签内部可以有 resultMap 标签中的任意元素。</p>
<p>下面我们来通过一个简单的例子来验证一下 discriminator 标签的用法和作用是不是和我们上面描述的一致，顺便巩固一下 discriminator 标签的理解。</p>
<pre><code class="language-sql line-numbers"><script type="text/plain">
create table people (
    id int not null auto_increment,
    name varchar(30) not null,
    age int not null,
    sex enum('M', 'F') not null,
    primary key (id)
);

create table male_people (
    id int not null,
    feiji varchar(30) not null
);

create table female_people (
    id int not null,
    ziwei varchar(30) not null
);

insert into people(name, age, sex) values("小张", 16, 'M'); # id = 1
insert into people(name, age, sex) values("小明", 16, 'M'); # id = 2
insert into people(name, age, sex) values("小丽", 15, 'F'); # id = 3
insert into people(name, age, sex) values("小红", 15, 'F'); # id = 4

insert into male_people(id, feiji) values(1, "喜欢打飞机");
insert into male_people(id, feiji) values(2, "喜欢撸管管");

insert into female_people(id, ziwei) values(3, "喜欢抠逼逼");
insert into female_people(id, ziwei) values(4, "喜欢仙女棒");

commit;
</script></code></pre>
<p>People 实体类（我创建的是抽象类，实际上 mybatis 没有这个要求，我这样做只是为了便于测试）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.bean;

public abstract class People {
    private Integer id;
    private String name;
    private Integer age;
    private Character sex;

    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Character getSex() {
        return sex;
    }

    public void setSex(Character sex) {
        this.sex = sex;
    }
}
</script></code></pre>
<p>MalePeople 实体类：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.bean;

public class MalePeople extends People {
    private String feiji;

    public String getFeiji() {
        return feiji;
    }

    public void setFeiji(String feiji) {
        this.feiji = feiji;
    }

    @Override
    public String toString() {
        return String.format("Male [ id = %s, name = %s, age = %s, sex = %s, feiji = %s ]", getId(), getName(), getAge(), getSex(), feiji);
    }
}
</script></code></pre>
<p>FemalePeople 实体类：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.bean;

public class FemalePeople extends People {
    private String ziwei;

    public String getZiwei() {
        return ziwei;
    }

    public void setZiwei(String ziwei) {
        this.ziwei = ziwei;
    }

    @Override
    public String toString() {
        return String.format("Female [ id = %s, name = %s, age = %s, sex = %s, ziwei = %s ]", getId(), getName(), getAge(), getSex(), ziwei);
    }
}
</script></code></pre>
<p>PeopleMapper.java 映射接口：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.mapper;

import com.zfl9.bean.People;

public interface PeopleMapper {
    People getPeopleById(int id);
}
</script></code></pre>
<p>PeopleMapper.xml 映射文件：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.zfl9.mapper.PeopleMapper">
  <select id="getPeopleById" resultMap="People">
    select * from people where id = #{id}
  </select>

  <select id="getMaleFeijiById" resultType="String">
    select feiji from male_people where id = #{id}
  </select>

  <select id="getFemaleZiweiById" resultType="String">
    select ziwei from female_people where id = #{id}
  </select>

  <resultMap id="People" type="com.zfl9.bean.People">
    <id property="id" column="id"/>
    <result property="name" column="name"/>
    <result property="age" column="age"/>
    <result property="sex" column="sex"/>
    <discriminator column="sex" javaType="java.lang.Character">
      <case value="M" resultType="com.zfl9.bean.MalePeople">
        <association property="feiji" column="id" select="getMaleFeijiById"/>
      </case>
      <case value="F" resultType="com.zfl9.bean.FemalePeople">
        <association property="ziwei" column="id" select="getFemaleZiweiById"/>
      </case>
    </discriminator>
  </resultMap>
</mapper>
</script></code></pre>
<p>简单解释一下：getMaleFeijiById 和 getFemaleZiweiById 的 resultType 不知道你注意到没？没错，我们的 select 语句可以返回任意 java 类型，不只是 pojo 哦，比如我们上面就是返回的 String 类型。然后就是 resultMap 这个标签，首先我们给它指定的 type 是 People 基类，然后里面的 id、result 就是 People 基类里面定义的属性，然后我们根据 sex 这个数据表字段来进行 switch 选择，如果是 M 那就实例化 MalePeople 实体类（resultType 指定的），如果是 F 那就实例化 FemalePeople 实体类（resultType 指定的），因为这两个具体类里面的 feiji、ziwei 字段不在当前 people 表中，而是在各自的 male_people、female_people 表中，所以我们使用一个 association 标签告诉 mybatis，这个 feiji、ziwei 属性需要分步查询，即调用 getMaleFeijiById、getFemaleZiweiById 标签，并传递 column 属性指定的参数（即 id）给它们查询，最后封装为对应的 MalePeople、FemalePeople 实体类对象，返回给我们；注意，mybatis 查到记录之后首先是去执行 discriminator 鉴别器标签，找到匹配的 javaType，然后实例化这个 javaType，最后才会使用当前 resultMap 及其父 resultMap 中的 id、result、association、collection 等标签来将数据记录封装为一个 pojo 给我们，整个过程是没有实例化 People 基类的，这也是我为什么将其设为抽象类的原因，就是为了验证 mybatis 没有实例化 People 类。</p>
<p>PeopleMapperTest 测试类：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.mapper;

import java.io.IOException;
import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.junit.After;
import org.junit.AfterClass;
import org.junit.Before;
import org.junit.BeforeClass;
import org.junit.Test;
import com.zfl9.bean.People;

public class PeopleMapperTest {
    private static SqlSessionFactory sqlSessionFactory;
    private SqlSession sqlSession;
    private PeopleMapper peopleMapper;

    @BeforeClass
    public static void init() throws IOException {
        sqlSessionFactory = new SqlSessionFactoryBuilder().build(Resources.getResourceAsStream("mybatis-config.xml"));
    }

    @AfterClass
    public static void destroy() {
        sqlSessionFactory = null;
    }

    @Before
    public void setUp() {
        sqlSession = sqlSessionFactory.openSession();
        peopleMapper = sqlSession.getMapper(PeopleMapper.class);
    }

    @After
    public void tearDown() {
        peopleMapper = null;
        sqlSession.close();
        sqlSession = null;
    }

    @Test
    public void testGetPeopleById() {
        People male = peopleMapper.getPeopleById(1);
        People female = peopleMapper.getPeopleById(4);
        System.out.println(male);
        System.out.println(female);
    }
}
</script></code></pre>
<p>运行结果如下：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
Male [ id = 1, name = 小张, age = 16, sex = M, feiji = 喜欢打飞机 ]
Female [ id = 4, name = 小红, age = 15, sex = F, ziwei = 喜欢仙女棒 ]
</script></code></pre>
<h2 id="执行器类型"><a href="#执行器类型" class="headerlink" title="执行器类型"></a>执行器类型</h2><p>mybatis 提供三种 Executor（执行器）类型，分别是（sqlSessionFactory.openSession() 方法的参数）：</p>
<ul>
<li>ExecutorType.SIMPLE：默认值，不会做任何特殊的事情，每个语句都会创建一个 PreparedStatement。</li>
<li>ExecutorType.REUSE：这种类型将重复使用 PreparedStatements。</li>
<li>ExecutorType.BATCH：通常用于数据的批量更新和插入。</li>
</ul>
<p>SIMPLE 执行器可以很轻松的返回每次 insert 操作的自增 id 值，只需要简单的使用 getGeneratedKeys 和 keyProperty 属性就行。而 BATCH 执行器因为是专门用于批量更新的（这里指的更新就是增删改），所以无法优雅的返回 insert 后的自增 id 值，只能返回最后一次 insert 操作的自增 id 值，并且无法返回成功更新的记录数目。</p>
<p>批量插入数据有两种实现方式，一种是使用 SIMPLE 执行器，用单条 sql 语句来插入所有数据，即 <code>insert into employee(name, email) values(...),(...),(...)</code> 方式，当然这种方式无法使用 mybatis 的 getGeneratedKeys 和 keyProperty 功能。另一种则是使用 BATCH 执行器，因为每个 sqlSession 都有自己相关联的 Executor，并且在获取之后就不能再更改了，所以通常我们需要临时获取一个 BATCH 类型的 session，然后进行批量插入，代码如下（网上找的，能看就行）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
SqlSession session = sqlSessionFactory.openSession(ExecutorType.BATCH);
try {
    UserDao batchUserDao = session.getMapper(UserDao.class);
    for (UserCommand user : users) {
        batchUserDao.insertUser(user);
    }
    session.commit(); // 提交事务的时候才会进行更新
    session.clearCache(); // 清理缓存，防止内存溢出
} finally {
    session.close();
}
</script></code></pre>
<p>除了调用 session.commit() 会执行批量更新之外，也可以调用 session 的 <code>List&lt;BatchResult&gt; flushStatements()</code> 方法来执行批量更新（推荐）。</p>
<h2 id="、-的区别"><a href="#、-的区别" class="headerlink" title="#{}、${} 的区别"></a><code>#{}</code>、<code>${}</code> 的区别</h2><p>阅读过 mybatis 的官方文档就可以知道，mybatis 的 select、insert、update、delete 语句的类型（<code>statementType</code>）都是 <code>PREPARED</code>（预编译类型，对应 jdbc 中的 PreparedStatement），statementType 有三个取值：<code>STATEMENT</code>，<code>PREPARED</code> 或 <code>CALLABLE</code>，这会让 MyBatis 分别使用 <code>Statement</code>，<code>PreparedStatement</code> 或 <code>CallableStatement</code>，因为默认情况下是预编译语句类型，所以我们可以使用 <code>#{}</code> 占位符，这个占位符其实就是 PreparedStatement 中的 <code>?</code> 占位符。</p>
<p>在学习 jdbc 的时候我们没有详细了解过 PreparedStatement 语句类型，现在我要告诉大家的是，Statement 不能防止 SQL 注入，而 PreparedStatement 能够防止 SQL 注入（Statement 是 PreparedStatement 的父接口，而 PreparedStatement 又是 CallableStatement 的父接口），那么什么是 SQL 注入呢？假设存在这样一条 SQL 语句，<code>select * from user where username = ? and password = ?</code>，作用很简单，就是查找与 username 和 password 相匹配的 user 记录（比如用户登录），正常情况下是这样的（暂不考虑 PreparedStatement 的防注入功能，只是简单的字符串替换），用户传入的 username 为 <code>&#39;Otokaze&#39;</code>，password 为 <code>&#39;123456&#39;</code>，那么实际发送给 mysql 的语句就是 <code>select * from user where username = &#39;Otokaze&#39; and password = &#39;123456&#39;</code>，没什么问题，正常找出这条记录；那么如果用户不怀好意，故意将 password 改为 <code>&#39;123456&#39; or 1 = 1</code>，那么实际执行的 sql 就是 <code>select * from user where username = &#39;Otokaze&#39; and password = &#39;123456&#39; or 1 = 1</code>，因为 and 的优先级比 or 的优先级高，所以这条判断语句可以看作为 <code>(username = &#39;Otokaze&#39; and password = &#39;123456&#39;) or (1 = 1)</code>，显然，<code>1 = 1</code> 是永远会成立的，这样的话，即使用户不知道用户名和密码，就可以得到 user 表中的所有记录！这就是所谓的”SQL 注入攻击”。</p>
<p>那么 PreparedStatement 是如何防止这种注入攻击的呢？还是假设 sql 语句为 <code>select * from user where username = ? and password = ?</code>，当我们通过 PreparedStatement 的 setString() 方法传入 <code>Otokaze</code> 和 <code>123456</code> 时，PreparedStatement 会将 <code>?</code> 作为一个字符串来处理，即实际的语句为 <code>select * from user where username = &#39;Otokaze&#39; and password = &#39;123456&#39;</code>，这时候即使你传入 <code>1 = 1</code> 这样的语句，也不会其作用，因为此时它只是字符串的一部分，即 <code>select * from user where username = &#39;Otokaze&#39; and password = &#39;123456 or 1 = 1&#39;</code>，如果 password 或 username 中存在单引号，那么 PreparedStatement 会将它进行转义，即 <code>\&#39;</code>，这样就能防止绝大多数 SQL 注入攻击了。</p>
<p>OK，回到 mybatis 的 <code>#{}</code> 和 <code>${}</code>，前面说了，默认情况下，mybatis 的语句类型就是 PreparedStatement，而 <code>#{}</code> 其实就是 PreparedStatement 里面的 <code>?</code> 占位符，因为 PreparedStatement 会将其作为一个字符串处理，所以可以防止 SQL 注入攻击；那么 <code>${}</code> 又是什么东西呢？也简单，<code>${}</code> 作用和 <code>#{}</code> 是相似的，只不过 <code>${}</code> 会在生成 PreparedStatement 之前被进行变量替换（类似 shell 中的变量替换），即在生成预编译语句之前，这个 <code>${}</code> 占位符就被对应的变量值给替换了（注意不会当作一个字符串看待），所以不能防止 SQL 注入攻击，但是有些时候我们又不得不使用 <code>${}</code>，比如我们想动态传递一个 table 名给 sql 语句进行拼装，因为 table 名不能使用字符串表示（单双引号都不行，而数值、字符串、时间日期这些基本上都可以使用字符串表示），即 <code>select * from ${table_name}</code> 这样，传入的 <code>table_name = user</code> 才会生效，如果使用 <code>select * from #{table_name}</code> 就会变为 <code>select * from &#39;user&#39;</code> 了，不是合法的 sql 语句，然后就会报错了。</p>
<p>总结：能用 <code>#{}</code> 的地方就使用 <code>#{}</code>，一是为了安全（防止 sql 注入），二是为了性能（重用预编译语句），如果某些时候必须使用 <code>${}</code>（比如动态表名），尽量在应用程序中过滤一些不安全的字符，防止 sql 注入。</p>
<h2 id="mapper-参数处理"><a href="#mapper-参数处理" class="headerlink" title="mapper 参数处理"></a>mapper 参数处理</h2><p>mybatis 的结构其实比较简单，总的来说就是，一个配置文件，即 mybatis-config.xml，主要配置的东西是：事务管理器类型、JDBC DataSource、Mapper 映射相关的配置，然后就是我们的 mapper 接口和 mapper 文件，mapper 文件其实就是 mapper 接口的一种实现，我们的 sql 语句就是写在 mapper 文件中，而我们的方法接口（返回值、方法名、形参列表等）这些都是在 mapper 接口中进行配置的（就是一个普通的接口方法声明），现在我们就来讨论一下形参列表的一些细节问题。</p>
<ul>
<li>单参数（没用 <code>@Param</code>）：分为这么几种情况（单个参数不会被封装为 map，但仍然需要 key 来访问，语法为 <code>#{key}</code>，下同）：<ul>
<li>标量类型：数值、数值包装类、字符串等，访问的 key 是没有要求的，随便一个 key 就能访问，通常我们会使用参数名称作为 key 来访问。</li>
<li>数组类型：这里说的数组就是 Java 的内置数组，即 built-in 数组，key 为 <code>array</code>，使用 <code>array[index]</code> 来获取指定元素。</li>
<li>列表类型：列表类型就是 java.util.List 类型，key 为 <code>list</code>，使用 <code>list[index]</code> 来访问指定索引位置的元素。</li>
<li>集合类型：java.util.Collection 的 key 为 <code>collection</code>，也可使用其子类特定的 key，比如 <code>list</code>。</li>
<li>Set 类型：MyBatis 并没有给 Set 提供专有的参数名，如 set，必须通过 <code>collection</code> 来访问。</li>
<li>Map 类型：这个就简单了，访问里面的 key 直接使用 <code>#{key}</code> 来访问就行了，很简单。</li>
<li>Pojo类型：也简单，和访问 map 一样，key 就是 getter 方法的属性名称。</li>
</ul>
</li>
<li>单参数（用了 <code>@Param</code>）：可以将其看作为只有一个参数的“多参数”类型，访问形参的方式为 <code>#{annotationValue}</code> 或 <code>#{param1}</code> 来访问。</li>
<li>多参数：会将参数列表封装为一个 map，这个 map 是形参列表的 map，所以我们需要先通过一个 key 来获取对应的形参，然后再使用上述方法来访问形参里面的数据，而默认情况下，如果没有使用 <code>@Param</code> 注解标注形参，那么访问这些形参的 key 就是 <code>0...index</code>（只能访问标量类型的形参）、<code>param1...paramN</code>，如果形参使用了 <code>@Param</code> 注解，也可以使用注解指定的 value 值作为 key 来访问对应的形参。举个例子，第 1 个形参声明方式为 <code>@Param(&quot;user&quot;) User user</code>，则可以通过 <code>#{param1.username}</code> 或者 <code>#{user.username}</code> 来访问 user.getUsername() 的值；又比如第 3 个形参为 <code>@Param(&quot;list&quot;) List&lt;String&gt; names</code>，可以通过 <code>#{param3[0]}</code> 或者 <code>#{list[0]}</code> 来访问这个 list 的第零个元素。</li>
</ul>
<h2 id="mapper-返回值相关"><a href="#mapper-返回值相关" class="headerlink" title="mapper 返回值相关"></a>mapper 返回值相关</h2><p>上一节说到，mapper 方法有三个重要的元素：返回值、方法名、形参列表。方法名比较简单，就是 select/insert/update/delete 标签的 id，而形参列表的一些处理细节在上一节中也详细介绍了，那么现在只剩下返回值没介绍了。</p>
<p>在前面的 CRUD 例子中，EmployeeMapper 接口是这样声明的：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.mapper;

import java.util.List;
import com.zfl9.bean.Employee;

public interface EmployeeMapper {
    int addEmployee(Employee employee);

    Employee getEmployeeById(Integer id);

    List<Employee> getAllEmployees();

    int updateEmployee(Employee employee);

    int deleteEmployeeById(Integer id);

    int deleteAllEmployees();

    void truncateEmployeeTable();
}
</script></code></pre>
<p>我们知道，mybatis 中分别为增删改查提供了各自的 xml 标签，即 <code>select</code>、<code>insert</code>、<code>update</code>、<code>delete</code>，select 标签可以说是其中最复杂的一个了，它的返回值我们后面再详细说明；先来解决 insert、update、delete 语句的返回值问题；这些标签对应的接口方法的返回值不需要也不能在 mapper.xml 中声明，mybatis 会自动根据方法签名来返回对应的值。通常，这些方法都是返回一个 int、long、boolean、java.lang.Integer、java.lang.Long、java.lang.Boolean、void 类型，void 类型其实就是不返回任何东西，所以这里就单独介绍 int、long、boolean 返回值类型。</p>
<p>int/long 返回值的意义是一样的，表示当前语句执行后，数据库中受影响的记录数目（affectedRows），而 boolean 返回值比较少用，一般来说，它的意义和 int/long 也是一样的，返回受影响的记录数，但因为是布尔类型，所以只要这个记录数大于 0，就会返回 true，如果等于 0，就返回 false。</p>
<p>其实你也注意到了，truncateEmployeeTable() 方法的返回值我设置的是 void，为什么不设置为 int 来获取受影响的记录数呢？好吧其实我一开始是这样干的，但是 <code>truncate table `table_name` </code> 语句的作用就是清空某张表，没有所谓受影响记录数，因为执行完之后表中就没有记录了，而即使你将返回值设为 int，返回的也是 0，所以干脆将其设为 void，免得有什么歧义。</p>
<p>OK，再来说说最复杂也是最常用的 select 方法的返回值，前面我们已经多次演示过返回 <code>Employee</code>、<code>List&lt;Employee&gt;</code>，注意无论是返回 Employee 还是 <code>List&lt;Employee&gt;</code>，对应的 select 标签的 <code>resultType</code> 都是 <code>com.zfl9.bean.Employee</code>，没错，对于 list 返回类型也是一样的，因为如果你将 resultType 设为 List 也没有实际意义，因为 mybatis 可以通过方法签名知道它的返回值类型，而只有传递集合元素的类型才有意义（因为 Java 的泛型信息在运行期间会被擦除，即所谓的“类型擦除”），所以我们需要告诉具体的元素类型是什么，不然 mybatis 只能知道这是一个 Object 元素类型，而不是我们想要的 Employee 元素类型。</p>
<p>但其实我们还能将 select 方法的返回值设为 Map，当然这里面有可以细分为两种情况，第一种情况是：如果 select 语句只会返回一条记录，那么我们就不需要做什么特殊操作，只要将 select 标签的 resultType 设为 <code>Map</code>，然后将方法的返回值类型设为 <code>Map&lt;String, Object&gt;</code> 就行了，其中 key 就是这条记录的字段名，而 value 就是对应的字段值，什么意思呢？来看一个简单的例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
Map<String, Object> getEmployeeByIdReturnMap(int id);
</script></code></pre>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<select id="getEmployeeByIdReturnMap" resultType="Map">
  select * from employee where id = #{id}
</select>
</script></code></pre>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetEmployeeByIdReturnMap() {
    Map<String, Object> map = employeeMapper.getEmployeeByIdReturnMap(1);
    Assert.assertFalse(map.isEmpty());
    System.out.println(map);
}
</script></code></pre>
<p>输出结果：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
{address=江西省赣州市, name=zfl9, telephone=123456, id=1, email=root@zfl9.com}
</script></code></pre>
<p>另一种情况则是，select 语句返回多条 Employee 记录，这种情况下，我希望将 Employee 中的某个 property 作为 key，然后 employee 对象作为 value 存储在一个 map 中，然后返回给调用者。做法也很简单，但是我们需要使用一个 <code>@MapKey(&quot;propertyNameAsMapKeyName&quot;)</code> 注解标注一下我们的这个查询方法，好告诉 mybatis 我们需要将 employee 对象中的指定属性作为 map 的 key，进行封装，例子如下：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@MapKey("name")
Map<String, Employee> getAllEmployeesReturnMap();
</script></code></pre>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<select id="getAllEmployeesReturnMap" resultType="Map">
  select * from employee
</select>
</script></code></pre>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetAllEmployeesReturnMap() {
    Map<String, Employee> map = employeeMapper.getAllEmployeesReturnMap();
    Assert.assertFalse(map.isEmpty());
    System.out.println(map);
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain">
{zfl9={address=江西省赣州市, name=zfl9, telephone=123456, id=1, email=root@zfl9.com}, youtube={address=美利坚合众国, name=youtube, telephone=123124, id=4, email=root@youtube.com}, facebook={address=美利坚合众国, name=facebook, telephone=123066, id=5, email=root@facebook.com}, baidu={address=北京市海淀区, name=baidu, telephone=123312, id=2, email=root@baidu.com}, google={address=美利坚合众国, name=google, telephone=122345, id=3, email=root@google.com}}
</script></code></pre>
<p>说到这里，我就顺便提一下 select 查询的封装问题，在前面我们没有接触 resultMap 的时候，都是使用 resultType 来告诉 mybatis 该语句的返回值类型是什么，但其实上我们也知道，这个 resultType 其实就是 resultMap 的语法糖，因为 mybatis 内部其实会将这个 resultType 转换为一个 resultMap，而里面的 column 和 property 都是这个实体类里面的属性名称，但是我们知道，java 命名规范推荐的是使用 <strong>驼峰命名法</strong>，而数据库命名规范推荐的则是 <strong>下划线命名法</strong>，比较难对应，所以没有匹配上的 property 是不会被赋值的，仍然为 null 或 0，这时候我们有 3 种办法来解决这个问题，第一种方法就是使用 sql 的 <code>as aliasName</code> 方式，定义字段的别名，让这个别名与实体类的属性名相同，这样使用 resultType 就能直接对应上了；第二种方法则是在 mybatis-config.xml 中启用 <code>mapUnderscoreToCamelCase</code> 属性（settings 标签），将其改为 true，来启用下划线命名到驼峰命名的自动映射功能，即从 <code>A_COLUMN</code> 字段名到 <code>aColumn</code> 属性名的自动映射，只要我们的命名规范没问题，仍然可以只使用 resultType 来进行自动映射；而第三种方法就是使用 resultMap 来手动指定 column 到 property 的映射关系，毕竟在做一些复杂查询时，resultMap 还是不可避免的。</p>
<h2 id="sql-语句的重用"><a href="#sql-语句的重用" class="headerlink" title="sql 语句的重用"></a>sql 语句的重用</h2><p>在写某些复杂的 select 语句时，通常会定义一些很长的字段列表，而且还可能在多个地方使用这些字段列表，这时候我们就可以使用 sql 标签和 include 标签来将这个冗长的字段列表提取出来，放到一个 sql 标签中，然后在 select 语句内部使用 include 标签来引用这个 sql 语句，实现代码重用，来看几个简单的例子（注意，sql 标签可以在 select、insert、update、delete 标签中使用 include 来引用）：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<sql id="userColumns"> ${alias}.id,${alias}.username,${alias}.password </sql>

<select id="selectUsers" resultType="map">
  select
    <include refid="userColumns"><property name="alias" value="t1"/></include>,
    <include refid="userColumns"><property name="alias" value="t2"/></include>
  from some_table t1 cross join some_table t2
</select>
</script></code></pre>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<sql id="sometable">
  ${prefix}Table
</sql>

<sql id="someinclude">
  from <include refid="${include_target}"/>
</sql>

<select id="select" resultType="map">
  select field1, field2, field3
  <include refid="someinclude">
    <property name="include_target" value="sometable"/>
    <property name="prefix" value="Some"/>
  </include>
</select>
</script></code></pre>
<p>可以在 sql 标签内部使用变量，语法为 <code>${}</code>，而变量的值则是通过 include 标签的 property 标签指定的，属于静态替换，并且还可以嵌套替换。</p>
<h2 id="selectKey-的用法"><a href="#selectKey-的用法" class="headerlink" title="selectKey 的用法"></a>selectKey 的用法</h2><p>在前面我们都是使用 jdbc 3.0 的 GeneratedKeys 方法，对于不支持 jdbc 获取主键自增值的数据库，也可以使用 selectKey 来手动回填主键。需要注意的是 selectKey 的 order 属性，有 BEFORE 和 AFTER 两个取值，BEFORE 表示在 insert 之前先获取 id 值，而 AFTER 则表示在 insert 之后再获取 id 值（MySQL 的 <code>select last_insert_id()</code> 就是这种情况），例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
int addEmployeeUseSelectKey(Employee employee);
</script></code></pre>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<insert id="addEmployee" useGeneratedKeys="true" keyProperty="id">
  insert into employee(name, email, address, telephone) values(#{name}, #{email}, #{address}, #{telephone})
</insert>

<insert id="addEmployeeUseSelectKey">
  insert into employee(name, email, address, telephone) values(#{name}, #{email}, #{address}, #{telephone})
  <selectKey keyProperty="id" resultType="Integer" order="AFTER">
    select last_insert_id()
  </selectKey>
</insert>
</script></code></pre>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testAddEmployeeUseSelectKey() {
    Employee employee = new Employee("wikipedia", "root@wikipedia.org", "美利坚合众国", "666123");
    int affectedRows = employeeMapper.addEmployeeUseSelectKey(employee);
    Assert.assertTrue(affectedRows > 0);
    System.out.println(affectedRows);
    System.out.println(employee);
    sqlSession.commit();
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain">
1
Employee [ id = 6, name = wikipedia, email = root@wikipedia.org, address = 美利坚合众国, telephone = 666123 ]
</script></code></pre>
<h2 id="调用函数和存储过程"><a href="#调用函数和存储过程" class="headerlink" title="调用函数和存储过程"></a>调用函数和存储过程</h2><p>本质上，mybatis 就是 jdbc api 的简单封装，前面我们也介绍了 mybatis 中的三种语句类型，即 STATEMENT、PREPARED、CALLABLE，默认是 PREPARED，所以如果需要调用函数或存储过程，就需要显式的将 statementType 属性改为 CALLABLE，然后使用 jdbc 的固定语法：</p>
<ul>
<li><code>{? = call function_name[(arg1, arg2, ...)]}</code>：调用函数，其中 argN 可以使用 ? 占位。</li>
<li><code>{call procedure_name[(arg1, arg2, ...)]}</code>：调用存储过程，其中 argN 可以使用 ? 占位。</li>
</ul>
<p>因为 mybatis 中的 <code>#{}</code> 表达式就是 <code>?</code> 占位符，所以我们需要使用 <code>#{}</code> 表达式来替换上面出现的 <code>?</code>，语法为：<br><code>#{parameterName, mode=OUT, jdbcType=INTEGER}</code><br>必须指定 mode，这个 mode 是参数类型的意思，有 IN、OUT、INOUT 三个取值，然后就是 jdbcType，也要明确指定。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.bean;

public class StringLengthPojo {
    private String string;
    private Integer length;

    public String getString() {
        return string;
    }

    public void setString(String string) {
        this.string = string;
    }

    public Integer getLength() {
        return length;
    }

    public void setLength(Integer length) {
        this.length = length;
    }

    @Override
    public String toString() {
        return String.format("string: %s; length = %s", string, length);
    }
}
</script></code></pre>
<pre><code class="language-java line-numbers"><script type="text/plain">
void callFunction(StringLengthPojo pojo);
void callProcedure(StringLengthPojo pojo);
</script></code></pre>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<select id="callFunction" statementType="CALLABLE">
  {#{length, mode=OUT, jdbcType=INTEGER} = call char_length(#{string, mode=IN, jdbcType=VARCHAR})}
</select>

<select id="callProcedure" statementType="CALLABLE">
  {call test.char_length(#{string, mode=IN, jdbcType=VARCHAR}, #{length, mode=OUT, jdbcType=INTEGER})}
</select>
</script></code></pre>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testCallFunction() {
    StringLengthPojo pojo = new StringLengthPojo();
    pojo.setString("中华人民共和国");
    employeeMapper.callFunction(pojo);
    System.out.println(pojo);
}

@Test
public void testCallProcedure() {
    StringLengthPojo pojo = new StringLengthPojo();
    pojo.setString("中华人民共和国");
    employeeMapper.callProcedure(pojo);
    System.out.println(pojo);
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain">
string: 中华人民共和国; length = 7
string: 中华人民共和国; length = 7
</script></code></pre>
<h2 id="多数据库支持"><a href="#多数据库支持" class="headerlink" title="多数据库支持"></a>多数据库支持</h2><p>mybatis 3.1.1 起，提供多数据库的无缝支持。首先你要在mybatis.xml文件中添加如下配置：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<databaseIdProvider type="DB_VENDOR">
  <property name="MySQL" value="mysql"/>
  <property name="Oracle" value="oracle"/>
  <property name="SQL Server" value="sqlserver"/>
</databaseIdProvider>
</script></code></pre>
<p>name 是数据库厂商名，value 是自定义的数据库标识。如果不知道数据库的 name，可以这样来获取：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
Connection conn = dataSource.getConnection();
DatabaseMetaData metaData = conn.getMetaData();
return metaData.getDatabaseProductName();
</script></code></pre>
<p>然后，在 sql 映射文件中的 select/insert/update/delete 标签中添加 databaseId 属性，注意 id 相同：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.boco.iwms.base.dao.BasicSqlDao">
  <select id="getCountOfSql" resultType="int" useCache="false" statementType="STATEMENT" timeout="5000" databaseId="mysql">
    <![CDATA[
    SELECT COUNT(*) FROM user
    ]]>
  </select>

  <select id="getCountOfSql" resultType="int" useCache="false" statementType="STATEMENT" timeout="5000" databaseId="oracle">
    <![CDATA[
    SELECT COUNT(*) FROM user
    ]]>
  </select>
</mapper>
</script></code></pre>
<p>这样 mybatis 就会自动获取 dataSource 对应的 DatabaseProductName，并转换为 databaseId，然后找到与该 databaseId 匹配的 sql 语句（就是 select、insert、update、delete 这些）。如果没有与之匹配的 databaseId 语句，则使用默认的没有标注 databaseId 的语句，如果都没有，那么就会报错，注意，如果找到了一个带 databaseId 的语句和一个没带 databaseId 的语句，那么前者的优先级更高，后者会被舍弃（应该很好理解吧）。</p>
<h2 id="sql-语句中的特殊字符"><a href="#sql-语句中的特殊字符" class="headerlink" title="sql 语句中的特殊字符"></a>sql 语句中的特殊字符</h2><p>也许你也注意到了上一节中的 <code>&lt;![CDATA[ ... ]]&gt;</code> 标签，有些时候我们的 sql 语句中会有一些 xml 特殊字符（主要是 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code> 这三个），这时候就需要进行一些特殊处理了，否则在构造 SqlSessionFactory 的时候就会报错，因为对应的 xml 文档是有问题的，无法解析，有两种解决办法，第一种是像上面那样，使用 CDATA 标签包住我们的 sql 语句，这样里面有什么特殊字符都不怕了；第二种方式则是使用 xml 的字符实体来转义这三个特殊字符，分别对应：<code>&amp;lt;</code>、<code>&amp;gt;</code>、<code>&amp;amp;</code>。</p>
<h2 id="mybatis-日志配置-log4j"><a href="#mybatis-日志配置-log4j" class="headerlink" title="mybatis 日志配置 log4j"></a>mybatis 日志配置 log4j</h2><p>使用 mybatis 的时候，有时候我希望能够看到 mybatis 实际发出的 sql 和对应的参数是什么，能做到吗？当然是可以的，这是官网的介绍：</p>
<p>MyBatis 的内置日志工厂提供日志功能，内置日志工厂将日志交给以下其中一种工具作代理：</p>
<ul>
<li>SLF4J</li>
<li>Apache Commons Logging</li>
<li>Log4j 2</li>
<li>Log4j</li>
<li>JDK logging</li>
</ul>
<p>MyBatis 在运行时会自动选择合适的日志工具。它会使用第一个查找得到的工具（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。</p>
<p>为了简单，这里就使用 log4j 来作为例子演示，首先在 pom.xml 中添加 log4j 的依赖，scope 只需要是 runtime 就可以了，因为只有运行时才会用到：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<dependency>
    <groupId>log4j</groupId>
    <artifactId>log4j</artifactId>
    <version>1.2.17</version>
</dependency>
</script></code></pre>
<p>然后在 resources 目录下创建 log4j.properties 文件，注意我们将 rootLogger 的日志级别设为了 INFO，而 mapper 包下的日志级别则设为了 TRACE：</p>
<pre><code class="language-properties line-numbers"><script type="text/plain">
log4j.rootLogger = INFO, STDOUT

log4j.logger.com.zfl9.mapper = TRACE

log4j.appender.STDOUT = org.apache.log4j.ConsoleAppender
log4j.appender.STDOUT.Threshold = TRACE
log4j.appender.STDOUT.ImmediateFlush = true
log4j.appender.STDOUT.Target = System.out
log4j.appender.STDOUT.layout = org.apache.log4j.PatternLayout
log4j.appender.STDOUT.layout.ConversionPattern = %d{yyyy-MM-dd HH:mm:ss.SSS} [%-5p] %c - %m%n
</script></code></pre>
<p>运行你的程序，你将会看到 com.zfl9.mapper 包下面的映射器打印的调试级别的日志，可以看到一些有很有用的调试信息，如执行的 sql、传入的参数。</p>
<h2 id="动态-SQL"><a href="#动态-SQL" class="headerlink" title="动态 SQL"></a>动态 SQL</h2><p>MyBatis 的强大特性之一便是它的动态 SQL。如果你有使用 JDBC 或其它类似框架的经验，你就能体会到根据不同条件拼接 SQL 语句的痛苦。例如拼接时要确保不能忘记添加必要的空格，还要注意去掉列表最后一个列名的逗号。利用动态 SQL 这一特性可以彻底摆脱这种痛苦。虽然在以前使用动态 SQL 并非一件易事，但正是 MyBatis 提供了可以被用在任意 SQL 映射语句中的强大的动态 SQL 语言得以改进这种情形。动态 SQL 元素和 JSTL 或基于类似 XML 的文本处理器相似。在 MyBatis 之前的版本中，有很多元素需要花时间了解。MyBatis 3 大大精简了元素种类，现在只需学习原来一半的元素便可。MyBatis 采用功能强大的基于 OGNL 的表达式来淘汰其它大部分元素。</p>
<p>你可以将动态 sql 标签看作 jstl 中的标签，动态 sql 标签可写在 sql、select、insert、update、delete 标签中。需要学习的标签很少，就 6 个：</p>
<ul>
<li><code>if</code>：根据 ognl 表达式作为测试条件，做动态的判断；</li>
<li><code>choose</code>：类似 java 的 switch，按照顺序动态的选择第一个匹配的元素；</li>
<li><code>trim</code>：可以给整个字符串加上前缀后缀（prefix、suffix），并且可以去除整个字符串首尾多余的字符；</li>
<li><code>where</code>：就是 sql 中的 where 条件的封装，本质就是 trim 的语法糖，即加上前缀 <code>where</code>，去掉开头多余的 <code>and/or</code>；</li>
<li><code>set</code>：就是 sql 中 update 语句的 set 关键字封装，和 where 一样也是 trim 的语法糖，即加上前缀 <code>set</code>，去掉结尾多余的 <code>,</code>；</li>
<li><code>foreach</code>：类似 jstl 中的 foreach 标签，用来遍历集合，如 array、list、set、map、collection，使用 <code>#{item变量名称}</code> 可访问元素。</li>
</ul>
<p>由于都比较简单，这里就不详细演示了，直接照搬官方文档中的例子过来（OGNL 和 EL 表达式很像，但 OGNL 还能调用对象的方法，语法同 Java）。</p>
<p><strong>if</strong><br>test 表达式中的变量都是从方法参数中读取的，不需要带什么 <code>#{}</code>，总之和 JSTL 很像就是了。</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<select id="findActiveBlogWithTitleLike" resultType="Blog">
  SELECT * FROM BLOG
  WHERE state = 'ACTIVE'
  <if test="title != null">
    AND title like #{title}
  </if>
</select>
</script></code></pre>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<select id="findActiveBlogLike" resultType="Blog">
  SELECT * FROM BLOG WHERE state = 'ACTIVE'
  <if test="title != null">
    AND title like #{title}
  </if>
  <if test="author != null and author.name != null">
    AND author_name like #{author.name}
  </if>
</select>
</script></code></pre>
<p><strong>choose</strong><br>只会匹配其中的一个，如果都没有匹配，则使用 otherwise（当然这个元素也可以没有）。</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<select id="findActiveBlogLike" resultType="Blog">
  SELECT * FROM BLOG WHERE state = 'ACTIVE'
  <choose>
    <when test="title != null">
      AND title like #{title}
    </when>
    <when test="author != null and author.name != null">
      AND author_name like #{author.name}
    </when>
    <otherwise>
      AND featured = 1
    </otherwise>
  </choose>
</select>
</script></code></pre>
<p><strong>where/set/trim</strong><br>注意我们前面的 if 示例，如果是这样的动态语句，并且假设我一个都没匹配上，会怎样？</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<select id="findActiveBlogLike" resultType="Blog">
  SELECT * FROM BLOG
  WHERE
  <if test="state != null">
    state = #{state}
  </if>
  <if test="title != null">
    AND title like #{title}
  </if>
  <if test="author != null and author.name != null">
    AND author_name like #{author.name}
  </if>
</select>
</script></code></pre>
<p>拼装出来的 sql 是这样的，多了一个 where，不是合法的 sql 语句，会报错：</p>
<pre><code class="language-sql line-numbers"><script type="text/plain">
SELECT * FROM BLOG WHERE
</script></code></pre>
<p>如果仅匹配第二个条件，又会怎样？开头多出一个 and，也不是合法的 sql，报错：</p>
<pre><code class="language-sql line-numbers"><script type="text/plain">
SELECT * FROM BLOG WHERE AND title like 'someTitle'
</script></code></pre>
<p>针对这些情况，mybatis 提供了一个 where 标签，专门表示 where 条件子句：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<select id="findActiveBlogLike" resultType="Blog">
  SELECT * FROM BLOG
  <where>
    <if test="state != null">
         state = #{state}
    </if>
    <if test="title != null">
        AND title like #{title}
    </if>
    <if test="author != null and author.name != null">
        AND author_name like #{author.name}
    </if>
  </where>
</select>
</script></code></pre>
<p>注意我们去掉了手写的 where，而是使用 <code>&lt;where&gt;</code> 标签来替代它，where 元素只会在至少有一个子元素的条件返回 SQL 子句的情况下才去插入 <code>WHERE</code> 子句。而且，若语句的开头为 <code>AND</code> 或 <code>OR</code>，where 元素也会将它们去除。注意到几个特性，如果 where 标签内部执行之后，整个字符串内容是空的（空字符串），则不会插入 where 关键字，相当于没有这个语句；如果至少有一个字符，那么就会在整个字符串的前面插入一个 <code>where</code> 关键字，并且去除整个字符串开头可能的 <code>and</code> 或 <code>or</code> 关键字（防止 sql 语法错误）。</p>
<p>这实际上和下面这个 trim 标签的作用和特征是完全一样的，因为 where 就是 trim 的一颗语法糖（反过来也是成立的，trim 也有上述 where 的特性）：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<trim prefix="WHERE" prefixOverrides="AND |OR ">
  ...
</trim>
</script></code></pre>
<p>注意，AND 和 OR 后面的空格也是必要的，使用 <code>|</code> 可以指定多个需要去除的字符串前缀，prefixOverrides、suffixOverrides 表达式不区分大小写。</p>
<p>类似于 where，在 update 语句中，我们也常常需要进行动态生成 sql，即 <code>set columnA = valueA, columnB = valueB</code>，对应的标签叫做 <code>&lt;set&gt;</code>：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<update id="updateAuthorIfNecessary">
  update Author
    <set>
      <if test="username != null">username=#{username},</if>
      <if test="password != null">password=#{password},</if>
      <if test="email != null">email=#{email},</if>
      <if test="bio != null">bio=#{bio}</if>
    </set>
  where id=#{id}
</update>
</script></code></pre>
<p>set 会动态的设置 SET 关键字（啰嗦一下，如果是空字符串，就相当于没有这个元素），同时会自动去除字符串尾部多余的逗号，它相当于这个 trim：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<trim prefix="SET" suffixOverrides=",">
  ...
</trim>
</script></code></pre>
<p><strong>foreach</strong><br>动态 SQL 的另外一个常用的操作需求是对一个集合进行遍历，通常是在构建 IN 条件语句的时候。比如：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<select id="selectPostIn" resultType="domain.blog.Post">
  SELECT *
  FROM POST P
  WHERE ID in
  <foreach item="item" index="index" collection="list" open="(" separator="," close=")">
    #{item}
  </foreach>
</select>
</script></code></pre>
<p>item 是指定当前遍历的元素的变量名，index 则是索引变量名，collection 则是 ognl 表达式，list 就是 <code>#{list}</code> 参数，它是一个 java.util.List 集合，open 则是整个字符串的开始字符串（注意是字符串，这意味着可以添加任意字符），close 和 open 相似，是结束字符串，而 separator 则是元素的分隔符，末尾的多余分隔符会自动去除；注意，和 trim、where、set 一样，如果集合中没有一个元素，则直接返回空串，相当于没有这个 foreach 标签，特别注意哦。还有就是里面使用 <code>#{item}</code> 来访问当前遍历的元素，使用 <code>#{index}</code> 来获取当前的元素索引值，另外，如果是遍历 map，则这个 index 是 key，item 是 value，如果是遍历的 list、array，那么 index 就是元素索引，item 就是元素本身，set 遍历不能使用 <code>index</code> 属性。</p>
<p><strong>两个内置参数</strong><br><strong><code>_parameter</code></strong><br>代表整个参数，如果是单个参数，那就是这个参数的值；如果是多个参数，则代表参数列表（就是 Map），通过 <code>_parameter.paramN</code> 访问各参数。</p>
<p><strong><code>_databaseId</code></strong><br>如果配置了多数据库支持，即 mybatis-config.xml 中配置了 <code>&lt;databaseIdProvider&gt;</code> 标签，那么这个 <code>_databaseId</code> 变量就是当前数据库的 ID 标识。</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<insert id="insert">
  <selectKey keyProperty="id" resultType="int" order="BEFORE">
    <if test="_databaseId == 'oracle'">
      select seq_users.nextval from dual
    </if>
    <if test="_databaseId == 'db2'">
      select nextval for seq_users from sysibm.sysdummy1"
    </if>
  </selectKey>
  insert into users values (#{id}, #{name})
</insert>
</script></code></pre>
<p><strong>bind 标签</strong><br>bind 标签和 jstl 的 set 标签类似，绑定一个变量到上下文中，可以在其它地方引用它，比如传入查询条件的时候，让 mybatis 自动插入 <code>% %</code> 前后缀：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<select id="selectBlogsLike" resultType="Blog">
  <bind name="pattern" value="'%' + _parameter.getTitle() + '%'"/>
  SELECT * FROM BLOG
  WHERE title LIKE #{pattern}
</select>
</script></code></pre>
<p>注意不能使用 <code>name like &#39;%${name}%&#39;</code> 来添加前后缀，会报错，但是我们可以将 <code>#{}</code> 换为 <code>${}</code>，就不会报错，但是 <code>${}</code> 有被 sql 注入的风险。</p>
<h2 id="MyBatis-缓存"><a href="#MyBatis-缓存" class="headerlink" title="MyBatis 缓存"></a>MyBatis 缓存</h2><p>mybatis 提供两种类型的缓存，<strong>一级缓存</strong>、<strong>二级缓存</strong>。注意，这里说的缓存都是指 <strong>查询缓存</strong>（select），insert、update、delete 不需要缓存。</p>
<p><strong>一级缓存</strong>（本地缓存）<br>SqlSession 级别的缓存，所谓缓存大多数情况下都是一个 Map（假设存储在内存中），mybatis 也是如此，一级缓存可以看作 SqlSession 实例中的一个成员变量（实际上并不是），这也是为什么叫做一级缓存的原因。可以知道，一级缓存的生命周期和 SqlSession 实例的生命周期是一样的。简单例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testFirstLevelCache() {
    Employee emp01 = employeeMapper.getEmployeeById(1);
    System.out.println(emp01);

    Employee emp02 = employeeMapper.getEmployeeById(1);
    System.out.println(emp02);

    System.out.println(emp01 == emp02);
}
</script></code></pre>
<p>运行结果如下：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
2019-01-09 10:23:20.651 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==>  Preparing: select * from employee where id = ?
2019-01-09 10:23:20.698 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==> Parameters: 1(Integer)
2019-01-09 10:23:20.727 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==    Columns: id, name, email, address, telephone
2019-01-09 10:23:20.728 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==        Row: 1, zfl9, root@zfl9.com, 江西省赣州市, 123456
2019-01-09 10:23:20.730 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==      Total: 1
Employee [ id = 1, name = zfl9, email = root@zfl9.com, address = 江西省赣州市, telephone = 123456 ]
Employee [ id = 1, name = zfl9, email = root@zfl9.com, address = 江西省赣州市, telephone = 123456 ]
true
</script></code></pre>
<p>可以看到，虽然我们调用了两次 employeeMapper.getEmployeeById(1) 方法，但是日志显示只查询了一次数据库，而且 <code>emp01 == emp02</code> 的结果居然是 true，也就是说它们是同一个对象（内存地址相同）。mybatis 缓存了第一次查询的结果（emp01），然后当我们再次查询 id 为 1 的员工时，它发现查询语句和查询条件是相同的，为了减轻数据库的负担，mybatis 直接将缓存中结果对象返回给调用者，这也就是为什么它们的引用是相同的了。</p>
<p>一级缓存默认是一直开启的，mybatis 早期版本甚至无法关闭一级缓存，mybatis 3.x 提供了一个 <code>localCacheScope</code> setting 选项，它有两个取值，<code>SESSION|STATEMENT</code>，SESSION 为默认值，表示一级缓存的作用范围为 session，如果将其设置为 STATEMENT，则表示作用范围为 statement 级别，也就是关闭一级缓存。每个 sqlSession 对象都有属于自己的一级缓存，不同 sqlSession 之间的一级缓存 map 是不一样的，不同 sqlSession 中的一级缓存数据也互不影响。注意，一级缓存的数据是存储在一个 hashmap 中的，mybatis 没有对这个 hashmap 进行容量限制，因为一级缓存只会在会话级别使用，而一个会话的生命周期通常都不会太长，所以没必要限制容量。</p>
<p>一级缓存失效的几种情况：</p>
<ul>
<li>sqlSession 不同（因为不同会话的缓存对象是不同的）。</li>
<li>sqlSession 相同，但查询条件不同（显然，因为缓存中没有这条数据）。</li>
<li>sqlSession 相同，但调用了 insert、update、delete 更新方法（因为这次增删改操作可能会影响当前缓存的数据，即脏数据）。</li>
<li>sqlSession 相同，但调用了 close()、commit()、clearCache() 方法（close 很简单不解释，commit 是提交事务的意思，因为事务里面都是增删改操作，所以同上，后者就更明显了，显式调用 sqlSession 的 clearCache() 方法来清空一级缓存中的数据，自然就会失效了）。</li>
</ul>
<p><strong>二级缓存</strong>（全局缓存）<br>二级缓存虽然叫做全局缓存，但是实际上每个 namespace 的二级缓存也是不同的，互不影响，所谓 namespace 就是命名空间（不同的 xml 文件、<strong>不同类型的 Mapper 接口</strong>），这样看来，不同 xml 之间的二级缓存也是不同的，当然 mybatis 允许你在一个 namespace 中使用 <code>&lt;cache-ref&gt;</code> 标签引用另外一个 namespace 中的二级缓存标签，这样两个命名空间使用的就是相同的二级缓存，即共享了。注意，二级缓存默认情况下是没有开启的，需要自己在 mapper.xml 中配置 <code>&lt;cache&gt;</code> 元素来开启，而一级缓存是默认启用的。</p>
<p>那么二级缓存中的数据是从哪里来的呢？答案是从一级缓存中来的，每当关闭或提交一个 sqlSession 对象（调用 <code>close()</code> 或 <code>commit()</code> 方法），mybatis 就会将该 sqlSession 的一级缓存中的数据转移到当前 namespace 的二级缓存中（当然这里假设同时开启了一级缓存和二级缓存）。当我们开启二级缓存后，mybatis 查询到的数据会先放到一级缓存中，当我们提交或关闭会话后，mybatis 会将一级缓存中的数据转移到二级缓存中，注意必须提交或关闭后其它会话才能读取到缓存中的对象！此时数据的查询顺序为：二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p>
<p><strong>开启二级缓存的步骤</strong>：</p>
<ol>
<li>修改 mybatis.xml，启用 <code>cacheEnabled</code> setting，虽然默认为 true，但是为了防止版本更新改变默认值，建议还是显式的配置为 true。</li>
<li>修改 mapper.xml，在开头添加 <code>&lt;cache&gt;</code> 元素，最小配置可以不指定任何属性，即 <code>&lt;cache/&gt;</code> 就可以启用当前 namespace 的二级缓存。</li>
</ol>
<p>cache 有几个常用的 xml 属性：</p>
<ul>
<li><code>type</code>：Cache 自定义实现类的全类名，即允许使用第三方的 Cache 接口实现，如 redis 缓存等。</li>
<li><code>size</code>：缓存的大小，即最多缓存多少个对象，默认是 1024，超过的话会执行 eviction 策略。</li>
<li><code>eviction</code>：缓存的回收策略，默认是 LRU，允许的取值为：LRU、FIFO、SOFT、WEAK。</li>
<li><code>flushInterval</code>：缓存的刷新间隔，默认不刷新，注意刷新间隔的时间单位为毫秒。</li>
<li><code>readOnly</code>：交给调用者的缓存对象是否为只读的，默认为 false，即 mybatis 认为调用者可能会修改叫出去的缓存对象，为了防止调用者修改缓存中的源对象，mybatis 会使用序列化和反序列化技术克隆 Map 中的缓存对象，然后将这个克隆出来的对象交给调用者，这样调用者无论如何修改都不会影响缓存 map 中的对象，显然，这要求 <strong>POJO 实现 java.io.Serializable 标记接口</strong>，当然序列化和反序列化是需要额外开销的，如果可能，尽量将 readOnly 为 true，这样 mybatis 交给你的就是 map 中的对象引用，注意不要修改里面的对象数据！</li>
</ul>
<p><strong>为什么一级缓存交给我们的是缓存对象的引用，而不是序列化反序列化出来的克隆对象？</strong><br>因为这里提到了二级缓存的 readOnly 属性，默认情况下这个属性的值为 false，即交给我们的缓存对象是克隆出来的，但是你想过没有，为什么一级缓存中我们执行 <code>emp01 == emp02</code> 的结果是 true，也就是说 mybatis 一级缓存的 readOnly 是为 true 的，而且无法更改，这难道是 mybatis 的 bug？其实稍微想想也能够知道，一级缓存始终是同一个线程中使用（因为 sqlSession 实例不是线程安全的），通常我们修改 pojo 的数据都是为了更新到数据库中，即稍后我们通常都会调用更新方法，而更新之后 mybatis 会刷新一级缓存中的数据，所以通常我们都不会得到脏数据（但这要求你需要谨慎修改返回的 pojo 对象，如果你稍后不更新它，那么将会导致意想不到的 bug）！</p>
<p><strong>缓存相关的属性、方法</strong></p>
<ul>
<li>select 标签的 <code>useCache</code> 属性：<strong>影响二级缓存的使用</strong>，默认是 true，即该 select 查询会使用二级缓存；若为 false 则表示该 select 查询不会使用二级缓存，但一级缓存仍然可用。</li>
<li>select 标签的 <code>flushCache</code> 属性：<strong>影响一级缓存、二级缓存</strong>，默认为 false，表示该 select 查询不会清空一级和二级缓存，如果置为 true，那么 mybatis 每次调用该查询都会清空一级缓存和二级缓存。</li>
<li>增删改标签的 <code>flushCache</code> 属性：<strong>影响二级缓存</strong>：默认为 true，表示该更新操作会清空二级缓存，注意有些文档说它会影响一级缓存的数据，但其实对于一级缓存来说，无论该选项的值如何，只要进行了增删改操作，mybatis 就会清空一级缓存，因为更新方法总是会调用 clearCache() 方法！</li>
<li>调用 sqlSession 的 clearCache() 方法：<strong>影响一级缓存</strong>，也就是它只会清空一级缓存中的数据，不会影响二级缓存中的数据。</li>
<li><code>&lt;cache-ref namespace=&quot;com.zfl9.mapper.BarMapper&quot;/&gt;</code> 用来引用其它命名空间中的二级缓存实例，即共享二级缓存。</li>
</ul>
<p>总之，要想使某条 Select 查询使用二级缓存，你需要保证这三个条件：</p>
<ol>
<li>MyBatis 支持二级缓存的总开关：全局配置变量参数 <code>cacheEnabled=true</code></li>
<li>该 select 语句所在的 Mapper 配置了 <code>&lt;cache&gt;</code> 或 <code>&lt;cached-ref&gt;</code> 节点</li>
<li>该 select 语句的 xml 标签属性 <code>useCache=true</code></li>
</ol>
<p><strong>调用增删改操作后，二级缓存也会被清空，但是该策略是可以通过 flushCache xml 属性进行配置的</strong>：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testSecondLevelCache() {
    SqlSession sqlSession1 = sqlSession;
    SqlSession sqlSession2 = sqlSessionFactory.openSession();

    EmployeeMapper employeeMapper1 = sqlSession1.getMapper(EmployeeMapper.class);
    EmployeeMapper employeeMapper2 = sqlSession2.getMapper(EmployeeMapper.class);

    Employee employee01 = employeeMapper1.getEmployeeById(1);
    System.out.println(employee01);

    sqlSession1.commit();

    // employeeMapper2.addEmployee(new Employee("a", "b", "c", "d"));

    Employee employee02 = employeeMapper2.getEmployeeById(1);
    System.out.println(employee02);

    sqlSession1.close();
    sqlSession2.close();
}
</script></code></pre>
<p>注释掉 employeeMapper2.addEmployee() 方法（二级缓存不清空）：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
2019-01-09 20:55:55.277 [DEBUG] com.zfl9.mapper.EmployeeMapper - Cache Hit Ratio [com.zfl9.mapper.EmployeeMapper]: 0.0
2019-01-09 20:55:55.474 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==>  Preparing: select * from employee where id = ?
2019-01-09 20:55:55.517 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==> Parameters: 1(Integer)
2019-01-09 20:55:55.551 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==    Columns: id, name, email, address, telephone
2019-01-09 20:55:55.551 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==        Row: 1, zfl9, root@zfl9.com, 江西省赣州市, 123456
2019-01-09 20:55:55.553 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==      Total: 1
Employee [ id = 1, name = zfl9, email = root@zfl9.com, address = 江西省赣州市, telephone = 123456 ]
2019-01-09 20:55:55.563 [DEBUG] com.zfl9.mapper.EmployeeMapper - Cache Hit Ratio [com.zfl9.mapper.EmployeeMapper]: 0.5
Employee [ id = 1, name = zfl9, email = root@zfl9.com, address = 江西省赣州市, telephone = 123456 ]
</script></code></pre>
<p>取消注释 employeeMapper2.addEmployee() 方法（二级缓存被清空）：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
2019-01-09 20:56:50.726 [DEBUG] com.zfl9.mapper.EmployeeMapper - Cache Hit Ratio [com.zfl9.mapper.EmployeeMapper]: 0.0
2019-01-09 20:56:50.974 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==>  Preparing: select * from employee where id = ?
2019-01-09 20:56:51.041 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==> Parameters: 1(Integer)
2019-01-09 20:56:51.068 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==    Columns: id, name, email, address, telephone
2019-01-09 20:56:51.068 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==        Row: 1, zfl9, root@zfl9.com, 江西省赣州市, 123456
2019-01-09 20:56:51.070 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==      Total: 1
Employee [ id = 1, name = zfl9, email = root@zfl9.com, address = 江西省赣州市, telephone = 123456 ]
2019-01-09 20:56:51.084 [DEBUG] com.zfl9.mapper.EmployeeMapper.addEmployee - ==>  Preparing: insert into employee(name, email, address, telephone) values(?, ?, ?, ?)
2019-01-09 20:56:51.085 [DEBUG] com.zfl9.mapper.EmployeeMapper.addEmployee - ==> Parameters: a(String), b(String), c(String), d(String)
2019-01-09 20:56:51.086 [DEBUG] com.zfl9.mapper.EmployeeMapper.addEmployee - <==    Updates: 1
2019-01-09 20:56:51.090 [DEBUG] com.zfl9.mapper.EmployeeMapper - Cache Hit Ratio [com.zfl9.mapper.EmployeeMapper]: 0.5
2019-01-09 20:56:51.090 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==>  Preparing: select * from employee where id = ?
2019-01-09 20:56:51.091 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==> Parameters: 1(Integer)
2019-01-09 20:56:51.091 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==    Columns: id, name, email, address, telephone
2019-01-09 20:56:51.092 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==        Row: 1, zfl9, root@zfl9.com, 江西省赣州市, 123456
2019-01-09 20:56:51.092 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==      Total: 1
Employee [ id = 1, name = zfl9, email = root@zfl9.com, address = 江西省赣州市, telephone = 123456 ]
</script></code></pre>
<p><strong>如何使用 ehcache 作为 mybatis 的二级缓存实现？</strong><br>mybatis 的 cache 标签有一个 type 属性，用于指定第三方的 Cache 实现类，步骤如下（ehcache 也是 Hibernate 的默认缓存实现）：</p>
<ol>
<li>获取 ehcache 的 jar 包（ehcache-core 等），并配置好 ehcache 的运行环境，如 ehcache.xml 配置文件；</li>
<li>获取 ehcache 的 mybatis 适配包（Cache 接口实现包），不用自己写，mybatis github 仓库有提供，直接下载；</li>
<li>配置 mapper.xml 中的 cache 标签，只需要指定 type 属性，如果需要改变 ehcache 运行时属性只需在 cache 标签中使用 property 进行配置。</li>
</ol>
<p><strong>mybatis 缓存的原理浅析</strong><br>这里说的都是 mybatis 一级缓存和二级缓存的默认实现，暂不讨论第三方二级缓存。mybatis 的一二级缓存的数据结构基本都是 java.util.Map（实现类都是 PerpetualCache，即 HashMap 的简单封装），思考一下，这个 map 的 key 和 value 分别都是什么数据类型？答案是 <code>Map&lt;CacheKey, QueryResult&gt;</code>，CacheKey 就是用来唯一标识一条 mybatis 查询的 key，而 QueryResult 就是该查询的结果对象，一级缓存和二级缓存除了生命周期不同之外，工作原理什么的基本都是相同的。</p>
<p>那么这个 CacheKey 缓存键是什么东西呢？mybatis 又是如何判断两次查询是“相同”的呢（一二级缓存的判断条件是一样的）？</p>
<ol>
<li><code>&lt;select&gt;</code> 标签所在的 Mapper 的 namespace + <code>&lt;select&gt;</code> 标签的 id 属性值相同；</li>
<li>RowBounds 的 offset 和 limit 相同，RowBounds 是 MyBatis 用于处理分页的一个类；</li>
<li><code>&lt;select&gt;</code> 标签中定义的 sql 语句相同（准确的说应该是运算之后的 sql 语句相同）；</li>
<li>传递给 select 语句的查询参数相同。</li>
</ol>
<p>即只要两次查询满足以上条件且没有定义 <code>flushCache=&quot;true&quot;</code>，那么第二次查询会直接从一级缓存中读取数据。</p>
<p><strong>一级缓存和二级缓存的使用注意事项（脏数据）</strong><br>先来看一级缓存的脏数据例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testFirstLevelCacheDirtyData() {
    SqlSession session1 = sqlSession;
    SqlSession session2 = sqlSessionFactory.openSession();

    EmployeeMapper mapper1 = employeeMapper;
    EmployeeMapper mapper2 = session2.getMapper(EmployeeMapper.class);

    System.out.println("session1 读取数据: " + mapper1.getEmployeeById(1));
    System.out.println("session2 读取数据: " + mapper2.getEmployeeById(1));

    System.out.println("session2 更新数据: " + mapper2.updateEmployee(new Employee(1, "hqm8", "root@hqm8.com", "江西省南昌市", "123456")));

    System.out.println("session1 读取数据: " + mapper1.getEmployeeById(1));
    System.out.println("session2 读取数据: " + mapper2.getEmployeeById(1));

    session1.close();
    session2.close();
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain">
2019-01-10 10:59:26.369 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==>  Preparing: select * from employee where id = ?
2019-01-10 10:59:26.430 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==> Parameters: 1(Integer)
2019-01-10 10:59:26.471 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==    Columns: id, name, email, address, telephone
2019-01-10 10:59:26.472 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==        Row: 1, zfl9, root@zfl9.com, 江西省赣州市, 123456
2019-01-10 10:59:26.475 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==      Total: 1
session1 读取数据: Employee [ id = 1, name = zfl9, email = root@zfl9.com, address = 江西省赣州市, telephone = 123456 ]
2019-01-10 10:59:26.484 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==>  Preparing: select * from employee where id = ?
2019-01-10 10:59:26.485 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==> Parameters: 1(Integer)
2019-01-10 10:59:26.487 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==    Columns: id, name, email, address, telephone
2019-01-10 10:59:26.487 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==        Row: 1, zfl9, root@zfl9.com, 江西省赣州市, 123456
2019-01-10 10:59:26.488 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==      Total: 1
session2 读取数据: Employee [ id = 1, name = zfl9, email = root@zfl9.com, address = 江西省赣州市, telephone = 123456 ]
2019-01-10 10:59:26.489 [DEBUG] com.zfl9.mapper.EmployeeMapper.updateEmployee - ==>  Preparing: update employee set name=?, email=?, address=?, telephone=? where id=?
2019-01-10 10:59:26.489 [DEBUG] com.zfl9.mapper.EmployeeMapper.updateEmployee - ==> Parameters: hqm8(String), root@hqm8.com(String), 江西省南昌市(String), 123456(String), 1(Integer)
2019-01-10 10:59:26.490 [DEBUG] com.zfl9.mapper.EmployeeMapper.updateEmployee - <==    Updates: 1
session2 更新数据: 1
session1 读取数据: Employee [ id = 1, name = zfl9, email = root@zfl9.com, address = 江西省赣州市, telephone = 123456 ]
2019-01-10 10:59:26.490 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==>  Preparing: select * from employee where id = ?
2019-01-10 10:59:26.491 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==> Parameters: 1(Integer)
2019-01-10 10:59:26.491 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==    Columns: id, name, email, address, telephone
2019-01-10 10:59:26.491 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==        Row: 1, hqm8, root@hqm8.com, 江西省南昌市, 123456
2019-01-10 10:59:26.492 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==      Total: 1
session2 读取数据: Employee [ id = 1, name = hqm8, email = root@hqm8.com, address = 江西省南昌市, telephone = 123456 ]
</script></code></pre>
<p>session1 和 session2 同时读取了 id 为 1 的员工记录，然后我们在 session2 中更新了该条记录，将 name 从 zfl9 改为了 hqm8，再次调用 session1 和 session2 的读取操作，发现 session1 读取的仍然是一级缓存中的记录，即读取到了脏数据，而 session2 因为在两次查询之间调用了更新操作，所以一级缓存被清空了，读取的是最新数据。</p>
<p>针对这种情况的脏读，建议在需要查询最新数据前显式的调用一下 <code>clearCache()</code> 方法，清空当前会话的一级缓存再来查询。</p>
<p>再来看一个二级缓存的脏读例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testCacheWithDiffererntNamespace() throws Exception {
    SqlSession sqlSession1 = factory.openSession(true);
    SqlSession sqlSession2 = factory.openSession(true);
    SqlSession sqlSession3 = factory.openSession(true);

    // studentMapper 中的查询会涉及到 ClassMapper 中的 class 表，即多表查询
    StudentMapper studentMapper1 = sqlSession1.getMapper(StudentMapper.class);
    StudentMapper studentMapper2 = sqlSession2.getMapper(StudentMapper.class);
    ClassMapper      classMapper = sqlSession3.getMapper(ClassMapper.class);

    // 二级缓存正常生效（sqlSession1 提交之后会将一级缓存中的数据转移到二级缓存）
    System.out.println("studentMapper1 读取数据: " + studentMapper1.getStudentByIdWithClassInfo(1));
    sqlSession1.close();
    System.out.println("studentMapper2 读取数据: " + studentMapper2.getStudentByIdWithClassInfo(1));

    // 在另一个 namespace 中更新 class 表的数据，而这条数据还缓存在 student namespace 中，发生脏读
    classMapper.updateClassName("特色一班", 1);
    sqlSession3.commit();
    System.out.println("studentMapper2 读取数据: " + studentMapper2.getStudentByIdWithClassInfo(1));
}
</script></code></pre>
<p>执行结果就不贴出来了，因为这个例子是从网上拿过来的，我们来回顾一下一级缓存的脏读发生条件，一级缓存的作用域是当前 session，所以如果分别在两个 session 中读取了同一条记录，假设为 session1 和 session2，那么当我们在 session1 中更新该记录后，mybatis 会清空 session1 中的一级缓存，但是并不会清空 session2 中的一级缓存，所以当我们在 session2 中再次读取该记录时就会读取到之前一级缓存中的数据，发生脏读。</p>
<p>二级缓存的脏读发生条件也是差不多的，二级缓存本质上和一级缓存没什么不同，只不过作用范围大了点，二级缓存的作用范围为当前 namespace；假设存在两个 namespace 不同的 session，如 namespace1-&gt;session1、namespace2-&gt;session2，namespace1 的查询会涉及到 namespace2 中的表（典型的多表查询），那么当我们在 namespace2 中更新了缓存在 namespace1 中的二级缓存数据时，mybatis 只会清空 namespace2 中的二级缓存，而不会清空 namespace1 中的二级缓存，所以当我们在 namespace1 中再次读取该数据时就会发生脏读。</p>
<p>那么如何防范这种类型的二级缓存脏读呢？对于上面这个例子，可以在 classMapper 这个 xml 中使用 <code>&lt;cache-ref&gt;</code> 来引用 studentMapper 里面的 cache 节点，这样两个 mapper 使用的就是同一个 namespace 了；对于这种多表查询的场景，建议将同一个表的 sql 语句都放到同一个 namespace 中，更进一步的说，只要是可能会一起用到的查询和数据表都组织到同一个 namespace 中，这样只要更新了，这个 namespace 的二级缓存就会被清空，可以很好的避免二级缓存脏数据。</p>
<p><strong>一级缓存图解</strong><br><img src="/images/mybatis-first-level-cache.png" alt="一级缓存图示"><br><img src="/images/mybatis-first-level-cache-class.png" alt="一级缓存图示 - 类的继承关系"><br><img src="/images/mybatis-first-level-cache-yuanli.png" alt="一级缓存图示 - 缓存工作流程"></p>
<p>对于一个查询，根据 statementId、sql、params、rowBounds 来构建一个 cacheKey，根据这个 cacheKey 去一级缓存中取出对应的缓存结果：</p>
<ul>
<li>判断从 Cache 中根据特定的 key 值取的数据数据是否为空，即是否命中；</li>
<li>如果命中，则直接将缓存结果返回；</li>
<li>如果没命中：<ul>
<li>去数据库中查询数据，得到查询结果；</li>
<li>将 key 和查询到的结果分别作为 key、value对存储到 Cache 中；</li>
<li>然后再将查询结果返回给调用者；</li>
</ul>
</li>
</ul>
<p><strong>二级缓存图解</strong><br><img src="/images/mybatis-second-level-cache.png" alt="二级缓存图示"></p>
<p>如上图所示，当开一个会话时，一个 SqlSession 对象会使用一个 Executor 对象来完成会话操作，MyBatis 的二级缓存机制的关键就是对这个 Executor 对象做文章。如果用户配置了 <code>&quot;cacheEnabled=true&quot;</code>，那么 MyBatis 在为 SqlSession 对象创建 Executor 对象时，会对 Executor 对象加上一个装饰者：<strong>CachingExecutor</strong>，这时 SqlSession 使用 CachingExecutor 对象来完成操作请求。CachingExecutor 对于查询请求，会先判断该查询请求在 namespace 级别的二级缓存中是否有缓存结果，如果有则直接返回缓存结果；如果没有，才会交给真正的 Executor 对象来完成查询操作（该 Executor 对象中还有一个一级缓存），之后 CachingExecutor 会将 Executor 返回的查询结果放置到二级缓存中，然后再返回给调用者。</p>
<h2 id="MyBatis-枚举"><a href="#MyBatis-枚举" class="headerlink" title="MyBatis 枚举"></a>MyBatis 枚举</h2><p><strong>mybatis 的查询流程（类型处理器）</strong><br><img src="/images/mybatis-enum-typehandler.png" alt="mybatis 的类型处理器"></p>
<p>顶层的代理对象就是指我们通过 sqlSession 对象的 getMapper() 方法获取的 mapper 接口对象，因为我们只定义了 mapper 接口，并未定义 mapper 接口的实现，所以这个对象实际上是 mybatis 为我们动态生成的 jdk 代理对象；mybatis 在设置参数的时候，会调用 ParameterHandler 来设置参数，在封装结果集的时候会调用 ResultSetHandler 来处理结果，而 ParameterHandler、ResultSetHandler 内部其实都是调用的 TypeHandler 来处理 java 类型和数据库类型之间的类型转换工作，而 TypeHandler 操作的就是原生 jdbc 代码了（Statement、ResultSet 等 jdbc 对象）。</p>
<p>那么请你思考一下，当我们往数据库中存储一个 java.lang.Enum 枚举对象的时候，mybatis 是如何处理的呢？我们知道 Enum 类型有两个基本属性，一个是 enum.name() 枚举的名字（字面名称），另一个是 enum.ordinal() 枚举的索引（从 0 开始），那 mybatis 是存储的枚举名还是枚举索引呢？答案是：mybatis 默认存储的是枚举的名字，如果需要存储枚举的索引值，则需要在 mybatis-config.xml 中配置 typeHandlers 标签，指定处理枚举类型时要用到的 TypeHandler 类型处理器。</p>
<p>mybatis 默认为我们定义了两个关于枚举类型的 TypeHandler，即 <code>EnumTypeHandler</code>、<code>EnumOrdinalTypeHandler</code>，前者是使用枚举的名字，后者是使用枚举的索引。比如我们现在有一个 UserStatus 枚举类型，需要存储到数据库中，并且我们希望 mybatis 在存储该枚举类型的时候使用 EnumOrdinalTypeHandler 类型处理器，就可以这样配置 mybatis-config.xml：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<typeHandlers>
  <typeHandler handler="org.apache.ibatis.type.EnumOrdinalTypeHandler" javaType="com.zfl9.model.UserStatus"/>
</typeHandlers>
</script></code></pre>
<p>注意，如果不指定 javaType，那么就是所有枚举类型都使用 EnumOrdinalTypeHandler 类型处理器，这可能不是你想要的。</p>
<p>我们来在 employee 表中添加一个字段，就叫做 status，类型就使用 mysql 的 enum 类型：</p>
<pre><code class="language-sql line-numbers"><script type="text/plain">
alter table `employee` add column `status` enum("LOGIN", "LOGOUT", "REMOVE");
</script></code></pre>
<p>在这之前，我们先来复习一下 java 枚举类型的一些知识，枚举是 jdk 1.5 引入的数据类型，目的是为了替代 <code>public static final ...</code> 这样的非类型安全的枚举定义（大多数情况下人们会将这种枚举的数据类型定义为 int），枚举其实是一个继承 java.lang.Enum 的 final 类，而里面定义的枚举常量是一个引用类型，不再是非类型安全的 int 数值，同时我们还可以在定义枚举常量的时候调用当前枚举类的 private、package 构造方法，来传递各自的属性信息，需要注意的是，枚举常量的定义需要放在枚举类的开头，并且格式为 <code>LOGIN, LOGOUT, REMOVE;</code>，枚举常量之间使用逗号分隔，最后以分号结束，当然也可以调用对应的构造器，如 <code>LOGIN(100, &quot;登录&quot;), LOGOUT(200, &quot;登出&quot;), REMOVE(300, &quot;删除&quot;);</code>，这个构造器在当前枚举类中定义，但是它的访问权限需要为 private 或 package，不能为 public、protected。现在我们来定义 EmployeeStatus 枚举类型：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.bean;

public enum EmployeeStatus {
    LOGIN(100, "登录状态"), LOGOUT(200, "登出状态"), REMOVE(300, "移除状态");

    private int code;
    private String mesg;

    EmployeeStatus(int code, String mesg) {
        this.code = code;
        this.mesg = mesg;
    }

    public int getCode() {
        return code;
    }

    public String getMesg() {
        return mesg;
    }

    @Override
    public String toString() {
        return String.format("枚举索引: %d, 枚举名称: %s, 枚举代码: %d, 枚举描述: %s", ordinal(), name(), code, mesg);
    }
}
</script></code></pre>
<p>然后修改 EmployeeMapper.xml，在 insert 标签中添加我们的 status 字段：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<insert id="addEmployee" useGeneratedKeys="true" keyProperty="id">
  insert into employee(name, email, address, telephone, status) values(#{name}, #{email}, #{address}, #{telephone}, #{status})
</insert>
</script></code></pre>
<p>修改我们的测试方法，添加我们的 status 属性：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testAddEmployee() {
    Employee employee = new Employee(null, "Otokaze", "root@zfl9.com", "江西省赣州市", "+86 15307973676", EmployeeStatus.LOGIN);
    int affectedRows = employeeMapper.addEmployee(employee);
    Assert.assertTrue(affectedRows > 0);
    System.out.println(affectedRows);
    System.out.println(employee);
    sqlSession.commit();
}
</script></code></pre>
<p>运行没问题，然后刷新我们的数据库，可以看到存储的就是 LOGIN 字符串：</p>
<pre><code class="language-sql line-numbers"><script type="text/plain">
mysql> select * from employee;
+----+----------+-------------------+--------------------+-----------------+--------+
| id | name     | email             | address            | telephone       | status |
+----+----------+-------------------+--------------------+-----------------+--------+
|  1 | zfl9     | root@zfl9.com     | 江西省赣州市       | 123456          | LOGIN  |
|  2 | baidu    | root@baidu.com    | 北京市海淀区       | 123312          | LOGOUT |
|  3 | google   | root@google.com   | 美利坚合众国       | 122345          | REMOVE |
|  4 | youtube  | root@youtube.com  | 美利坚合众国       | 123124          | LOGOUT |
|  5 | facebook | root@facebook.com | 美利坚合众国       | 123066          | LOGIN  |
|  6 | Otokaze  | root@zfl9.com     | 江西省赣州市       | +86 15307973676 | LOGIN  |
+----+----------+-------------------+--------------------+-----------------+--------+
</script></code></pre>
<p>OK，我们现在来修改 mybatis-config.xml 配置文件，改为存储枚举的索引值：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<typeHandlers>
  <typeHandler handler="org.apache.ibatis.type.EnumOrdinalTypeHandler" javaType="com.zfl9.bean.EmployeeStatus"/>
</typeHandlers>
</script></code></pre>
<p>注意因为我们刚才设置的 status 字段的数据类型为 enum，所以要改为一个 int 类型：</p>
<pre><code class="language-sql line-numbers"><script type="text/plain">
alter table `employee` modify column `status` int;
</script></code></pre>
<p>然后再次运行，看看数据库中的新纪录是什么样子的：</p>
<pre><code class="language-sql line-numbers"><script type="text/plain">
mysql> select * from employee;
+----+----------+-------------------+--------------------+-----------------+--------+
| id | name     | email             | address            | telephone       | status |
+----+----------+-------------------+--------------------+-----------------+--------+
|  1 | zfl9     | root@zfl9.com     | 江西省赣州市       | 123456          |      1 |
|  2 | baidu    | root@baidu.com    | 北京市海淀区       | 123312          |      2 |
|  3 | google   | root@google.com   | 美利坚合众国       | 122345          |      3 |
|  4 | youtube  | root@youtube.com  | 美利坚合众国       | 123124          |      2 |
|  5 | facebook | root@facebook.com | 美利坚合众国       | 123066          |      1 |
|  6 | Otokaze  | root@zfl9.com     | 江西省赣州市       | +86 15307973676 |      1 |
|  7 | Otokaze  | root@zfl9.com     | 江西省赣州市       | +86 15307973676 |      0 |
+----+----------+-------------------+--------------------+-----------------+--------+
</script></code></pre>
<p>注意 id 为 7 的记录，status 为 0，而 0 正好是 EmployeeStatus.LOGIN 的 ordinal 索引值，没问题。</p>
<p><strong>自定义枚举类型的 TypeHandler</strong><br>有些时候我们既不想存储枚举常量的名字也不想存储枚举常量的索引，而是想存储 EmployeeStatus 枚举常量的 code，怎么办呢？简单，我们自己来实现一个 TypeHandler 接口就行了，来看这个接口定义了哪些方法：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
// 类型参数 T 表示用来处理什么 java 类型
public interface TypeHandler<T> {
  // 设置参数是调用的方法
  void setParameter(PreparedStatement ps, int i, T parameter, JdbcType jdbcType) throws SQLException;

  // 封装结果集时调用的方法 (列名)
  T getResult(ResultSet rs, String columnName) throws SQLException;

  // 封装结果集时调用的方法 (列索引)
  T getResult(ResultSet rs, int columnIndex) throws SQLException;

  // 封装结果集时调用的方法 (存储过程)
  T getResult(CallableStatement cs, int columnIndex) throws SQLException;
}
</script></code></pre>
<p>当然 mybatis 也提供了一个 BaseTypeHandler 抽象基类，方便我们实现自定义的类型处理器，这里就直接以实现接口为例：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.bean;

import java.sql.CallableStatement;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import org.apache.ibatis.type.JdbcType;
import org.apache.ibatis.type.TypeHandler;

public class EmployeeStatusTypeHandler implements TypeHandler<EmployeeStatus> {
    @Override
    public void setParameter(PreparedStatement ps, int i, EmployeeStatus parameter, JdbcType jdbcType) throws SQLException {
        ps.setInt(i, parameter.getCode());
    }

    @Override
    public EmployeeStatus getResult(ResultSet rs, String columnName) throws SQLException {
        return EmployeeStatus.getEmployeeStatusByCode(rs.getInt(columnName));
    }

    @Override
    public EmployeeStatus getResult(ResultSet rs, int columnIndex) throws SQLException {
        return EmployeeStatus.getEmployeeStatusByCode(rs.getInt(columnIndex));
    }

    @Override
    public EmployeeStatus getResult(CallableStatement cs, int columnIndex) throws SQLException {
        return EmployeeStatus.getEmployeeStatusByCode(cs.getInt(columnIndex));
    }
}
</script></code></pre>
<p>因为我们在封装结果集的时候需要根据 code 来获取对应的 EmployeeStatus 枚举常量，所以定义一个静态查找方法：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
public static EmployeeStatus getEmployeeStatusByCode(int code) {
    switch (code) {
        case 100:
            return LOGIN;
        case 200:
            return LOGOUT;
        case 300:
            return REMOVE;
        default:
            return null;
    }
}
</script></code></pre>
<p>现在我们修改 mybatis-config.xml，将 EmployeeStatus 的类型处理器改为我们自己的类型处理器：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<typeHandlers>
  <typeHandler handler="com.zfl9.bean.EmployeeStatusTypeHandler" javaType="com.zfl9.bean.EmployeeStatus"/>
</typeHandlers>
</script></code></pre>
<p>现在我们再来添加一个员工，看看存储的是什么东西：</p>
<pre><code class="language-sql line-numbers"><script type="text/plain">
mysql> select * from employee;
+----+----------+-------------------+--------------------+-----------------+--------+
| id | name     | email             | address            | telephone       | status |
+----+----------+-------------------+--------------------+-----------------+--------+
|  1 | zfl9     | root@zfl9.com     | 江西省赣州市       | 123456          |      1 |
|  2 | baidu    | root@baidu.com    | 北京市海淀区       | 123312          |      2 |
|  3 | google   | root@google.com   | 美利坚合众国       | 122345          |      3 |
|  4 | youtube  | root@youtube.com  | 美利坚合众国       | 123124          |      2 |
|  5 | facebook | root@facebook.com | 美利坚合众国       | 123066          |      1 |
|  6 | Otokaze  | root@zfl9.com     | 江西省赣州市       | +86 15307973676 |      1 |
|  7 | Otokaze  | root@zfl9.com     | 江西省赣州市       | +86 15307973676 |      0 |
|  8 | Otokaze  | root@zfl9.com     | 江西省赣州市       | +86 15307973676 |      0 |
|  9 | Otokaze  | root@zfl9.com     | 江西省赣州市       | +86 15307973676 |    100 |
+----+----------+-------------------+--------------------+-----------------+--------+
</script></code></pre>
<p>可以看到存储的是 EmployeeStatus.LOGIN 的 code 状态码，100，那么我们来调用查询方法，看看：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetEmployeeById() {
    Employee employee = employeeMapper.getEmployeeById(9);
    Assert.assertNotNull(employee);
    System.out.println(employee.getStatus());
}
</script></code></pre>
<p>没问题，获取出来的就是 200 状态码对应的 EmployeeStatus.LOGIN，说明我们定义的类型处理器生效了。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
2019-01-13 13:40:02.963 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==>  Preparing: select * from employee where id = ?
2019-01-13 13:40:03.026 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==> Parameters: 9(Integer)
2019-01-13 13:40:03.050 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==    Columns: id, name, email, address, telephone, status
2019-01-13 13:40:03.050 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==        Row: 9, Otokaze, root@zfl9.com, 江西省赣州市, +86 15307973676, 100
2019-01-13 13:40:03.053 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==      Total: 1
枚举索引: 0, 枚举名称: LOGIN, 枚举代码: 100, 枚举描述: 登录状态
</script></code></pre>
<h2 id="MyBatis-插件"><a href="#MyBatis-插件" class="headerlink" title="MyBatis 插件"></a>MyBatis 插件</h2><p>MyBatis 插件又称拦截器，下文中出现的拦截器都表示插件，MyBatis 采用责任链模式，通过动态代理组织多个插件（拦截器），通过这些插件可以改变 MyBatis 的默认行为（如流行的 PageHelper 分页插件），由于插件会深入到 MyBatis 的核心，因此在编写自己的插件前最好了解下它的原理，以便写出安全高效的插件。</p>
<p>MyBatis 允许你在已映射语句执行过程中的某一点进行拦截调用。默认情况下，MyBatis 允许使用插件来拦截的方法调用包括：</p>
<ul>
<li><code>Executor</code>：(update, query, flushStatements, commit, rollback, getTransaction, close, isClosed)</li>
<li><code>ParameterHandler</code>：(getParameterObject, setParameters)</li>
<li><code>ResultSetHandler</code>：(handleResultSets, handleOutputParameters)</li>
<li><code>StatementHandler</code>：(prepare, parameterize, batch, update, query)</li>
</ul>
<p>总体概括为：</p>
<ul>
<li>拦截执行器的方法</li>
<li>拦截参数的处理</li>
<li>拦截结果集的处理</li>
<li>拦截 sql 语句的处理</li>
</ul>
<p>mybatis 的插件机制能够拦截 mybatis 的四大核心对象（也就上面列出来的四个接口的实现类），所以如果需要编写自己的插件，或者希望自己对插件机制能够有比较深刻的了解，就需要先来了解 mybatis 的四大核心对象。<br><img src="/images/mybatis-yuanli.png" alt="mybatis 的四大对象，运行原理"><br>上图 MyBatis 框架的整个执行过程。MyBatis 插件能够对则四大对象进行拦截，可以包含到了 MyBatis 一次会话的所有操作。可见插件之强大。</p>
<ul>
<li>SqlSession 是 MyBatis 对外提供的一个门面接口，SqlSession 内部调用的实际上是 Executor。</li>
<li>Executor 是 MyBatis 的内部执行器，负责调用 StatementHandler 操作数据库，同时还处理二级缓存。</li>
<li>StatementHandler 是 MyBatis 语句执行对象，即原生 JDBC API 的封装，另外它也实现了 MyBatis 的一级缓存。</li>
<li>ParameterHandler 是 MyBatis 实现 Sql 入参设置的对象。插件可以改变我们 Sql 的参数默认设置，如动态的改变传入的参数。</li>
<li>ResultSetHandler 是 MyBatis 把 ResultSet 集合映射成 POJO 的接口对象。我们可以定义插件对 MyBatis 的结果集自动映射进行修改。</li>
</ul>
<blockquote>
<p>StatementHandler 会调用 ParameterHandler 来处理 SQL 预编译参数，然后在查询数据库之后会调用 ResultSetHandler 来封装结果集。</p>
</blockquote>
<p>那么 mybatis 插件是如何实现的呢？如果你研究过 mybatis 的源码就会知道，mybatis 的四大对象在创建的时候，并非直接返回给调用者，而是都会在最后调用一下这个方法：<code>interceptorChain.pluginAll(target)</code>，最后才会被返回，那么这个 pluginAll() 方法内部做了什么操作呢？我们来看看：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
public Executor newExecutor(Transaction transaction, ExecutorType executorType) {
   executorType = executorType == null ? defaultExecutorType : executorType;
   executorType = executorType == null ? ExecutorType.SIMPLE : executorType;
   Executor executor;   if (ExecutorType.BATCH == executorType) {
      executor = new BatchExecutor(this, transaction);
   } else if (ExecutorType.REUSE == executorType) {
      executor = new ReuseExecutor(this, transaction);
   } else {
      executor = new SimpleExecutor(this, transaction);
   }   if (cacheEnabled) {
      executor = new CachingExecutor(executor);
   }
   executor = (Executor) interceptorChain.pluginAll(executor);
   return executor;
}

public StatementHandler newStatementHandler(Executor executor, MappedStatement mappedStatement, Object parameterObject, RowBounds rowBounds, ResultHandler resultHandler, BoundSql boundSql) {
   StatementHandler statementHandler = new RoutingStatementHandler(executor, mappedStatement, parameterObject, rowBounds, resultHandler, boundSql);
   statementHandler = (StatementHandler) interceptorChain.pluginAll(statementHandler);
   return statementHandler;
}

public ParameterHandler newParameterHandler(MappedStatement mappedStatement, Object parameterObject, BoundSql boundSql) {
   ParameterHandler parameterHandler = mappedStatement.getLang().createParameterHandler(mappedStatement, parameterObject, boundSql);
   parameterHandler = (ParameterHandler) interceptorChain.pluginAll(parameterHandler);
   return parameterHandler;
}

public ResultSetHandler newResultSetHandler(Executor executor, MappedStatement mappedStatement, RowBounds rowBounds, ParameterHandler parameterHandler, ResultHandler resultHandler, BoundSql boundSql) {
   ResultSetHandler resultSetHandler = new DefaultResultSetHandler(executor, mappedStatement, parameterHandler, resultHandler, boundSql, rowBounds);
   resultSetHandler = (ResultSetHandler) interceptorChain.pluginAll(resultSetHandler);
   return resultSetHandler;
}
</script></code></pre>
<pre><code class="language-java line-numbers"><script type="text/plain">
public Object pluginAll(Object target) {
    for (Interceptor interceptor : interceptors) {
        target = interceptor.plugin(target);
    }
    return target;
}
</script></code></pre>
<p>pluginAll() 方法内部会获取所有的 Interceptor 拦截器，Interceptor 是一个接口，这里获取的当然是 Interceptor 接口的实例，而一个实现了 Interceptor 接口的对象就是所谓的 mybatis 插件，mybatis 会遍历所有的拦截器，分别调用它们的 plugin() 方法来包装我们的四大对象，最后返回包装后的对象；那么我们来看看 interceptor.plugin() 方法内部又做了什么操作，由于调用的是接口定义的方法，所以来看一下 Interceptor 接口的声明：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
public interface Interceptor {
  Object plugin(Object target);
  void setProperties(Properties properties);
  Object intercept(Invocation invocation) throws Throwable;
}
</script></code></pre>
<ul>
<li>plugin() 方法用来包装目标对象，官方示例为 <code>return Plugin.wrap(target, this)</code>，即创建目标对象的代理对象；</li>
<li>setProperties() 方法则用来获取在 mybatis-config.xml 全局配置文件中传递给 plugin 的 property 参数；</li>
<li>intercept() 方法则是我们的插件方法，在里面可以拦截目标方法的执行，做一些 AOP 操作。</li>
</ul>
<p>mybatis 插件和 Spring AOP 很像，都是创建目标对象的代理对象，然后做一些 Before、After 增强；来看看 Plugin.wrap(target, this) 方法：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
public static Object wrap(Object target, Interceptor interceptor) {
   // 获取插件上面的 @Intercepts 注解（即该插件将拦截哪些对象的哪些方法）
   Map<Class<?>, Set<Method>> signatureMap = getSignatureMap(interceptor);
   Class<?> type = target.getClass();
   Class<?>[] interfaces = getAllInterfaces(type, signatureMap);
   // 如果当前插件并未声明对当前目标对象的任何方法进行拦截，则放行
   if (interfaces.length > 0) {
      return Proxy.newProxyInstance(type.getClassLoader(), interfaces, new Plugin(target, interceptor, signatureMap));
   }
   return target;
}
</script></code></pre>
<p>如果插件没有声明要拦截当前目标对象的方法，则不会创建它的代理，这样可以避免不必要的开销，因为每个对象创建都会调用 pluginAll() 方法。</p>
<p><strong>插件配置注解 <code>@Intercepts</code></strong><br>MyBatis 的每个插件都必须使用 <code>@Intercepts</code> 注解来指定要拦截哪个对象的哪个方法。来看一下这个注解的声明：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({ElementType.TYPE})
public @interface Intercepts {
    Signature[] value();
}
</script></code></pre>
<p>只有一个 value 属性，类型为 Signature[] 数组，Signature 其实就是要拦截的目标方法的具体签名，声明如下：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Documented
@Retention(RetentionPolicy.RUNTIME)
@Target({})
public @interface Signature {
    Class<?> type(); // 要拦截的目标对象
    String method(); // 要拦截的目标方法名
    Class<?>[] args(); // 目标方法的参数列表
}
</script></code></pre>
<p>官方推荐的插件开发例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Intercepts(@Signature(type = Executor.class, method = "query", args = {MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class}))
public class TestInterceptor implements Interceptor {
   @Override
   public Object intercept(Invocation invocation) throws Throwable {
     Object target = invocation.getTarget(); // 目标对象的引用
     Method method = invocation.getMethod(); // 目标对象的方法
     Object[] args = invocation.getArgs();   // 目标方法的参数
     // do something ...... 方法拦截前执行代码块
     Object result = invocation.proceed();
     // do something ...... 方法拦截后执行代码块
     return result;
   }

   @Override
   public Object plugin(Object target) {
     return Plugin.wrap(target, this);
   }

   @Override
   public void setProperties(Properties properties) {
       // TODO
   }
}
</script></code></pre>
<p><strong>注册插件到 mybatis-config.xml 全局配置文件中</strong><br>当你写好一个 Interceptor 实现类（插件），并使用 <code>@Intercepts</code> 注解插件要拦截的目标方法之后，MyBatis 是不知道你有这个插件的，你必须将这个插件注册到 mybatis-config.xml 全局配置文件中，告诉 mybatis 我有一个插件，如下，其中 plugin 元素的 interceptor 属性指定的是插件的全类名，而里面的 property 则是传递给插件的属性（当然这个 property 标签是可选的，这里仅仅是告诉你可以这样传递相关的属性给对应的插件）：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<plugins>
  <plugin interceptor="org.mybatis.example.ExamplePlugin">
    <property name="someProperty" value="100"/>
  </plugin>
</plugins>
</script></code></pre>
<p>那么如果我们同时注册了多个插件，它们都拦截同一个方法，执行顺序是如何的呢？我们来测试一下，编写两个简单的插件：</p>
<p>MyFirstPlugin.java</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.plugin;

import java.sql.PreparedStatement;
import java.util.Properties;
import org.apache.ibatis.executor.parameter.ParameterHandler;
import org.apache.ibatis.plugin.Interceptor;
import org.apache.ibatis.plugin.Intercepts;
import org.apache.ibatis.plugin.Invocation;
import org.apache.ibatis.plugin.Plugin;
import org.apache.ibatis.plugin.Signature;

@Intercepts(@Signature(type = ParameterHandler.class, method = "setParameters", args = PreparedStatement.class))
public class MyFirstPlugin implements Interceptor {
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        System.out.println("MyFirstPlugin...before: " + invocation.getTarget().getClass());
        Object result = invocation.proceed();
        System.out.println("MyFirstPlugin...after: " + invocation.getTarget().getClass());
        return result;
    }

    @Override
    public Object plugin(Object o) {
        System.out.println("MyFirstPlugin...plugin: " + o.getClass());
        return Plugin.wrap(o, this);
    }

    @Override
    public void setProperties(Properties properties) {
        System.out.println("MyFirstPlugin...properties: " + properties);
    }
}
</script></code></pre>
<p>MySecondPlugin.java</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
package com.zfl9.plugin;

import java.sql.PreparedStatement;
import java.util.Properties;
import org.apache.ibatis.executor.parameter.ParameterHandler;
import org.apache.ibatis.plugin.Interceptor;
import org.apache.ibatis.plugin.Intercepts;
import org.apache.ibatis.plugin.Invocation;
import org.apache.ibatis.plugin.Plugin;
import org.apache.ibatis.plugin.Signature;

@Intercepts(@Signature(type = ParameterHandler.class, method = "setParameters", args = PreparedStatement.class))
public class MySecondPlugin implements Interceptor {
    @Override
    public Object intercept(Invocation invocation) throws Throwable {
        System.out.println("MySecondPlugin...before: " + invocation.getTarget().getClass());
        Object result = invocation.proceed();
        System.out.println("MySecondPlugin...after: " + invocation.getTarget().getClass());
        return result;
    }

    @Override
    public Object plugin(Object o) {
        System.out.println("MySecondPlugin...plugin: " + o.getClass());
        return Plugin.wrap(o, this);
    }

    @Override
    public void setProperties(Properties properties) {
        System.out.println("MySecondPlugin...properties: " + properties);
    }
}
</script></code></pre>
<p>然后在 mybatis 全局配置文件中注册这两个插件：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<plugins>
  <plugin interceptor="com.zfl9.plugin.MyFirstPlugin">
    <property name="插件名称" value="我的第一个插件"/>
  </plugin>
  <plugin interceptor="com.zfl9.plugin.MySecondPlugin">
    <property name="插件名称" value="我的第二个插件"/>
  </plugin>
</plugins>
</script></code></pre>
<p>然后调用测试类中的 testGetEmployeeById() 方法：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetEmployeeById() {
    Employee employee = employeeMapper.getEmployeeById(1);
    Assert.assertNotNull(employee);
    System.out.println(employee);
}
</script></code></pre>
<p>执行结果如下：</p>
<pre><code class="language-none line-numbers"><script type="text/plain">
MyFirstPlugin...properties: {插件名称=我的第一个插件}
MySecondPlugin...properties: {插件名称=我的第二个插件}
MyFirstPlugin...plugin: class org.apache.ibatis.executor.CachingExecutor
MySecondPlugin...plugin: class org.apache.ibatis.executor.CachingExecutor
MyFirstPlugin...plugin: class org.apache.ibatis.scripting.defaults.DefaultParameterHandler
MySecondPlugin...plugin: class com.sun.proxy.$Proxy13
MyFirstPlugin...plugin: class org.apache.ibatis.executor.resultset.DefaultResultSetHandler
MySecondPlugin...plugin: class org.apache.ibatis.executor.resultset.DefaultResultSetHandler
MyFirstPlugin...plugin: class org.apache.ibatis.executor.statement.RoutingStatementHandler
MySecondPlugin...plugin: class org.apache.ibatis.executor.statement.RoutingStatementHandler
2019-01-14 14:36:04.291 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==>  Preparing: select * from employee where id = ?
MySecondPlugin...before: class com.sun.proxy.$Proxy13
MyFirstPlugin...before: class org.apache.ibatis.scripting.defaults.DefaultParameterHandler
MyFirstPlugin...after: class org.apache.ibatis.scripting.defaults.DefaultParameterHandler
MySecondPlugin...after: class com.sun.proxy.$Proxy13
2019-01-14 14:36:04.349 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==> Parameters: 1(Integer)
2019-01-14 14:36:04.365 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==    Columns: id, name, email, address, telephone
2019-01-14 14:36:04.365 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==        Row: 1, zfl9, root@zfl9.com, 江西省赣州市, 123456
2019-01-14 14:36:04.368 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==      Total: 1
Employee [ id = 1, name = zfl9, email = root@zfl9.com, address = 江西省赣州市, telephone = 123456 ]
</script></code></pre>
<p>可以看到，mybatis 会按照插件声明的顺序，实例化插件对象，然后在创建四大对象的时候，也是按照声明的顺序依次调用插件的 plugin() 方法来进行包装，即先调用 MyFirstPlugin、再调用 MySecondPlugin 的 plugin 方法，因为这两个插件都是拦截的同一个对象的同一个方法，而又因为是 MyFirstPlugin 先包装，MySecondPlugin 后包装，所以最外层的是 MySecondPlugin 插件，中间的是 MyFirstPlugin 插件，最内部才是真正的目标方法，从最后打印的日志中也能看的出来，这个有点类似 Java EE 中的 Filter 执行顺序。</p>
<p>现在我们来在 MyFirstPlugin 插件中做一些有意义的事，比如动态的修改调用者传入进来的查询参数，比如上面查询的是 1 号员工，我们来将其动态的替换为 2 号员工（一个简单的偷梁换柱，将查询 ID 加一），如下：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Override
public Object intercept(Invocation invocation) throws Throwable {
    System.out.println("MyFirstPlugin...before: " + invocation.getTarget().getClass());

    MetaObject metaObject = SystemMetaObject.forObject(invocation.getTarget());
    System.out.println("当前传递过来的查询参数为：" + metaObject.getValue("parameterObject"));
    metaObject.setValue("parameterObject", (Integer)metaObject.getValue("parameterObject") + 1);
    System.out.println("但是实际使用的查询参数为：" + metaObject.getValue("parameterObject"));

    Object result = invocation.proceed();
    System.out.println("MyFirstPlugin...after: " + invocation.getTarget().getClass());
    return result;
}
</script></code></pre>
<p>然后再次执行 testGetEmployeeById() 测试方法，输出如下：</p>
<pre><code class="language-none line-numbers"><script type="text/plain">
MyFirstPlugin...properties: {插件名称=我的第一个插件}
MySecondPlugin...properties: {插件名称=我的第二个插件}
MyFirstPlugin...plugin: class org.apache.ibatis.executor.CachingExecutor
MySecondPlugin...plugin: class org.apache.ibatis.executor.CachingExecutor
MyFirstPlugin...plugin: class org.apache.ibatis.scripting.defaults.DefaultParameterHandler
MySecondPlugin...plugin: class com.sun.proxy.$Proxy13
MyFirstPlugin...plugin: class org.apache.ibatis.executor.resultset.DefaultResultSetHandler
MySecondPlugin...plugin: class org.apache.ibatis.executor.resultset.DefaultResultSetHandler
MyFirstPlugin...plugin: class org.apache.ibatis.executor.statement.RoutingStatementHandler
MySecondPlugin...plugin: class org.apache.ibatis.executor.statement.RoutingStatementHandler
2019-01-14 14:51:38.111 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==>  Preparing: select * from employee where id = ?
MySecondPlugin...before: class com.sun.proxy.$Proxy13
MyFirstPlugin...before: class org.apache.ibatis.scripting.defaults.DefaultParameterHandler
当前传递过来的查询参数为：1
但是实际使用的查询参数为：2
MyFirstPlugin...after: class org.apache.ibatis.scripting.defaults.DefaultParameterHandler
MySecondPlugin...after: class com.sun.proxy.$Proxy13
2019-01-14 14:51:38.152 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - ==> Parameters: 2(Integer)
2019-01-14 14:51:38.192 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==    Columns: id, name, email, address, telephone
2019-01-14 14:51:38.192 [TRACE] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==        Row: 2, baidu, root@baidu.com, 北京市海淀区, 123312
2019-01-14 14:51:38.199 [DEBUG] com.zfl9.mapper.EmployeeMapper.getEmployeeById - <==      Total: 1
Employee [ id = 2, name = baidu, email = root@baidu.com, address = 北京市海淀区, telephone = 123312 ]
</script></code></pre>
<p>可以看到，虽然我们传递给 Mapper 对象的查询参数为 1，但是实际上向数据库查询的 Id 却是 2，说明插件正常生效。</p>
<p><strong>MyBatis 中一个流行的分页插件，PageHelper</strong><br>配置 pom.xml，引入 PageHelper 插件的依赖：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<dependency>
    <groupId>com.github.pagehelper</groupId>
    <artifactId>pagehelper</artifactId>
    <version>5.1.8</version>
</dependency>
</script></code></pre>
<p>然后配置 mybatis-config.xml，注册分页插件：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<plugins>
  <plugin interceptor="com.github.pagehelper.PageInterceptor"/>
</plugins>
</script></code></pre>
<p>PageHelper 的 github 主页：<a href="https://github.com/pagehelper/Mybatis-PageHelper" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/pagehelper/Mybatis-PageHelper</a><br>PageHelper 的中文文档：<a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/pagehelper/Mybatis-PageHelper/blob/master/README_zh.md</a><br>PageHelper 的使用方法：<a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/HowToUse.md</a><br>PageHelper 的重要提示：<a href="https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/Important.md" rel="external nofollow noopener noreferrer" target="_blank">https://github.com/pagehelper/Mybatis-PageHelper/blob/master/wikis/zh/Important.md</a></p>
<blockquote>
<p>只要你可以保证在 PageHelper 方法调用后紧跟 MyBatis 查询方法，这就是安全的（内部使用了 ThreadLocal，所以是线程安全的）。</p>
</blockquote>
<p>PageHelper 的 startPage()、offsetPage() 方法仅对它后面的第一个 mybatis 查询方法生效，所以如果需要多次分页，请多次调用这些方法。</p>
<p><strong>PageHelper 的基本用法</strong>：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
// 每页记录数为 10，当前查询第 1 页（页数从 1 开始）
PageHelper.startPage(1, 10);
List<Country> list = countryMapper.selectIf(1);

// 第一个参数为 offset，第二个参数为 limit（length）
// 所以该分页的意思就是查询从第 0 条开始的 10 条记录
PageHelper.offsetPage(0, 10);
List<Country> list = countryMapper.selectIf(1);
</script></code></pre>
<p>注意，PageHelper 查询出来的结果对象其实是 <code>Page&lt;E&gt;</code> 类型，看文档可知，Page 是 ArrayList 的子类，所以可以将其赋值给 <code>List&lt;Country&gt;</code> 类型。<br>PageHelper 返回的 Page 对象中封装了一些分页相关的信息，比如当前的页码，总共有多少页，每页有多少条记录（即页面大小）等，我们来测试一下：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetAllEmployees() {
    PageHelper.startPage(1, 2);
    List<Employee> employees = employeeMapper.getAllEmployees();
    for (Employee employee : employees) {
        System.out.println(employee);
    }
    Page<Employee> page = (Page<Employee>) employees;
    System.out.println("当前页码：" + page.getPageNum());
    System.out.println("页面大小：" + page.getPageSize());
    System.out.println("总页面数：" + page.getPages());
    System.out.println("总记录数：" + page.getTotal());
}
</script></code></pre>
<p>输出结果：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
2019-01-14 19:52:24.199 [DEBUG] com.zfl9.mapper.EmployeeMapper.getAllEmployees_COUNT - ==>  Preparing: SELECT count(0) FROM employee
2019-01-14 19:52:24.245 [DEBUG] com.zfl9.mapper.EmployeeMapper.getAllEmployees_COUNT - ==> Parameters:
2019-01-14 19:52:24.262 [TRACE] com.zfl9.mapper.EmployeeMapper.getAllEmployees_COUNT - <==    Columns: count(0)
2019-01-14 19:52:24.262 [TRACE] com.zfl9.mapper.EmployeeMapper.getAllEmployees_COUNT - <==        Row: 10
2019-01-14 19:52:24.263 [DEBUG] com.zfl9.mapper.EmployeeMapper.getAllEmployees_COUNT - <==      Total: 1
2019-01-14 19:52:24.268 [DEBUG] com.zfl9.mapper.EmployeeMapper.getAllEmployees - ==>  Preparing: select * from employee LIMIT ?
2019-01-14 19:52:24.269 [DEBUG] com.zfl9.mapper.EmployeeMapper.getAllEmployees - ==> Parameters: 2(Integer)
2019-01-14 19:52:24.270 [TRACE] com.zfl9.mapper.EmployeeMapper.getAllEmployees - <==    Columns: id, name, email, address, telephone
2019-01-14 19:52:24.270 [TRACE] com.zfl9.mapper.EmployeeMapper.getAllEmployees - <==        Row: 1, zfl9, root@zfl9.com, 江西省赣州市, 123456
2019-01-14 19:52:24.272 [TRACE] com.zfl9.mapper.EmployeeMapper.getAllEmployees - <==        Row: 2, baidu, root@baidu.com, 北京市海淀区, 123312
2019-01-14 19:52:24.272 [DEBUG] com.zfl9.mapper.EmployeeMapper.getAllEmployees - <==      Total: 2
Employee [ id = 1, name = zfl9, email = root@zfl9.com, address = 江西省赣州市, telephone = 123456 ]
Employee [ id = 2, name = baidu, email = root@baidu.com, address = 北京市海淀区, telephone = 123312 ]
当前页码：1
页面大小：2
总页面数：5
总记录数：10
</script></code></pre>
<p>当然也可以将 Page 结果对象封装为 PageInfo 对象，PageInfo 对象提供了更多分页相关的信息，如当前是不是第一页，是不是最后一页等：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetAllEmployees() {
    PageHelper.startPage(1, 2);
    List<Employee> employees = employeeMapper.getAllEmployees();
    for (Employee employee : employees) {
        System.out.println(employee);
    }
    Page<Employee> page = (Page<Employee>) employees;
    System.out.println("当前页码：" + page.getPageNum());
    System.out.println("页面大小：" + page.getPageSize());
    System.out.println("总页面数：" + page.getPages());
    System.out.println("总记录数：" + page.getTotal());
    PageInfo<Employee> pageInfo = new PageInfo<>(page);
    System.out.println("是否为第一页：" + pageInfo.isIsFirstPage());
    System.out.println("是否为最后一页：" + pageInfo.isIsLastPage());
}
</script></code></pre>
<p>执行结果：</p>
<pre><code class="language-none line-numbers"><script type="text/plain">
2019-01-14 19:57:08.979 [DEBUG] com.zfl9.mapper.EmployeeMapper.getAllEmployees_COUNT - ==>  Preparing: SELECT count(0) FROM employee
2019-01-14 19:57:09.022 [DEBUG] com.zfl9.mapper.EmployeeMapper.getAllEmployees_COUNT - ==> Parameters:
2019-01-14 19:57:09.039 [TRACE] com.zfl9.mapper.EmployeeMapper.getAllEmployees_COUNT - <==    Columns: count(0)
2019-01-14 19:57:09.039 [TRACE] com.zfl9.mapper.EmployeeMapper.getAllEmployees_COUNT - <==        Row: 10
2019-01-14 19:57:09.040 [DEBUG] com.zfl9.mapper.EmployeeMapper.getAllEmployees_COUNT - <==      Total: 1
2019-01-14 19:57:09.042 [DEBUG] com.zfl9.mapper.EmployeeMapper.getAllEmployees - ==>  Preparing: select * from employee LIMIT ?
2019-01-14 19:57:09.043 [DEBUG] com.zfl9.mapper.EmployeeMapper.getAllEmployees - ==> Parameters: 2(Integer)
2019-01-14 19:57:09.043 [TRACE] com.zfl9.mapper.EmployeeMapper.getAllEmployees - <==    Columns: id, name, email, address, telephone
2019-01-14 19:57:09.043 [TRACE] com.zfl9.mapper.EmployeeMapper.getAllEmployees - <==        Row: 1, zfl9, root@zfl9.com, 江西省赣州市, 123456
2019-01-14 19:57:09.045 [TRACE] com.zfl9.mapper.EmployeeMapper.getAllEmployees - <==        Row: 2, baidu, root@baidu.com, 北京市海淀区, 123312
2019-01-14 19:57:09.045 [DEBUG] com.zfl9.mapper.EmployeeMapper.getAllEmployees - <==      Total: 2
Employee [ id = 1, name = zfl9, email = root@zfl9.com, address = 江西省赣州市, telephone = 123456 ]
Employee [ id = 2, name = baidu, email = root@baidu.com, address = 北京市海淀区, telephone = 123312 ]
当前页码：1
页面大小：2
总页面数：5
总记录数：10
是否为第一页：true
是否为最后一页：false
</script></code></pre>
<h2 id="MyBatis-MBG"><a href="#MyBatis-MBG" class="headerlink" title="MyBatis MBG"></a>MyBatis MBG</h2><p>mybatis mbg 又称为 mybatis 逆向工程，mbg 全称 MyBatis Generator，是 mybatis 官方提供的一个 mybatis 代码生成器，mbg 可以为所有版本的 MyBatis 以及 2.2.0 之后的 iBATIS 生成代码（pojo 类、mapper 接口、mapper 文件）。MBG 用于生成简单的 CRUD（增删改查）代码，所以你仍然需要手写复杂的连接查询、存储过程调用等 sql 代码以及对象代码，但不管怎么说，mbg 的出现极大的减轻了 mybatis 繁杂的初始化工作，对 mybatis 的发展产生了重大影响。</p>
<p>mbg 是根据一个 xml 配置文件来生成 pojo 类、mapper 接口、mapper 文件的，所以我们需要了解 mbg 的配置文件，这是官方给出的例子：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
  PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
  "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
  <!-- 引入外部的 jar/zip 包到 classpath 中 -->
  <classPathEntry location="/Program Files/IBM/SQLLIB/java/db2java.zip"/>

  <!--
    运行上下文，可以有多个，mbg 默认会运行所有的 context，注意 id 需要唯一
    targetRuntime 是目标类型，如：MyBatis3、MyBatis3Simple、MyBatis3DynamicSql
    所谓 targetRuntime 就是生成什么类型的 mybatis 代码，简单的 curd 还是高级的 curd
    MyBatis3 就是高级的 curd 类型，支持动态条件查询，而 MyBatis3Simple 则是简单的 curd
  -->
  <context id="DB2Tables" targetRuntime="MyBatis3">
    <!-- 目标数据库的连接信息，告诉 mbg 生成哪个数据库的代码 -->
    <jdbcConnection
      driverClass="COM.ibm.db2.jdbc.app.DB2Driver"
      connectionURL="jdbc:db2:TEST"
      userId="db2admin"
      password="db2admin"/>

    <!-- 定义与 Java 类型相关的策略，如是否强制使用 BigDecimals -->
    <javaTypeResolver>
      <property name="forceBigDecimals" value="false"/>
    </javaTypeResolver>

    <!-- 定义 javabean/pojo 类的生成策略，如 pojo 类的所在包和存放路径 -->
    <javaModelGenerator targetPackage="test.model" targetProject="\MBGTestProject\src">
      <property name="enableSubPackages" value="true"/>
      <property name="trimStrings" value="true"/>
    </javaModelGenerator>

    <!-- 定义 mapper 文件的生成策略，如 mapper 文件的所在包和存放的路径 -->
    <sqlMapGenerator targetPackage="test.xml" targetProject="\MBGTestProject\src">
      <property name="enableSubPackages" value="true"/>
    </sqlMapGenerator>

    <!-- 定义 mapper 接口的生成策略，如 mapper 接口的所在包和存放的路径 -->
    <javaClientGenerator type="XMLMAPPER" targetPackage="test.dao" targetProject="\MBGTestProject\src">
      <property name="enableSubPackages" value="true"/>
    </javaClientGenerator>

    <!-- 需要分析数据库中的哪些表，可以指定多个 table 元素，以分析多个表 -->
    <table schema="DB2ADMIN" tableName="ALLTYPES" domainObjectName="Customer">
      <property name="useActualColumnNames" value="true"/>
      <generatedKey column="ID" sqlStatement="DB2" identity="true"/>
      <columnOverride column="DATE_FIELD" property="startDate"/>
      <ignoreColumn column="FRED"/>
      <columnOverride column="LONG_VARCHAR_FIELD" jdbcType="VARCHAR"/>
    </table>
  </context>
</generatorConfiguration>
</script></code></pre>
<p>要使用 mybatis generator，需要编辑 pom.xml，导入 mybatis-generator-core 包：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<dependency>
    <groupId>org.mybatis.generator</groupId>
    <artifactId>mybatis-generator-core</artifactId>
    <version>1.3.7</version>
</dependency>
</script></code></pre>
<p>OK，配置还是比较简单的，我们来编写一个 employees 数据表的 mbg 配置文件 <code>generatorConfig.xml</code>：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE generatorConfiguration
    PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"
    "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd">
<generatorConfiguration>
  <properties resource="jdbc.properties"/>

  <context id="mysql_employees" targetRuntime="MyBatis3">
    <jdbcConnection driverClass="${jdbc.driver}"
                    connectionURL="${jdbc.url}"
                    userId="${jdbc.username}"
                    password="${jdbc.password}">
    </jdbcConnection>

    <javaTypeResolver>
      <property name="forceBigDecimals" value="false"/>
    </javaTypeResolver>

    <javaModelGenerator targetPackage="com.zfl9.bean" targetProject="./src/main/java">
      <property name="enableSubPackages" value="true"/>
      <property name="trimStrings" value="true"/>
    </javaModelGenerator>

    <sqlMapGenerator targetPackage="com.zfl9.mapper" targetProject="./src/main/resources">
      <property name="enableSubPackages" value="true"/>
    </sqlMapGenerator>

    <javaClientGenerator type="XMLMAPPER" targetPackage="com.zfl9.mapper" targetProject="./src/main/java">
      <property name="enableSubPackages" value="true"/>
    </javaClientGenerator>

    <table tableName="employees" domainObjectName="Employee"/>
    <table tableName="departments" domainObjectName="Department"/>
  </context>
</generatorConfiguration>
</script></code></pre>
<p>然后编写一个运行方法，使用 Java 代码来生成 mybatis 代码：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void mybatisGeneratorRunner() throws IOException, XMLParserException, InvalidConfigurationException, SQLException, InterruptedException {
    List<String> warnings = new ArrayList<>();
    ConfigurationParser parser = new ConfigurationParser(warnings);
    Configuration config = parser.parseConfiguration(getClass().getResourceAsStream("/generatorConfig.xml"));
    DefaultShellCallback callback = new DefaultShellCallback(true);
    MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings);
    myBatisGenerator.generate(null);
}
</script></code></pre>
<p>然后运行，可以看到对应目录下生成了 pojo 类、mapper 接口、mapper 文件：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
2019-01-15 19:39:20.781 [DEBUG] org.mybatis.generator.logging.LogFactory - Logging initialized using 'org.mybatis.generator.logging.log4j.Log4jLoggingLogFactory@8e24743' adapter.
2019-01-15 19:39:20.783 [DEBUG] org.mybatis.generator.internal.db.DatabaseIntrospector - Retrieving column information for table "employees"
2019-01-15 19:39:20.815 [DEBUG] org.mybatis.generator.internal.db.DatabaseIntrospector - Found column "emp_no", data type 4, in table "employees..employees"
2019-01-15 19:39:20.815 [DEBUG] org.mybatis.generator.internal.db.DatabaseIntrospector - Found column "birth_date", data type 91, in table "employees..employees"
2019-01-15 19:39:20.815 [DEBUG] org.mybatis.generator.internal.db.DatabaseIntrospector - Found column "first_name", data type 12, in table "employees..employees"
2019-01-15 19:39:20.815 [DEBUG] org.mybatis.generator.internal.db.DatabaseIntrospector - Found column "last_name", data type 12, in table "employees..employees"
2019-01-15 19:39:20.815 [DEBUG] org.mybatis.generator.internal.db.DatabaseIntrospector - Found column "gender", data type 1, in table "employees..employees"
2019-01-15 19:39:20.815 [DEBUG] org.mybatis.generator.internal.db.DatabaseIntrospector - Found column "hire_date", data type 91, in table "employees..employees"
2019-01-15 19:39:20.836 [DEBUG] org.mybatis.generator.internal.db.DatabaseIntrospector - Retrieving column information for table "departments"
2019-01-15 19:39:20.846 [DEBUG] org.mybatis.generator.internal.db.DatabaseIntrospector - Found column "dept_no", data type 1, in table "employees..departments"
2019-01-15 19:39:20.846 [DEBUG] org.mybatis.generator.internal.db.DatabaseIntrospector - Found column "dept_name", data type 12, in table "employees..departments"
</script></code></pre>
<p>然后我们来编写几个测试方法，看看生成的 mybatis 代码是否正确：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetAllDepartments() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
        DepartmentMapper mapper = sqlSession.getMapper(DepartmentMapper.class);
        List<Department> departments = mapper.selectByExample(null);
        for (Department department : departments) {
            System.out.println(department);
        }
    } finally {
        sqlSession.close();
    }
}
</script></code></pre>
<p>注意 <code>xxxByExample()</code> 都是所谓的按条件查询，这个 example 就是条件，如果为 null 表示不传递条件，即查询所有：</p>
<pre><code class="language-none line-numbers"><script type="text/plain">
2019-01-15 19:51:17.587 [DEBUG] com.zfl9.mapper.DepartmentMapper.selectByExample - ==>  Preparing: select dept_no, dept_name from departments
2019-01-15 19:51:17.633 [DEBUG] com.zfl9.mapper.DepartmentMapper.selectByExample - ==> Parameters:
2019-01-15 19:51:17.652 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==    Columns: dept_no, dept_name
2019-01-15 19:51:17.652 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d009, Customer Service
2019-01-15 19:51:17.653 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d005, Development
2019-01-15 19:51:17.656 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d002, Finance
2019-01-15 19:51:17.656 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d003, Human Resources
2019-01-15 19:51:17.656 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d001, Marketing
2019-01-15 19:51:17.657 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d004, Production
2019-01-15 19:51:17.657 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d006, Quality Management
2019-01-15 19:51:17.657 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d008, Research
2019-01-15 19:51:17.658 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d007, Sales
2019-01-15 19:51:17.658 [DEBUG] com.zfl9.mapper.DepartmentMapper.selectByExample - <==      Total: 9
com.zfl9.bean.Department@20ce78ec
com.zfl9.bean.Department@393671df
com.zfl9.bean.Department@56620197
com.zfl9.bean.Department@6eda5c9
com.zfl9.bean.Department@55b7a4e0
com.zfl9.bean.Department@5f058f00
com.zfl9.bean.Department@192d43ce
com.zfl9.bean.Department@72057ecf
com.zfl9.bean.Department@1afd44cb
</script></code></pre>
<p>发的 sql 没问题，查询出来的记录也是正确的，但是 mbg 生成的 pojo 类并未重写 toString() 方法，我们自己来添加一个：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Override
public String toString() {
    return String.format("Employee [ empNo = %s, birthDate = %s, firstName = %s, lastName = %s, gender = %s, hireDate = %s]", empNo, birthDate, firstName, lastName, gender, hireDate);
}

@Override
public String toString() {
    return String.format("Department [ deptNo = %s, deptName = %s ]", deptNo, deptName);
}
</script></code></pre>
<p>然后再次编写我们的测试方法，获取全部 Department，以及所有 lastName 以 <code>&#39;Bain%&#39;</code> 开头的 Employee：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetAllDepartments() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
        DepartmentMapper mapper = sqlSession.getMapper(DepartmentMapper.class);
        List<Department> departments = mapper.selectByExample(null);
        for (Department department : departments) {
            System.out.println(department);
        }
    } finally {
        sqlSession.close();
    }
}

@Test
public void testGetSomeEmployees() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
        EmployeeExample example = new EmployeeExample();
        example.createCriteria().andLastNameLike("Bain%");
        List<Employee> employees = mapper.selectByExample(example);
        for (Employee employee : employees) {
            System.out.println(employee);
        }
    } finally {
        sqlSession.close();
    }
}
</script></code></pre>
<p>运行结果如下：</p>
<pre><code class="language-none line-numbers"><script type="text/plain">
2019-01-15 20:07:43.801 [DEBUG] com.zfl9.mapper.DepartmentMapper.selectByExample - ==>  Preparing: select dept_no, dept_name from departments
2019-01-15 20:07:43.854 [DEBUG] com.zfl9.mapper.DepartmentMapper.selectByExample - ==> Parameters:
2019-01-15 20:07:43.876 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==    Columns: dept_no, dept_name
2019-01-15 20:07:43.876 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d009, Customer Service
2019-01-15 20:07:43.878 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d005, Development
2019-01-15 20:07:43.879 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d002, Finance
2019-01-15 20:07:43.879 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d003, Human Resources
2019-01-15 20:07:43.879 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d001, Marketing
2019-01-15 20:07:43.879 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d004, Production
2019-01-15 20:07:43.880 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d006, Quality Management
2019-01-15 20:07:43.880 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d008, Research
2019-01-15 20:07:43.881 [TRACE] com.zfl9.mapper.DepartmentMapper.selectByExample - <==        Row: d007, Sales
2019-01-15 20:07:43.881 [DEBUG] com.zfl9.mapper.DepartmentMapper.selectByExample - <==      Total: 9
Department [ deptNo = d009, deptName = Customer Service ]
Department [ deptNo = d005, deptName = Development ]
Department [ deptNo = d002, deptName = Finance ]
Department [ deptNo = d003, deptName = Human Resources ]
Department [ deptNo = d001, deptName = Marketing ]
Department [ deptNo = d004, deptName = Production ]
Department [ deptNo = d006, deptName = Quality Management ]
Department [ deptNo = d008, deptName = Research ]
Department [ deptNo = d007, deptName = Sales ]
</script></code></pre>
<pre><code class="language-none line-numbers"><script type="text/plain">
2019-01-15 20:10:44.643 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - ==>  Preparing: select emp_no, birth_date, first_name, last_name, gender, hire_date from employees WHERE ( last_name like ? )
2019-01-15 20:10:44.673 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - ==> Parameters: Bain%(String)
2019-01-15 20:10:44.860 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==    Columns: emp_no, birth_date, first_name, last_name, gender, hire_date
2019-01-15 20:10:44.860 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 10332, 1961-11-05, Masanao, Bain, F, 1988-06-08
2019-01-15 20:10:44.863 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 16128, 1964-05-17, Guenter, Bain, F, 1994-07-13
2019-01-15 20:10:44.864 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 16509, 1956-02-04, Girolamo, Bain, F, 1989-03-05
2019-01-15 20:10:44.865 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 16722, 1963-12-06, Torsten, Bain, M, 1994-08-29
2019-01-15 20:10:44.866 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 17720, 1959-05-29, Ranga, Bain, F, 1989-11-04
2019-01-15 20:10:44.866 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 17912, 1962-08-30, Maik, Bain, F, 1986-12-02
2019-01-15 20:10:44.867 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 18202, 1955-08-20, Changho, Bain, M, 1990-01-04
...
2019-01-15 20:10:44.950 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - <==      Total: 186
Employee [ empNo = 10332, birthDate = Sun Nov 05 00:00:00 CST 1961, firstName = Masanao, lastName = Bain, gender = F, hireDate = Wed Jun 08 01:00:00 CDT 1988]
Employee [ empNo = 16128, birthDate = Sun May 17 00:00:00 CST 1964, firstName = Guenter, lastName = Bain, gender = F, hireDate = Wed Jul 13 00:00:00 CST 1994]
Employee [ empNo = 16509, birthDate = Sat Feb 04 00:00:00 CST 1956, firstName = Girolamo, lastName = Bain, gender = F, hireDate = Sun Mar 05 00:00:00 CST 1989]
Employee [ empNo = 16722, birthDate = Fri Dec 06 00:00:00 CST 1963, firstName = Torsten, lastName = Bain, gender = M, hireDate = Mon Aug 29 00:00:00 CST 1994]
Employee [ empNo = 17720, birthDate = Fri May 29 00:00:00 CST 1959, firstName = Ranga, lastName = Bain, gender = F, hireDate = Sat Nov 04 00:00:00 CST 1989]
Employee [ empNo = 17912, birthDate = Thu Aug 30 00:00:00 CST 1962, firstName = Maik, lastName = Bain, gender = F, hireDate = Tue Dec 02 00:00:00 CST 1986]
Employee [ empNo = 18202, birthDate = Sat Aug 20 00:00:00 CST 1955, firstName = Changho, lastName = Bain, gender = M, hireDate = Thu Jan 04 00:00:00 CST 1990]
...
</script></code></pre>
<p>发现第二个查询太多记录了，我们来筛选一下，将查询条件改为 <code>where lastName like &#39;Bain%&#39; and firstName like &#39;Go%&#39;</code>：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetSomeEmployees() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
        EmployeeExample example = new EmployeeExample();
        example.createCriteria()
                .andLastNameLike("Bain%")
                .andFirstNameLike("Go%");
        List<Employee> employees = mapper.selectByExample(example);
        for (Employee employee : employees) {
            System.out.println(employee);
        }
    } finally {
        sqlSession.close();
    }
}
</script></code></pre>
<p>注意我们可以链式调用 <code>andXxx()</code> 方法来增加查询条件，然后运行，可以看到这次查出来的记录就比较少了，就一条：</p>
<pre><code class="language-none line-numbers"><script type="text/plain">
2019-01-15 20:16:29.659 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - ==>  Preparing: select emp_no, birth_date, first_name, last_name, gender, hire_date from employees WHERE ( last_name like ? and first_name like ? )
2019-01-15 20:16:29.723 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - ==> Parameters: Bain%(String), Go%(String)
2019-01-15 20:16:29.943 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==    Columns: emp_no, birth_date, first_name, last_name, gender, hire_date
2019-01-15 20:16:29.944 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 101803, 1954-05-13, Goa, Bain, M, 1990-08-02
2019-01-15 20:16:29.946 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - <==      Total: 1
Employee [ empNo = 101803, birthDate = Thu May 13 00:00:00 CST 1954, firstName = Goa, lastName = Bain, gender = M, hireDate = Thu Aug 02 01:00:00 CDT 1990]
</script></code></pre>
<p>那么如果我们想再添加一个 or 查询条件，即 <code>where (...) or (empNo between 10000 and 10003 and gender = &#39;F&#39;)</code>：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetSomeEmployees() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
        EmployeeExample example = new EmployeeExample();
        example.createCriteria()
                .andLastNameLike("Bain%")
                .andFirstNameLike("Go%");
        example.or()
                .andEmpNoBetween(10000, 10003)
                .andGenderEqualTo("F");
        List<Employee> employees = mapper.selectByExample(example);
        for (Employee employee : employees) {
            System.out.println(employee);
        }
    } finally {
        sqlSession.close();
    }
}
</script></code></pre>
<p>运行结果如下，可以看到发的 sql 是没问题的，即 <code>where ( ... ) or ( ... )</code>：</p>
<pre><code class="language-none line-numbers"><script type="text/plain">
2019-01-15 20:25:31.481 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - ==>  Preparing: select emp_no, birth_date, first_name, last_name, gender, hire_date from employees WHERE ( last_name like ? and first_name like ? ) or( emp_no between ? and ? and gender = ? )
2019-01-15 20:25:31.548 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - ==> Parameters: Bain%(String), Go%(String), 10000(Integer), 10003(Integer), F(String)
2019-01-15 20:25:31.732 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==    Columns: emp_no, birth_date, first_name, last_name, gender, hire_date
2019-01-15 20:25:31.732 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 10002, 1964-06-02, Bezalel, Simmel, F, 1985-11-21
2019-01-15 20:25:31.735 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 101803, 1954-05-13, Goa, Bain, M, 1990-08-02
2019-01-15 20:25:31.735 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - <==      Total: 2
Employee [ empNo = 10002, birthDate = Tue Jun 02 00:00:00 CST 1964, firstName = Bezalel, lastName = Simmel, gender = F, hireDate = Thu Nov 21 00:00:00 CST 1985]
Employee [ empNo = 101803, birthDate = Thu May 13 00:00:00 CST 1954, firstName = Goa, lastName = Bain, gender = M, hireDate = Thu Aug 02 01:00:00 CDT 1990]
</script></code></pre>
<p>总结：mybatis generator 虽然能够比较好的生成 mybatis curd 代码，但是貌似并不提供常用的分页功能，如果需要实现分页，需要在 mbg 运行完之后，修改生成的 mapper 接口和 mapper 文件，添加自己的分页逻辑，加上 limit 语句，不建议直接使用 mybatis 提供的分页功能，因为它那个实际是逻辑分页，即从数据库中先查出所有的记录，再调用 jdbc api 进行分页，所以性能不好，最好的方式还是自己使用动态 sql 来添加 limit 语句，实现物理分页，这样性能才是最好的。</p>
<p>更新：PageHelper 插件可以很好的配合 MyBatis Generator 进行分页，例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetSomeEmployees() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
        PageHelper.startPage(1, 10);
        EmployeeExample example = new EmployeeExample();
        example.createCriteria().andLastNameLike("Bain%");
        List<Employee> employees = mapper.selectByExample(example);
        for (Employee employee : employees) {
            System.out.println(employee);
        }
    } finally {
        sqlSession.close();
    }
}
</script></code></pre>
<p>运行结果如下，可以发现正常注入了 limit 语句，查出来的记录也是 10 条，没问题：</p>
<pre><code class="language-none line-numbers"><script type="text/plain">
2019-01-15 20:46:34.999 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample_COUNT - ==>  Preparing: SELECT count(0) FROM employees WHERE (last_name LIKE ?)
2019-01-15 20:46:35.052 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample_COUNT - ==> Parameters: Bain%(String)
2019-01-15 20:46:35.155 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample_COUNT - <==    Columns: count(0)
2019-01-15 20:46:35.155 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample_COUNT - <==        Row: 186
2019-01-15 20:46:35.157 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample_COUNT - <==      Total: 1
2019-01-15 20:46:35.159 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - ==>  Preparing: select emp_no, birth_date, first_name, last_name, gender, hire_date from employees WHERE ( last_name like ? ) LIMIT ?
2019-01-15 20:46:35.160 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - ==> Parameters: Bain%(String), 10(Integer)
2019-01-15 20:46:35.167 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==    Columns: emp_no, birth_date, first_name, last_name, gender, hire_date
2019-01-15 20:46:35.168 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 10332, 1961-11-05, Masanao, Bain, F, 1988-06-08
2019-01-15 20:46:35.169 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 16128, 1964-05-17, Guenter, Bain, F, 1994-07-13
2019-01-15 20:46:35.170 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 16509, 1956-02-04, Girolamo, Bain, F, 1989-03-05
2019-01-15 20:46:35.171 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 16722, 1963-12-06, Torsten, Bain, M, 1994-08-29
2019-01-15 20:46:35.171 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 17720, 1959-05-29, Ranga, Bain, F, 1989-11-04
2019-01-15 20:46:35.172 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 17912, 1962-08-30, Maik, Bain, F, 1986-12-02
2019-01-15 20:46:35.172 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 18202, 1955-08-20, Changho, Bain, M, 1990-01-04
2019-01-15 20:46:35.173 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 18842, 1960-05-07, Susanne, Bain, F, 1986-11-16
2019-01-15 20:46:35.174 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 20379, 1962-06-01, Arve, Bain, M, 1989-11-08
2019-01-15 20:46:35.174 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 23173, 1955-06-11, Ashish, Bain, M, 1993-01-19
2019-01-15 20:46:35.174 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - <==      Total: 10
Employee [ empNo = 10332, birthDate = Sun Nov 05 00:00:00 CST 1961, firstName = Masanao, lastName = Bain, gender = F, hireDate = Wed Jun 08 01:00:00 CDT 1988]
Employee [ empNo = 16128, birthDate = Sun May 17 00:00:00 CST 1964, firstName = Guenter, lastName = Bain, gender = F, hireDate = Wed Jul 13 00:00:00 CST 1994]
Employee [ empNo = 16509, birthDate = Sat Feb 04 00:00:00 CST 1956, firstName = Girolamo, lastName = Bain, gender = F, hireDate = Sun Mar 05 00:00:00 CST 1989]
Employee [ empNo = 16722, birthDate = Fri Dec 06 00:00:00 CST 1963, firstName = Torsten, lastName = Bain, gender = M, hireDate = Mon Aug 29 00:00:00 CST 1994]
Employee [ empNo = 17720, birthDate = Fri May 29 00:00:00 CST 1959, firstName = Ranga, lastName = Bain, gender = F, hireDate = Sat Nov 04 00:00:00 CST 1989]
Employee [ empNo = 17912, birthDate = Thu Aug 30 00:00:00 CST 1962, firstName = Maik, lastName = Bain, gender = F, hireDate = Tue Dec 02 00:00:00 CST 1986]
Employee [ empNo = 18202, birthDate = Sat Aug 20 00:00:00 CST 1955, firstName = Changho, lastName = Bain, gender = M, hireDate = Thu Jan 04 00:00:00 CST 1990]
Employee [ empNo = 18842, birthDate = Sat May 07 00:00:00 CST 1960, firstName = Susanne, lastName = Bain, gender = F, hireDate = Sun Nov 16 00:00:00 CST 1986]
Employee [ empNo = 20379, birthDate = Fri Jun 01 00:00:00 CST 1962, firstName = Arve, lastName = Bain, gender = M, hireDate = Wed Nov 08 00:00:00 CST 1989]
Employee [ empNo = 23173, birthDate = Sat Jun 11 00:00:00 CST 1955, firstName = Ashish, lastName = Bain, gender = M, hireDate = Tue Jan 19 00:00:00 CST 1993]
</script></code></pre>
<p>在实际查询之前，PageHelper 发了一个查询有多少条记录的 sql，<code>select count(0) from employees where ...</code>，那么第二次查询会怎样呢：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">
@Test
public void testGetSomeEmployees() throws IOException {
    SqlSessionFactory sqlSessionFactory = getSqlSessionFactory();
    SqlSession sqlSession = sqlSessionFactory.openSession();
    try {
        EmployeeMapper mapper = sqlSession.getMapper(EmployeeMapper.class);
        // 第一次查询
        PageHelper.startPage(1, 10);
        EmployeeExample example = new EmployeeExample();
        example.createCriteria().andLastNameLike("Bain%");
        List<Employee> employees = mapper.selectByExample(example);
        for (Employee employee : employees) {
            System.out.println(employee);
        }
        // 第二次查询
        PageHelper.startPage(2, 10);
        employees = mapper.selectByExample(example);
        for (Employee employee : employees) {
            System.out.println(employee);
        }
    } finally {
        sqlSession.close();
    }
}
</script></code></pre>
<p>运行结果如下，可以发现 PageHelper 很聪明，第二次查询并没有发送统计记录总数的 sql，而是直接发送带有 limit 子句的查询：</p>
<pre><code class="language-none line-numbers"><script type="text/plain">
2019-01-15 20:51:37.240 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample_COUNT - ==>  Preparing: SELECT count(0) FROM employees WHERE (last_name LIKE ?)
2019-01-15 20:51:37.328 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample_COUNT - ==> Parameters: Bain%(String)
2019-01-15 20:51:37.433 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample_COUNT - <==    Columns: count(0)
2019-01-15 20:51:37.433 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample_COUNT - <==        Row: 186
2019-01-15 20:51:37.434 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample_COUNT - <==      Total: 1
2019-01-15 20:51:37.436 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - ==>  Preparing: select emp_no, birth_date, first_name, last_name, gender, hire_date from employees WHERE ( last_name like ? ) LIMIT ?
2019-01-15 20:51:37.437 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - ==> Parameters: Bain%(String), 10(Integer)
2019-01-15 20:51:37.442 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==    Columns: emp_no, birth_date, first_name, last_name, gender, hire_date
2019-01-15 20:51:37.443 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 10332, 1961-11-05, Masanao, Bain, F, 1988-06-08
2019-01-15 20:51:37.444 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 16128, 1964-05-17, Guenter, Bain, F, 1994-07-13
2019-01-15 20:51:37.445 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 16509, 1956-02-04, Girolamo, Bain, F, 1989-03-05
2019-01-15 20:51:37.446 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 16722, 1963-12-06, Torsten, Bain, M, 1994-08-29
2019-01-15 20:51:37.447 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 17720, 1959-05-29, Ranga, Bain, F, 1989-11-04
2019-01-15 20:51:37.448 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 17912, 1962-08-30, Maik, Bain, F, 1986-12-02
2019-01-15 20:51:37.449 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 18202, 1955-08-20, Changho, Bain, M, 1990-01-04
2019-01-15 20:51:37.449 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 18842, 1960-05-07, Susanne, Bain, F, 1986-11-16
2019-01-15 20:51:37.450 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 20379, 1962-06-01, Arve, Bain, M, 1989-11-08
2019-01-15 20:51:37.451 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 23173, 1955-06-11, Ashish, Bain, M, 1993-01-19
2019-01-15 20:51:37.451 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - <==      Total: 10
Employee [ empNo = 10332, birthDate = Sun Nov 05 00:00:00 CST 1961, firstName = Masanao, lastName = Bain, gender = F, hireDate = Wed Jun 08 01:00:00 CDT 1988]
Employee [ empNo = 16128, birthDate = Sun May 17 00:00:00 CST 1964, firstName = Guenter, lastName = Bain, gender = F, hireDate = Wed Jul 13 00:00:00 CST 1994]
Employee [ empNo = 16509, birthDate = Sat Feb 04 00:00:00 CST 1956, firstName = Girolamo, lastName = Bain, gender = F, hireDate = Sun Mar 05 00:00:00 CST 1989]
Employee [ empNo = 16722, birthDate = Fri Dec 06 00:00:00 CST 1963, firstName = Torsten, lastName = Bain, gender = M, hireDate = Mon Aug 29 00:00:00 CST 1994]
Employee [ empNo = 17720, birthDate = Fri May 29 00:00:00 CST 1959, firstName = Ranga, lastName = Bain, gender = F, hireDate = Sat Nov 04 00:00:00 CST 1989]
Employee [ empNo = 17912, birthDate = Thu Aug 30 00:00:00 CST 1962, firstName = Maik, lastName = Bain, gender = F, hireDate = Tue Dec 02 00:00:00 CST 1986]
Employee [ empNo = 18202, birthDate = Sat Aug 20 00:00:00 CST 1955, firstName = Changho, lastName = Bain, gender = M, hireDate = Thu Jan 04 00:00:00 CST 1990]
Employee [ empNo = 18842, birthDate = Sat May 07 00:00:00 CST 1960, firstName = Susanne, lastName = Bain, gender = F, hireDate = Sun Nov 16 00:00:00 CST 1986]
Employee [ empNo = 20379, birthDate = Fri Jun 01 00:00:00 CST 1962, firstName = Arve, lastName = Bain, gender = M, hireDate = Wed Nov 08 00:00:00 CST 1989]
Employee [ empNo = 23173, birthDate = Sat Jun 11 00:00:00 CST 1955, firstName = Ashish, lastName = Bain, gender = M, hireDate = Tue Jan 19 00:00:00 CST 1993]
2019-01-15 20:51:37.454 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - ==>  Preparing: select emp_no, birth_date, first_name, last_name, gender, hire_date from employees WHERE ( last_name like ? ) LIMIT ?, ?
2019-01-15 20:51:37.454 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - ==> Parameters: Bain%(String), 10(Integer), 10(Integer)
2019-01-15 20:51:37.469 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==    Columns: emp_no, birth_date, first_name, last_name, gender, hire_date
2019-01-15 20:51:37.469 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 23889, 1963-02-02, Shin, Bain, M, 1988-02-17
2019-01-15 20:51:37.470 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 24218, 1962-03-09, Abdelwaheb, Bain, F, 1990-06-27
2019-01-15 20:51:37.470 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 25766, 1963-06-11, Garnet, Bain, F, 1992-09-12
2019-01-15 20:51:37.471 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 28078, 1956-12-14, Chinhyun, Bain, F, 1990-09-25
2019-01-15 20:51:37.472 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 28265, 1962-06-29, Frederique, Bain, F, 1985-03-20
2019-01-15 20:51:37.472 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 28565, 1952-11-18, Rosalie, Bain, F, 1988-09-28
2019-01-15 20:51:37.474 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 31201, 1962-03-04, Brigham, Bain, F, 1993-05-21
2019-01-15 20:51:37.474 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 36154, 1960-11-05, Supot, Bain, M, 1992-09-22
2019-01-15 20:51:37.475 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 42779, 1962-10-23, Rosita, Bain, M, 1987-09-08
2019-01-15 20:51:37.475 [TRACE] com.zfl9.mapper.EmployeeMapper.selectByExample - <==        Row: 46560, 1952-10-07, Tamiya, Bain, F, 1994-11-16
2019-01-15 20:51:37.475 [DEBUG] com.zfl9.mapper.EmployeeMapper.selectByExample - <==      Total: 10
Employee [ empNo = 23889, birthDate = Sat Feb 02 00:00:00 CST 1963, firstName = Shin, lastName = Bain, gender = M, hireDate = Wed Feb 17 00:00:00 CST 1988]
Employee [ empNo = 24218, birthDate = Fri Mar 09 00:00:00 CST 1962, firstName = Abdelwaheb, lastName = Bain, gender = F, hireDate = Wed Jun 27 01:00:00 CDT 1990]
Employee [ empNo = 25766, birthDate = Tue Jun 11 00:00:00 CST 1963, firstName = Garnet, lastName = Bain, gender = F, hireDate = Sat Sep 12 00:00:00 CST 1992]
Employee [ empNo = 28078, birthDate = Fri Dec 14 00:00:00 CST 1956, firstName = Chinhyun, lastName = Bain, gender = F, hireDate = Tue Sep 25 00:00:00 CST 1990]
Employee [ empNo = 28265, birthDate = Fri Jun 29 00:00:00 CST 1962, firstName = Frederique, lastName = Bain, gender = F, hireDate = Wed Mar 20 00:00:00 CST 1985]
Employee [ empNo = 28565, birthDate = Tue Nov 18 00:00:00 CST 1952, firstName = Rosalie, lastName = Bain, gender = F, hireDate = Wed Sep 28 00:00:00 CST 1988]
Employee [ empNo = 31201, birthDate = Sun Mar 04 00:00:00 CST 1962, firstName = Brigham, lastName = Bain, gender = F, hireDate = Fri May 21 00:00:00 CST 1993]
Employee [ empNo = 36154, birthDate = Sat Nov 05 00:00:00 CST 1960, firstName = Supot, lastName = Bain, gender = M, hireDate = Tue Sep 22 00:00:00 CST 1992]
Employee [ empNo = 42779, birthDate = Tue Oct 23 00:00:00 CST 1962, firstName = Rosita, lastName = Bain, gender = M, hireDate = Tue Sep 08 01:00:00 CDT 1987]
Employee [ empNo = 46560, birthDate = Tue Oct 07 00:00:00 CST 1952, firstName = Tamiya, lastName = Bain, gender = F, hireDate = Wed Nov 16 00:00:00 CST 1994]
</script></code></pre>
<p><strong>MBG 插件</strong><br>和 mybatis 一样，mybatis-generator 也支持 plugin 插件，并且 mybatis-generator 官方也提供了好些个插件（内置插件），比如生成 model 类的 toString() 方法，就可以使用 ToStringPlugin 插件；配置 mbg 的插件很简单，只需要在 context 元素的开头添加 plugin 元素，该元素只有一个 type 属性，用来指定插件的全类名，例如这里配置了 4 个比较常用的内置插件：</p>
<pre><code class="language-xml line-numbers"><script type="text/plain">
<plugin type="org.mybatis.generator.plugins.SerializablePlugin"/>
<plugin type="org.mybatis.generator.plugins.EqualsHashCodePlugin"/>
<plugin type="org.mybatis.generator.plugins.ToStringPlugin"/>
<plugin type="org.mybatis.generator.plugins.CaseInsensitiveLikePlugin"/>
</script></code></pre>
    </div>
    <div>
    </div>
    <div>
    </div>
    <div>
    </div>
    <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/java/" rel="tag"># java</a>
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/spring-mybatis.html" rel="next" title="Spring + SpringMVC + MyBatis">
                <i class="fa fa-chevron-left"></i> Spring + SpringMVC + MyBatis
              </a>
          </div>
          <span class="post-nav-divider"></span>
          <div class="post-nav-prev post-nav-item">
              <a href="/spring-el.html" rel="prev" title="Spring 表达式语言">
                Spring 表达式语言 <i class="fa fa-chevron-right"></i>
              </a>
          </div>
        </div>
    </footer>
  </article>
    <div class="post-spread">
    </div>
  </div>
          </div>
  <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer" target="_blank">comments powered by Disqus.</a>
        </noscript>
      </div>
  </div>
        </div>
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>
  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Otokaze">
          <p class="site-author-name" itemprop="name">Otokaze</p>
              <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">170</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
        </nav>
        <div class="links-of-author motion-element">
              <span class="links-of-author-item">
                <a href="https://github.com/zfl9" target="_blank" title="GitHub rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-github"></i>
                  GitHub
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="mailto:zfl9.com@gmail.com" target="_blank" title="Email rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-envelope"></i>
                  Email
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://gitlab.com/zfl9" target="_blank" title="GitLab rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-gitlab"></i>
                  GitLab
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://t.me/Otokaze" target="_blank" title="Telegram rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-telegram"></i>
                  Telegram
                </a>
              </span>
        </div>
      </section>
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#插曲"><span class="nav-number">1.</span> <span class="nav-text">插曲</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#入门"><span class="nav-number">2.</span> <span class="nav-text">入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#CRUD"><span class="nav-number">3.</span> <span class="nav-text">CRUD</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关联查询"><span class="nav-number">4.</span> <span class="nav-text">关联查询</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#执行器类型"><span class="nav-number">5.</span> <span class="nav-text">执行器类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#、-的区别"><span class="nav-number">6.</span> <span class="nav-text">#{}、${} 的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mapper-参数处理"><span class="nav-number">7.</span> <span class="nav-text">mapper 参数处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mapper-返回值相关"><span class="nav-number">8.</span> <span class="nav-text">mapper 返回值相关</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sql-语句的重用"><span class="nav-number">9.</span> <span class="nav-text">sql 语句的重用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#selectKey-的用法"><span class="nav-number">10.</span> <span class="nav-text">selectKey 的用法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#调用函数和存储过程"><span class="nav-number">11.</span> <span class="nav-text">调用函数和存储过程</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多数据库支持"><span class="nav-number">12.</span> <span class="nav-text">多数据库支持</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#sql-语句中的特殊字符"><span class="nav-number">13.</span> <span class="nav-text">sql 语句中的特殊字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#mybatis-日志配置-log4j"><span class="nav-number">14.</span> <span class="nav-text">mybatis 日志配置 log4j</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#动态-SQL"><span class="nav-number">15.</span> <span class="nav-text">动态 SQL</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis-缓存"><span class="nav-number">16.</span> <span class="nav-text">MyBatis 缓存</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis-枚举"><span class="nav-number">17.</span> <span class="nav-text">MyBatis 枚举</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis-插件"><span class="nav-number">18.</span> <span class="nav-text">MyBatis 插件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#MyBatis-MBG"><span class="nav-number">19.</span> <span class="nav-text">MyBatis MBG</span></a></li></ol></div>
          </div>
        </section>
      <!--/noindex-->
    </div>
  </aside>
      </div>
    </main>
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Otokaze</span>
</div>
<script src="/js/clipboard.min.js"></script>
<script src="/js/prism/prism.js" async></script>
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
  </div>
<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>
      <script id="dsq-count-scr" src="https://otokaze.disqus.com/count.js" async></script>
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://www.zfl9.com/mybatis.html';
          this.page.identifier = 'mybatis.html';
          this.page.title = 'MyBatis 笔记';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://otokaze.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("3hhdw6gOg9wavsharVwVjqI3-gzGzoHsz", "O5WfDffqFsgmAVPwNY9of3QU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");
      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });
      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';
          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);
            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);
      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }
    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</body>
</html>
