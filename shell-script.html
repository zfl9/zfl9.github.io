<!doctype html>
<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">
<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">
<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">
  <meta name="keywords" content="shell shell-script shell脚本">
  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1">
<meta name="description" content="Shell - 脚本编程，变量、数组、运算符、echo/printf、流程控制、函数、参数传递、文件包含。">
<meta name="keywords" content="linux,shell">
<meta property="og:type" content="article">
<meta property="og:title" content="Shell - 脚本编程">
<meta property="og:url" content="https://www.zfl9.com/shell-script.html">
<meta property="og:site_name" content="Otokaze's Blog">
<meta property="og:description" content="Shell - 脚本编程，变量、数组、运算符、echo/printf、流程控制、函数、参数传递、文件包含。">
<meta property="og:image" content="https://www.zfl9.com/images/shell-exec-cmd.png">
<meta property="og:updated_time" content="2019-09-01T01:11:00.192Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Shell - 脚本编程">
<meta name="twitter:description" content="Shell - 脚本编程，变量、数组、运算符、echo/printf、流程控制、函数、参数传递、文件包含。">
<meta name="twitter:image" content="https://www.zfl9.com/images/shell-exec-cmd.png">
<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
  <link rel="canonical" href="https://www.zfl9.com/shell-script.html">
<link href="/js/prism/prism.css" rel="stylesheet">
  <title>Shell - 脚本编程 | Otokaze's Blog</title>
</head>
<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-97872912-1', 'auto');
  ga('send', 'pageview');
</script>
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3d58f51dbb2496a0e6d17b85065a5ae5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Otokaze's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">拼一年春夏秋冬，搏一生无怨无悔</h1>
  </div>
  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>
<nav class="site-nav">
    <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            首页
          </a>
        </li>
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            分类
          </a>
        </li>
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            标签
          </a>
        </li>
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            归档
          </a>
        </li>
    </ul>
</nav>
 </div>
    </header>
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
  <div id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.zfl9.com/shell-script.html">
    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Otokaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>
    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Otokaze's Blog">
    </span>
      <header class="post-header">
          <h2 class="post-title" itemprop="name headline">
                Shell - 脚本编程
          </h2>
        <div class="post-meta">
          <span class="post-time">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
                <span class="post-meta-item-text">发表于</span>
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-16T19:18:00+08:00">
                2017-11-16
              </time>
          </span>
            <span class="post-category">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
                <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/" itemprop="url" rel="index">
                    <span itemprop="name">linux</span>
                  </a>
                </span>
                  ， 
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/linux/shell/" itemprop="url" rel="index">
                    <span itemprop="name">shell</span>
                  </a>
                </span>
            </span>
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/shell-script.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="shell-script.html" itemprop="commentCount"></span>
                </a>
              </span>
             <span id="/shell-script.html" class="leancloud_visitors" data-flag-title="Shell - 脚本编程">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
                 <span class="post-meta-item-text">阅读次数 </span>
                 <span class="leancloud-visitors-count"></span>
             </span>
        </div>
      </header>
    <div class="post-body" itemprop="articleBody">
        <p>Shell - 脚本编程，变量、数组、运算符、echo/printf、流程控制、函数、参数传递、文件包含。</p>
<a id="more"></a>
<h2 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h2><p><strong>什么是 shell 脚本</strong>？<br>shell-script 可以理解为 Windows 下的 bat 批处理文件，它们的作用是类似的。<br>shell-script 是通过 shell 解释器来运行的，称为 <strong>解释型语言</strong>，即没有 <strong>编译</strong> 环节。</p>
<p><strong>shell 解释器有哪些</strong>？<br>1) <code>sh</code>(Bourne Shell)：UNIX 最初使用的 shell，而且在每种 UNIX 上都可以使用。<br>Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。</p>
<p>2) <code>bash</code>(Bourne Again Shell)：Linux 默认 shell，它是 Bourne Shell 的扩展。<br>Bourne Again Shell 与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。<br>bash 可以提供命令补全，命令编辑和命令历史等功能，bash 包含了 csh、ksh 的很多优点，以及友好的交互界面。</p>
<p>3) <code>zsh</code>(Z Shell)：是一种 Unix Shell，它可以用作为交互式的登录 shell，也是一种强大的 shell 脚本命令解释器。<br>Zsh 可以认为是一种 Bourne shell 的扩展，带有数量庞大的改进（因此配置比较复杂），包括一些 bash、ksh、tcsh 的功能。</p>
<p><strong>究竟使用哪个 shell</strong>？<br>先给出结论：编写 shell 脚本，建议使用 bash；使用 shell 交互环境，建议使用 bash 或 zsh（推荐）。</p>
<p>在 Linux 中，<code>/bin/sh</code> 通常是一个指向 <code>/bin/bash</code> 的软链接文件，所以在脚本中使用 sh 或 bash 都是调用的同一个程序 /bin/bash。那是不是就可以认为它们完全一样呢？不是，如果使用 /bin/sh，那么 bash 会以 sh 兼容的方式运行（不支持 bash 的特性，如高级重定向）。例子，我想比较本地的 /usr/local/ss-tproxy 与 github 上的 ss-tproxy 的区别，但又不想下载 github 上的文件，就可以使用 bash 的 <code>&lt;(command)</code> 重定向，将 command 的输出作为一个虚拟的文件参数传递给 diff：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ diff /usr/local/bin/ss-tproxy <(curl https://raw.github.com/zfl9/ss-tproxy/v2-master/ss-tproxy)
--- /usr/local/bin/ss-tproxy    2018-07-13 09:15:01.848014646 +0800
+++ /proc/self/fd/11    2018-07-13 09:15:40.470761996 +0800
@@ -1,7 +1,5 @@
 #!/bin/bash

-export PS4='+${BASH_SOURCE}:${LINENO}:${FUNCNAME[0]}: '
-
 main_cfg='/etc/tproxy/ss-tproxy.conf'
 if [ -f $main_cfg ]; then
     source $main_cfg
</script></code></pre>
<p>但是如果使用 /bin/sh 来执行上面的命令，就会提示语法错误。为了提高 shell 脚本的执行性，建议始终使用 /bin/bash。最后说一下 zsh，zsh 基本与 bash 兼容，且提供更强大、更灵活的功能，但是为什么不建议使用 zsh 作为 shell 脚本的解释器呢？因为 zsh 并不是默认的 shell，很多 Linux 上都没有自带 zsh，必须自己安装。为了可移植性，不建议使用 zsh 作为脚本解释器，不过作为 shell 交互环境还是非常不错的，尤其是 oh-my-zsh，不要太爽。</p>
<p><strong>hello world 程序</strong><br>编写和运行 shell 脚本非常简单，只需要一个文本编辑器（推荐 vim）和一个 shell 解释器（推荐 bash）。</p>
<p>hello.sh，扩展名无所谓，见名知意即可。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">#!/bin/bash
echo "Hello World !"
</script></code></pre>
<p>添加可执行权限，然后运行脚本。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~ [20:07:26]
$ chmod +x hello.sh

# root @ arch in ~ [20:07:31]
$ ./hello.sh
Hello, World !
</script></code></pre>
<p>其中，<code>#!/bin/bash</code>是告诉系统，启动什么解释器来运行该脚本，这是一个约定标记，必须位于文件首行！<br>而<code>chmod +x hello.sh</code>则是设置文件的可执行权限，否则在运行<code>./hello.sh</code>的时候会提示没有执行权限。<br>当然，也可以显式的指定解释器来运行脚本，这样的话就不需要执行权限，也不需要首行的约定标记，如：<code>/bin/bash hello.sh</code>。</p>
<p>无论是<code>./hello.sh</code>还是<code>/bin/bash hello.sh</code>，其实都是启动了一个全新的 shell 程序来解释运行脚本语句。<br>除了这种方式，我们也可以直接将让当前 shell 读取脚本内容，并解释执行，使用<code>source</code>命令，如：<code>source hello.sh</code></p>
<p>那么这两种方式有什么区别呢？<br>1) <strong>子进程中运行</strong>，具体启动流程：当前 shell（父进程）首先读取文件首行，然后执行 fork() 系统调用，创建一个子进程，紧接着执行 exec() 系统调用，载入指定的解释器（/bin/bash），然后开始解释运行。这两个 shell 之间是父子进程关系，子 shell 会继承父 shell 的环境变量（env 可查看），但是它们之间是不会互相影响的。</p>
<p>2) <strong>当前进程中运行</strong>，这个就比较简单了，相当于我把一条一条的命令保存到了文件中，然后执行<code>source</code>来载入它，让 shell 来运行，这个和手打来执行命令完全没区别，比较符合”批处理”的概念。正因如此，脚本中的命令可以改变当前 shell 的环境变量、普通变量；任何语句带来的影响都会在当前 shell 中体现出来。</p>
<p><strong><code>#!/bin/env bash</code>和<code>#!/bin/bash</code>区别</strong><br><code>#!/bin/env bash</code>：从<code>$PATH</code>环境变量中查找 bash 命令的位置，并启动它；<br><code>#!/bin/bash</code>，直接根据绝对路径启动 bash 解释器（不存在则报错，然后退出）。</p>
<p>理论来说，前者的移植性更好一些，因为有些系统的 bash 可能不在 /bin 目录（但实际上不必太过担心）。</p>
<p><strong>shell 注释</strong><br>以<code>#</code>号开头的行就是注释，它会被解释器忽略。<br>shell 不支持多行注释，只能在每行前面添加<code>#</code>。</p>
<p>如果需要临时注释一大段代码，过一会又要取消注释，怎么办呢？<br>我们可以利用 function 函数，将这段代码放在函数中，要用的时候调用就行了。</p>
<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p><strong>定义变量</strong><br>和 C/C++、Java 一样，shell 也有变量，并且定义方式大同小异。<br>如：<code>name=Otokaze</code>、<code>name=&#39;Otokaze&#39;</code>、<code>name=&quot;Otokaze&quot;</code>；<br>三种方式都可以，并且不需要指明变量类型，因为它们本质都是字符串。<br>但是，如果变量值存在空白符（如：空格），那么必须使用引号包围起来。<br>使用单双引号其实是有区别的，具体的细节我会在后面进行详细解释。</p>
<p><strong>从标准输入读取</strong><br>除了普通的变量定义方式，我们也可以获取用户的输入，并将其存储在变量中；<br>语法：<code>read var_name</code>，当运行到<code>read</code>所在行时，当前 shell 进程阻塞，等待用户输入；<br>当用户输入完成，并键入回车后，当前进程继续执行，输入的字符串（不包含换行符）将保存至<code>var_name</code>中。</p>
<p><strong>变量命名规则</strong><br>只能以<code>字母</code>或<code>_</code>开头，后面可跟<code>字母</code>、<code>数字</code>、<code>_</code>。</p>
<p><strong>变量初始化</strong><br>在定义变量的时候必须进行赋值（称为：初始化），如 <code>name=&#39;Otokaze&#39;</code>，也可以赋空值：<code>name=&quot;&quot;</code>；<br>其实 shell 允许你直接使用未定义/赋值的变量，未定义变量在字符串上下文中为空串，数值上下文中为 0。</p>
<p><strong>引用变量值</strong><br>定义变量后就可以使用这个变量了，比如我要打印 name 变量的值：<code>echo ${name}</code>或<code>echo $name</code>。<br>这里特别注意，在<strong>引用变量时，必须加上<code>$</code>，并且最好加上<code>{}</code>来标识边界</strong>，这是一个很好的编程习惯！</p>
<p><strong>重新赋值</strong><br>一个变量被定义后，可以被重新赋值，变量名前不用加<code>$</code>。如：<code>name=&quot;Google&quot;</code>。<br>可以这样简单记忆：<strong>写入变量值时，不能加上<code>$</code>；读取变量值时，必须加上<code>$</code></strong>，而定义的时候其实也是写入变量值，不能加<code>$</code>。</p>
<p><strong>只读变量</strong><br>有时候我们想定义一个<strong>常量</strong>，或者叫只读变量，在 C/C++ 中使用关键字<code>const</code>，在 Shell 中使用<code>readonly</code>。<br><code>readonly</code>有两种用法：1) <code>readonly MAX_SIZE=100</code>，直接定义；2) <code>MAX_SIZE=100; readonly MAX_SIZE</code>，将变量设置为只读。<br>任何尝试修改只读变量的操作都会产生：<code>MAX_SIZE: readonly variable</code>错误；并且<strong>只读变量不能被 unset 删除</strong>！</p>
<p><strong>删除变量</strong><br>使用<code>unset</code>命令，可以一次性删除多个变量。如：<code>unset name</code>、<code>unset var_a var_b var_c</code>。<br>但是，对于只读变量，是不可以用 unset 进行删除的，它的生命周期和 shell 进程一样长。</p>
<p><strong>变量类型</strong><br>注意，这里不是指变量存储的值的类型，它们都是字符串，没什么好说的。变量类型有四种：<br>1) <strong>局部变量</strong>，或者称为函数变量，即在函数中使用<code>local</code>关键字定义的变量都是局部变量。<br>局部变量只能在函数内部使用；在函数被调用的时候初始化，在函数返回的时候回收释放。<br>2) <strong>全局变量</strong>，即当前 shell 环境中定义的变量，一般我们定义的变量都是全局的，除非在函数中使用<code>local</code>关键字。<br>注意，在函数中，如果不使用<code>local</code>定义变量，那么它默认就是全局变量！全局变量就相当于 C/C++ 中的静态变量，在 shell 退出的时候才被释放。<br>3) <strong>环境变量</strong>，所有的环境变量都可以使用<code>env</code>命令查看，子进程会继承父进程的环境变量（拷贝一份）。<br>我们可以使用<code>export</code>命令将全局变量导出为环境变量。只读变量也能导出为环境变量，它依旧只读。<br>4) <strong>shell变量</strong>，shell 进程设置的特殊变量，一部分是全局变量，一部分是环境变量，它们的存在都是为了保证 shell 的正常运行。</p>
<p><strong>单双引号区别</strong><br>单引号的特点：<br>1) 单引号中的任何字符都会原样输出，单引号中的变量引用（<code>${}</code>）、命令替换（<code>$()</code>）都是无效的。<br>2) 单引号字符串中不允许出现单引号，就算是使用’\’转义也不行，也就是说单引号必须成对出现！</p>
<p>双引号的特点：<br>1) 可以进行变量引用、命令替换；<br>2) 允许转义字符，可以包含单引号（无需转义），可以包含双引号（需要转义）。</p>
<p>无论是单引号还是双引号，它们都可以用来存储多行字符串（也就是字符串可以跨行）。</p>
<p><strong>获取字符串长度</strong><br>使用<code>＃</code>号，如：<code>url=&quot;www.zfl9.com&quot;; echo ${＃url}</code>，输出 12。</p>
<p><strong>提取子串</strong><br>索引值从 0 开始。如：<br><code>echo ${url:3:5}</code>，输出<code>&quot;.zfl9&quot;</code>，3 表示从索引值 3 开始，5 表示提取 5 个字符；<br><code>echo ${url:3}</code>，输出<code>&quot;.zfl9.com&quot;</code>，如果省略长度，则默认提取剩下的所有字符；<br><code>echo ${url:0-1}</code>，输出<code>&quot;m&quot;</code>，倒数第一个索引为 -1，倒数第二个为 -2，以此类推；<br><code>echo ${url:0-8:4}</code>，输出<code>&quot;zfl9&quot;</code>，0-8 表示索引 -8，4 表示提取 4 个字符长度。</p>
<p><strong>删除子串</strong><br><code>#</code> 或 <code>##</code> 表示从字符串左边匹配子串，然后删除；<code>%</code> 或 <code>%%</code> 表示从字符串右边匹配子串，然后删除。<br>模式中可以使用 glob 通配符，如 <code>?</code>、<code>*</code>、<code>[]</code>、<code>[^]</code>；<code>#</code> 和 <code>%</code> 中的 <code>*</code> 为最短匹配，<code>##</code> 和 <code>%%</code> 中的 <code>*</code> 为最长匹配。</p>
<p><code>echo ${url＃w*.}</code>，最短匹配，输出<code>&quot;zfl9.com&quot;</code>；<br><code>echo ${url＃＃w*.}</code>，最长匹配，输出<code>&quot;com&quot;</code>；</p>
<p><code>echo ${url%.*}</code>，最短匹配，输出<code>&quot;www.zfl9&quot;</code>；<br><code>echo ${url%%.*}</code>，最长匹配，输出<code>&quot;www&quot;</code>。</p>
<p><strong>替换子串</strong><br><code>echo ${url/./*}</code>，仅替换一次，输出<code>&quot;www*zfl9.com&quot;</code>；<br><code>echo ${url//./*}</code>，替换所有匹配的子串，输出<code>&quot;www*zfl9*com&quot;</code>。</p>
<p><strong>查找子串</strong><br>为了查找子串，我们需要借助 expr 命令，具体用法如下：<br><code>expr index $url zfl9</code>，注意 expr 是以 1 开始的，因此输出 5；<br><code>expr index $url google</code>，因为没有匹配的子串，因此输出 0；<br>注意，对于查找的子串<code>&quot;zfl9&quot;</code>或<code>&quot;google&quot;</code>，它是一个一个字符去匹配的；<br>如：<code>expr index $url abcd.</code>，它会将<code>&quot;abcd.&quot;</code>五个字符依次去匹配，因此返回 4。</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>bash 支持一维数组，不支持多维数组。并且没有限定数组的长度。<br>类似的，数组元素的下标以 0 开始编号，获取元素要利用下标，下标可以是整数或算术表达式，其值应大于等于 0。</p>
<p><strong>定义数组</strong><br>1) 直接定义，<code>array=(1 2 3 4 5)</code>，定义数组需要使用<code>()</code>圆括号，每个元素之间用空格隔开。<br>2) 依次赋值，<code>array[0]=1; array[3]=4</code>，数组的下标可以不连续，并且下标的范围没有限制。</p>
<p><strong>访问数组</strong><br><code>echo ${array[0]}</code>，使用给定下标，整数形式；<br><code>echo ${array[1 - 1]}</code>，使用算数表达式，支持<code>+ - * / % **</code>加减乘除、取余、乘方；<br><code>ind=0; echo ${array[ind]}</code>，使用变量，变量值须为大于等于 0 的整数，并且不需要加<code>$</code>。</p>
<p><strong>所有元素</strong><br><code>echo ${array[@]}</code>，获取所有元素；或者<code>echo ${array[*]}</code>也可以。<br><code>@</code>和<code>*</code>是有区别的，<code>@</code>是将每个元素分开传递，<code>*</code>则是一次性传递。<br>当然，一般情况下是体现不出来的；只有在双引号中，才会表现得不一样：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~ [9:38:43]
$ cat test.sh
#!/bin/bash

arr=(1 2 3 4 5)

for i in "${arr[@]}"; do
    echo $i
done

echo "------------"

for i in "${arr[*]}"; do
    echo $i
done

# root @ arch in ~ [9:38:46]
$ ./test.sh
1
2
3
4
5
------------
1 2 3 4 5
</script></code></pre>
<p><strong>数组长度</strong><br>1) <code>echo ${＃arr[@]}</code>；2) <code>echo ${＃arr[*]}</code>；这两种方式都可以，没有什么区别；<br>同时也可以获取单个元素的长度：<code>echo ${＃arr[0]}</code>，和获取字符串长度的方法相同。</p>
<h2 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h2><p>在执行 shell 脚本时，我们可以向 shell 脚本传递命令行参数（位置参数）。<br>获取参数可以通过特殊变量<code>$n</code>，其中 n 为非负整数，<code>$0</code>是当前执行文件名。<br>而我们传递的参数是从序号 1 开始的，<code>$1</code>就是第一个参数，<code>$2</code>就是第二个参数，以此类推。<br>当 n 大于等于 10 时，需要使用<code>${10}</code>来进行引用，这个和引用变量是一样的，用来标识边界。</p>
<p>例子：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">[root@arch ~]# cat ./test.sh
#!/bin/bash
echo "文件名: $0"
num=1
for arg in $@; do
    echo "参数 $[num++]: $arg"
done
[root@arch ~]# ./test.sh www.zfl9.com www.google.com www.baidu.com
文件名: ./test.sh
参数 1: www.zfl9.com
参数 2: www.google.com
参数 3: www.baidu.com
</script></code></pre>
<p>其实上面的例子有几个细节处理的不好，这是重写后的：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
# root @ arch in ~ [18:54:27] 
$ cat test.sh
#!/bin/bash
echo "文件名: $0"
for arg in "$@"; do
    echo "参数 $((++num)): $arg"
done

# root @ arch in ~ [18:54:27] 
$ ./test.sh                          
文件名: ./test.sh

# root @ arch in ~ [18:54:32] 
$ ./test.sh 1 2 3                    
文件名: ./test.sh
参数 1: 1
参数 2: 2
参数 3: 3

# root @ arch in ~ [18:54:34] 
$ ./test.sh zfl9 baidu google 'a b c'
文件名: ./test.sh
参数 1: zfl9
参数 2: baidu
参数 3: google
参数 4: a b c
</script></code></pre>
<p><strong>几个特殊变量</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">变量名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>$0</code></td>
<td style="text-align:center">当前的可执行文件名</td>
</tr>
<tr>
<td style="text-align:center"><code>$n</code></td>
<td style="text-align:center">n 为非负整数，传递的命令行参数</td>
</tr>
<tr>
<td style="text-align:center"><code>$#</code></td>
<td style="text-align:center">命令行参数个数，不包括<code>$0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>$@</code></td>
<td style="text-align:center">获取所有参数，不包括<code>$0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>$*</code></td>
<td style="text-align:center">获取所有参数，不包括<code>$0</code></td>
</tr>
<tr>
<td style="text-align:center"><code>$?</code></td>
<td style="text-align:center">最后一个命令的退出值，0 为无错误，其它值为有错误</td>
</tr>
<tr>
<td style="text-align:center"><code>$$</code></td>
<td style="text-align:center">当前 shell 进程的 PID</td>
</tr>
<tr>
<td style="text-align:center"><code>$!</code></td>
<td style="text-align:center">最后一个后台任务的 PID</td>
</tr>
</tbody>
</table>
<p><strong><code>$@</code>和<code>$*</code>区别</strong><br>其实和前面一节中的数组<code>${arr[@]}</code>、<code>${arr[*]}</code>区别是一样的，在双引号中才有区别：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">[root@arch ~]# cat test.sh
#!/bin/bash
for arg in "$@"; do
    echo $arg
done
echo "--------"
for arg in "$*"; do
    echo $arg
done
[root@arch ~]# ./test.sh 1 2 3 4 5
1
2
3
4
5
--------
1 2 3 4 5
</script></code></pre>
<p><strong>传递参数时加引号和不加引号的区别</strong><br>加引号：shell 会将引号内的字符串作为一个参数进行传递；<br>不加引号：shell 会使用空格进行参数分割，然后传递给命令；</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">$ cat test.sh
#!/bin/bash
echo "参数个数: $#，分别为:"
for i in "$@"; do
    echo $i
done

$ ./test.sh 1 2 3
参数个数: 3，分别为:
1
2
3

$ ./test.sh "1 2 3"
参数个数: 1，分别为:
1 2 3

$ ./test.sh "1 2" 3
参数个数: 2，分别为:
1 2
3
</script></code></pre>
<p><strong>建议</strong>：养成使用双引号、单引号的习惯，这样可以避免很多稀奇古怪的问题！</p>
<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p><strong>算数运算符</strong><br>bash 支持 4 种语法来进行算数运算（只支持整数运算）：<code>let</code>、<code>(())</code>、<code>$(())</code>、<del><code>$[]</code></del>（过时，同 <code>$(())</code>）。<br><code>let</code>、<code>(())</code>、<code>$(())</code> 这 3 个都是内置命令（废话），它们所支持的运算符是一样的，那么它们有什么区别呢？</p>
<ul>
<li><code>let</code>：支持多个算数表达式的计算（单纯计算）</li>
<li><code>(())</code>：只支持单个算数表达式的计算（单纯计算）</li>
<li><code>$(())</code>：只支持单个算数表达式的计算（计算＆结果替换）</li>
</ul>
<p>基本用法：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
## let
# 如果需要在算数表达式中引用变量，请不要在变量名前添加 '$' 美元符
# 建议将运算表达式用引号(单双引号都行)括起来，当作一个参数传递给 let
# 这样的好处是允许在表达式中间存在空白符(空格)，否则不允许空白符的存在

# 加、减、乘、除、取余、乘方
let "result = a + b"
let "result = a - b"
let "result = a * b"
let "result = a / b"
let "result = a % b"
let "result = a ** b"

let "a += b"
let "a -= b"
let "a *= b"
let "a /= b"
let "a %= b"
let "a **= b" # 错误

let "++a"   # 前自增
let "--a"   # 前自减
let "a++"   # 后自增
let "a--"   # 后自减

# 前自增、后自增区别（自减同理）
$ a=10      # 初始化为 10

$ let "ret = ++a"   # 前自增，返回自增后的结果
$ typeset a ret
a=11
ret=11

$ let "ret = a++"   # 后自增，返回自增前的结果
$ typeset a ret
a=12
ret=11

# let 支持同时运算多个表达式
$ a=20; b=10
$ let "r1 = a + b" "r2 = a - b" "r3 = a * b" "r4 = a / b"
$ typeset a b r1 r2 r3 r4
a=20
b=10
r1=30
r2=10
r3=200
r4=2

## (())
# 同 let，但是不支持计算多个表达式

## $(())
# 同 (())，但它会进行结果替换，如 result=$((10 * 10))
</script></code></pre>
<p><code>let</code> 和 <code>(())</code> 是有返回值的，如果最后一个表达式的值不为 0 则为 true（返回 0），如果为 0 则为 false（返回 1），和 C 语言一样。</p>
<p>let 支持的运算符（优先级从高到低）：</p>
<ul>
<li><code>var++</code>、<code>var--</code>：后自增、后自减</li>
<li><code>++var</code>、<code>--var</code>：前自增、前自减</li>
<li><code>+expr</code>、<code>-expr</code>：一元加（乘以 1）、一元减（乘以 -1）</li>
<li><code>!</code>、<code>~</code>：逻辑非、按位非，<code>!</code> 建议放在单引号中（let）</li>
<li><code>**</code>：幂（乘方）</li>
<li><code>*</code>、<code>/</code>、<code>%</code>：乘、除、取余</li>
<li><code>+</code>、<code>-</code>：加、减</li>
<li><code>&lt;&lt;</code>、<code>&gt;&gt;</code>：按位左移、按位右移</li>
<li><code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>：小于、小于等于、大于、大于等于</li>
<li><code>==</code>、<code>!=</code>：等于、不等于</li>
<li><code>&amp;</code>：按位与</li>
<li><code>^</code>：按位异或</li>
<li><code>|</code>：按位或</li>
<li><code>&amp;&amp;</code>：逻辑与</li>
<li><code>||</code>：逻辑非</li>
<li><code>expr1 ? expr2 : expr3</code>：条件运算符，如果 expr1 为 true 则计算 expr2，如果 expr1 为 false 则计算 expr3</li>
<li><code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>&amp;=</code>、<code>^=</code>、<code>|=</code>：赋值、加减乘除取余、左移右移、按位与、按位异或、按位或</li>
</ul>
<p>注意，<code>let</code> 系列的操作符只支持整数运算（即使计算结果是小数，也会被去除小数部分，注意不是四舍五入）。<br>如果需要进行小数运算（浮点数运算），请使用 awk、bc 等外部命令来完成，建议使用 awk，bc 有些系统没有。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ cat script.awk
BEGIN {
    a = 45; b = 20;
    printf("a + b = %d\n", a + b);
    printf("a - b = %d\n", a - b);
    printf("a * b = %d\n", a * b);
    printf("a / b = %g\n", a / b);
    printf("a % b = %d\n", a % b);
    printf("a ^ b = %d\n", a ^ b);
    printf("a ** b = %d\n", a ** b);
}

$ awk -f script.awk
a + b = 65
a - b = 25
a * b = 900
a / b = 2.25
a % b = 5
a ^ b = 1159445329576199501472242656608256
a ** b = 1159445329576199501472242656608256

$ awk 'BEGIN { print(3 / 2) }'
1.5

$ awk 'BEGIN { print(5 / 3) }'
1.66667

$ awk 'BEGIN { printf("%.6f\n", 5 / 3) }'
1.666667
</script></code></pre>
<p><strong>关系运算符</strong><br>关系运算符只支持数字，不支持字符串。<br>在 bash 中，需要借助<code>/bin/test</code>或<code>/bin/[</code>命令进行关系运算。<br><code>test</code>和<code>[</code>是一样的，它们都是普通命令，区别是<code>[</code>需要使用<code>]</code>标记结束。<br>如：<code>test 10 -eq 10</code>、<code>[ 10 -eq 10 ]</code>，这也就是为什么<code>[]</code>内侧需要空格。<br>建议使用 <code>[</code> 替代 <code>test</code> 命令，因为 bash 已经内置了 <code>[</code> 命令，所以效率更高。</p>
<p>注意，在 shell 中，返回值 0 表示真，其他值表示假，这个和其他语言是相反的。</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-eq</code></td>
<td style="text-align:center">即<code>equal</code>，<code>==</code>等于</td>
<td style="text-align:center"><code>[ 10 -eq 10 ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-ne</code></td>
<td style="text-align:center">即<code>not equal</code>，<code>!=</code>不等于</td>
<td style="text-align:center"><code>[ 10 -ne 11 ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-lt</code></td>
<td style="text-align:center">即<code>less than</code>，<code>&lt;</code>小于</td>
<td style="text-align:center"><code>[ 10 -lt 20 ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-le</code></td>
<td style="text-align:center">即<code>less than or equal</code>，<code>&lt;=</code>小于等于</td>
<td style="text-align:center"><code>[ 10 -le 10 ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-gt</code></td>
<td style="text-align:center">即<code>greater than</code>，<code>&gt;</code>大于</td>
<td style="text-align:center"><code>[ 10 -gt 5 ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-ge</code></td>
<td style="text-align:center">即<code>greater than or equal</code>，<code>&gt;=</code>大于等于</td>
<td style="text-align:center"><code>[ 10 -ge 10 ]</code>，真</td>
</tr>
</tbody>
</table>
<p><strong>逻辑运算符</strong><br>同样的，逻辑运算也要借助于<code>/bin/test</code>或<code>/bin/[</code>命令。</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-a</code></td>
<td style="text-align:center">逻辑与，<code>&amp;&amp;</code></td>
<td style="text-align:center"><code>[ 10 -eq 10 -a 20 -gt 10 ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-o</code></td>
<td style="text-align:center">逻辑或，<code>｜｜</code></td>
<td style="text-align:center"><code>[ 10 -eq 10 -o 20 -lt 10 ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>!</code></td>
<td style="text-align:center">逻辑非，<code>!</code></td>
<td style="text-align:center"><code>[ 10 -eq 10 -a ! 20 -lt 10 ]</code>，真</td>
</tr>
</tbody>
</table>
<p>如果你喜欢使用<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>，那么你可以尝试使用<code>[[</code>关键字：<br>如：<code>[[ 10 -eq 10 &amp;&amp; 20 -eq 20 ]]</code>真、<code>[[ 1 -lt 0 || 1 -gt 0 ]]</code>真。<br>但是，<code>[[ ]]</code>中不再支持<code>-a</code>、<code>-o</code>，只支持<code>&amp;&amp;</code>、<code>||</code>、<code>!</code>了。</p>
<p><strong>字符串测试</strong><br>同样的，字符串测试也要借助于<code>/bin/test</code>或<code>/bin/[</code>命令。</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>=</code></td>
<td style="text-align:center">两个字符串是否<strong>相等</strong></td>
<td style="text-align:center"><code>[ &quot;a&quot; = &quot;a&quot; ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>!=</code></td>
<td style="text-align:center">两个字符串是否<strong>不相等</strong></td>
<td style="text-align:center"><code>[ &quot;a&quot; != &quot;b&quot; ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-n</code></td>
<td style="text-align:center">字符串是否<strong>非空</strong></td>
<td style="text-align:center"><code>[ -n &quot;www&quot; ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>STRING</code></td>
<td style="text-align:center">字符串是否<strong>非空</strong>，同<code>-n</code></td>
<td style="text-align:center"><code>[ &quot;www&quot; ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-z</code></td>
<td style="text-align:center">字符串是否<strong>为空</strong></td>
<td style="text-align:center"><code>[ -z &quot;&quot; ]</code>，真</td>
</tr>
</tbody>
</table>
<p><strong>文件测试</strong><br>同样的，文件测试也要借助于<code>/bin/test</code>或<code>/bin/[</code>命令。</p>
<table>
<thead>
<tr>
<th style="text-align:center">运算符</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">例子</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>-e</code></td>
<td style="text-align:center">文件是否<strong>存在</strong></td>
<td style="text-align:center"><code>[ -e /etc/resolv.conf ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-s</code></td>
<td style="text-align:center">文件是否<strong>非空</strong></td>
<td style="text-align:center"><code>[ -s /etc/resolv.conf ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-d</code></td>
<td style="text-align:center">文件是否为<strong>目录</strong></td>
<td style="text-align:center"><code>[ -d /etc ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-f</code></td>
<td style="text-align:center">文件是否为<strong>普通文件</strong></td>
<td style="text-align:center"><code>[ -f /etc/resolv.conf ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-b</code></td>
<td style="text-align:center">文件是否为<strong>块设备</strong></td>
<td style="text-align:center"><code>[ -b /dev/sda ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-c</code></td>
<td style="text-align:center">文件是否为<strong>字符设备</strong></td>
<td style="text-align:center"><code>[ -c /dev/tty ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-p</code></td>
<td style="text-align:center">文件是否为<strong>具名管道</strong></td>
<td style="text-align:center"><code>[ -p pipe ]</code>，pipe 是我创建的管道文件，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-S</code></td>
<td style="text-align:center">文件是否为<strong>套接字文件</strong></td>
<td style="text-align:center"><code>[ -S /run/systemd/coredump ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-h</code></td>
<td style="text-align:center">文件是否为<strong>软链接文件</strong></td>
<td style="text-align:center"><code>[ -h /bin/sh ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-L</code></td>
<td style="text-align:center">文件是否为<strong>软链接文件</strong>，同<code>-h</code></td>
<td style="text-align:center"><code>[ -L /bin/sh ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-r</code></td>
<td style="text-align:center">文件是否有<strong>可读权限</strong></td>
<td style="text-align:center"><code>[ -r /etc/resolv.conf ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-w</code></td>
<td style="text-align:center">文件是否有<strong>可写权限</strong></td>
<td style="text-align:center"><code>[ -w /etc/resolv.conf ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-x</code></td>
<td style="text-align:center">文件是否有<strong>可执行权限</strong></td>
<td style="text-align:center"><code>[ -x /bin/sh ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-u</code></td>
<td style="text-align:center">文件是否有<strong>SUID权限</strong></td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><code>-g</code></td>
<td style="text-align:center">文件是否有<strong>SGID权限</strong></td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><code>-k</code></td>
<td style="text-align:center">文件是否有<strong>sticky权限</strong></td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><code>-O</code></td>
<td style="text-align:center">文件<strong>所属用户是否有效</strong></td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><code>-G</code></td>
<td style="text-align:center">文件<strong>所属用户组是否有效</strong></td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center"><code>-t</code></td>
<td style="text-align:center"><strong>文件描述符是否已打开</strong></td>
<td style="text-align:center"><code>[ -t 0 ]</code>，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-ef</code></td>
<td style="text-align:center">两个文件是否相同（所在设备相同 &amp;&amp; inode 相同）</td>
<td style="text-align:center"><code>[ f1 -ef f2 ]</code>，f2 是 f1 的硬连接文件，真</td>
</tr>
<tr>
<td style="text-align:center"><code>-nt</code></td>
<td style="text-align:center">即<code>newer than</code>（修改时间）</td>
<td style="text-align:center"><code>[ f1 -nt f2 ]</code>，假</td>
</tr>
<tr>
<td style="text-align:center"><code>-ot</code></td>
<td style="text-align:center">即<code>older than</code>（修改时间）</td>
<td style="text-align:center"><code>[ f1 -ot f2 ]</code>，假</td>
</tr>
</tbody>
</table>
<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2><p>echo 可能是我们接触 Linux 的第一个命令了。大家都比较熟悉，下面是几个简单的用法：<br><code>echo &quot;www.zfl9.com www.baidu.com www.google.com&quot;</code>，使用双引号扩起来；<br><code>echo &#39;www.zfl9.com www.baidu.com www.google.com&#39;</code>，使用单引号扩起来；<br><code>echo www.zfl9.com www.baidu.com www.google.com</code>，也可以省略引号；</p>
<p>上面几个都是最常见的用法，谁都知道，但是下面这些命令，你可能就不一定熟悉了：<br><code>echo -n &quot;www.zfl9.com&quot;</code>，<code>-n</code>选项，不在字符串末尾添加<code>\n</code>换行符；<br><code>echo -e &quot;\twww.zfl9.com&quot;</code>，<code>-e</code>选项，开启字符串转义；<br><code>echo -e &quot;www.zfl9.com\n\c这些字符串不会被输出&quot;</code>，<code>\c</code>表示从这以后的字符串将不再输出；<br><code>echo -e &quot;\e[32mtrue\e[0m&quot; &quot;\e[35mfalse\e[0m&quot;</code>，支持设定字符串颜色，true 为绿色，false 为红色；</p>
<p>echo 默认是关闭转义功能的，使用选项<code>-e</code>来显式开启它，下面是一些常见的转义字符：</p>
<table>
<thead>
<tr>
<th style="text-align:center">转义字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\a</code></td>
<td style="text-align:center">响铃（BEL），终端会响一声</td>
</tr>
<tr>
<td style="text-align:center"><code>\b</code></td>
<td style="text-align:center">退格（BS），将当前位置退回上一个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>\r</code></td>
<td style="text-align:center">回车（CR），将当前位置移至本行开头</td>
</tr>
<tr>
<td style="text-align:center"><code>\n</code></td>
<td style="text-align:center">换行（LF），将当前位置移至下行开头</td>
</tr>
<tr>
<td style="text-align:center"><code>\f</code></td>
<td style="text-align:center">换页（FF），将当前位置移至下页开头</td>
</tr>
<tr>
<td style="text-align:center"><code>\t</code></td>
<td style="text-align:center">水平制表（HT）</td>
</tr>
<tr>
<td style="text-align:center"><code>\v</code></td>
<td style="text-align:center">垂直制表（VT）</td>
</tr>
<tr>
<td style="text-align:center"><code>\0</code></td>
<td style="text-align:center">空字符（NULL）</td>
</tr>
<tr>
<td style="text-align:center"><code>\0NNN</code></td>
<td style="text-align:center">八进制数字（1 ~ 3 位）</td>
</tr>
<tr>
<td style="text-align:center"><code>\xHH</code></td>
<td style="text-align:center">十六进制数字（1 ~ 2 位）</td>
</tr>
</tbody>
</table>
<p><strong>输出颜色</strong><br>这个可能是最炫的功能了，我们一起来学习一下，如何让 echo 输出带有颜色的字符！<br>要想输出颜色，就必须打开转义功能，使用选项<code>-e</code>；具体格式<code>\e[控制码m字符串</code>，或<code>\033[控制码m字符串</code>。<br>以<code>\e[</code>或<code>\033[</code>开头，控制码可以有多个，它们之间使用分号<code>;</code>隔开，最后以字符<code>m</code>结束。<br>但是为了不影响后面的输出，我们通常需要使用<code>\e[0m</code>来恢复默认格式，因此，一般形式为：<code>\e[控制码m字符串\e[0m</code>。</p>
<table>
<thead>
<tr>
<th style="text-align:center">编码</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>\e[0m</code></td>
<td style="text-align:center">恢复默认格式</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[1m</code></td>
<td style="text-align:center">粗体/高亮显示</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[2m</code></td>
<td style="text-align:center">模糊（部分终端支持）</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[3m</code></td>
<td style="text-align:center">斜体（部分终端支持）</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[4m</code></td>
<td style="text-align:center">下划线</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[5m</code></td>
<td style="text-align:center">闪烁（慢）</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[6m</code></td>
<td style="text-align:center">闪烁（快）（部分终端支持）</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[7m</code></td>
<td style="text-align:center">交换背景色与前景色</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[8m</code></td>
<td style="text-align:center">隐藏（什么也看不见）（部分终端支持）</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[3xm</code></td>
<td style="text-align:center">前景色，x 为颜色值（可参见下面的颜色表）</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[4xm</code></td>
<td style="text-align:center">背景色，x 为颜色值（可参见下面的颜色表）</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[nA</code></td>
<td style="text-align:center">光标上移 n 行</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[nB</code></td>
<td style="text-align:center">光标下移 n 行</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[nC</code></td>
<td style="text-align:center">光标右移 n 行</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[nD</code></td>
<td style="text-align:center">光标左移 n 行</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[y;xH</code></td>
<td style="text-align:center">调整光标位置，y 为纵向，x 为横向</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[s</code></td>
<td style="text-align:center">保存光标位置</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[u</code></td>
<td style="text-align:center">恢复光标位置</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[?25l</code></td>
<td style="text-align:center">隐藏光标</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[?25h</code></td>
<td style="text-align:center">显示光标</td>
</tr>
<tr>
<td style="text-align:center"><code>\e[2J</code></td>
<td style="text-align:center">清屏</td>
</tr>
<tr>
<td style="text-align:center"><code>\ec</code></td>
<td style="text-align:center">清屏（推荐）</td>
</tr>
</tbody>
</table>
<p>颜色表</p>
<table>
<thead>
<tr>
<th style="text-align:center">编码</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0</td>
<td style="text-align:center">黑</td>
</tr>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">红</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">绿</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">黄</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">蓝</td>
</tr>
<tr>
<td style="text-align:center">5</td>
<td style="text-align:center">紫</td>
</tr>
<tr>
<td style="text-align:center">6</td>
<td style="text-align:center">青</td>
</tr>
<tr>
<td style="text-align:center">7</td>
<td style="text-align:center">白</td>
</tr>
</tbody>
</table>
<blockquote>
<p>需要注意的是，这些控制码都是由终端支持的，与具体的语言无关，因此你可以使用 C/C++、Java、Python 等语言输出颜色。</p>
</blockquote>
<h2 id="printf"><a href="#printf" class="headerlink" title="printf"></a>printf</h2><p>除了 echo，还有一个常用的输出命令就是 printf，它支持格式化输出，和 C 语言的 printf() 风格类似。<br>语法：<code>printf format-string arguments...</code>，和 printf() 一样，它不会自动在字符串末尾添加换行符。</p>
<p>格式参数，以<code>%</code>开头，如果需要输出<code>%</code>本身，需要使用<code>%%</code>进行转义，常用的几个格式：<br><code>%c</code>，单个字符，如果传入的参数为多个字符，那么只提取第一个字符；<br><code>%s</code>，字符串，使用<code>%ns</code>控制长度（默认右对齐），使用<code>%-ns</code>进行左对齐，下同；<br><code>%d</code>，整数，十进制，使用<code>%nd</code>控制长度（默认右对齐），使用<code>%0nd</code>进行高位补零，使用<code>%+d</code>显示正负号；<br><code>%f</code>，浮点数，精确到小数点后六位（四舍五入），使用<code>%.nf</code>控制精确位数；<br><code>%e</code>，浮点数，以科学计数法表示，指数部分以小写的 e 表示；<br><code>%E</code>，浮点数，以科学计数法表示，指数部分以大写的 E 表示；<br><code>%g</code>，浮点数，自动选择使用<code>%f</code>、<code>%e</code>格式；<br><code>%G</code>，浮点数，自动选择使用<code>%f</code>、<code>%E</code>格式；</p>
<p>如果格式参数的个数与实际参数的个数不一致，那么<code>format-string</code>将被重用；<br>如：<code>printf &quot;%s\n&quot; &quot;baidu&quot; &quot;google&quot; &quot;facebook&quot;</code>，将输出三行，说明<code>%s\n</code>被重用了。</p>
<p>printf 支持的转义字符和 echo 一样，并且还额外支持以下几个转义字符：<br><code>\NNN</code>八进制数字（0 ~ 3 位）、<code>\xHH</code>十六进制数字（1 ~ 2 位）、<code>\uHHHH</code>Unicode码、<code>\uHHHHHHHH</code>Unicode码。</p>
<p><code>echo</code> 和 <code>printf</code> 都是 bash 的内置命令，因此从效率上讲没多大区别，根据自己的需要选择使用。</p>
<h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><blockquote>
<p>注意，每个分支不可为空，如果不需要此分支，那就不要写，如果真的需要，那么就使用 <code>:</code> 内置命令填充。</p>
</blockquote>
<p><strong>if</strong><br>if 根据 condition 的返回值判断是否要执行该分支，如果 condition 返回 0，则为真，否则为假。<br>一般使用<code>/bin/test</code>、<code>/bin/[</code>、<code>[[</code>进行条件测试，具体的命令用法已在前文给出，不再复述。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">if condition; then
    command1
    command2
    ...
    commandN
fi
</script></code></pre>
<p><strong>if…else</strong><br>如果 condition 为真，则执行 if 分支，否则执行 else 分支。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">if condition; then
    command1
    ...
    commandN
else
    command1
    ...
    commandN
fi
</script></code></pre>
<p><strong>if…elif…else</strong><br>从上至下依次匹配，如果条件为真，则执行该分支，如果所有条件都为假，则执行 else 分支（也可以没有 else 分支）。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">if condition; then
    ...
elif condition; then
    ...
elif condition; then
    ...
else
    ...
fi
</script></code></pre>
<p><strong>foreach</strong><br>用于遍历（枚举）指定的元素列表。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
## 指定元素列表(空格隔开，如果元素内容包含空白符，请使用引号包围)
for var in item1 item2 item3 ... itemN; do
    command1
    command2
    ...
    commandN
done

## 如果省略 in 列表，则遍历位置参数(脚本命令行参数或函数的位置参数)
for arg; do
    echo "$arg"
done

## foreach 的语法细节
# 传递给 foreach 的元素列表其实和传递给命令的参数列表一样，使用空白符作为分隔符
# 如果元素内容包含空白符（如空格符），必须使用引号包围，否则会被作为多个元素处理

## 遍历数组 (双引号)
for elem in "${array[@]}"; do
    command1
    command2
    ...
    commandN
done

## 遍历参数 (双引号)
for arg in "$@"; do
    command1
    command2
    ...
    commandN
done

## 关于 "${array[@]}" 和 "$@"
# 必须使用双引号包围，否则无法正确处理数组元素/位置参数中包含空白符的情况（未加双引号时元素中的空白符被作为分隔符处理）
# 只要是双引号里面带 @ 的表达式（好像就上面的两种），shell 都会先展开里面的元素（如果元素内容含空白符，则自动加上引号）
# 不光在 foreach 中是这样，在进行 "参数转发" 时也经常使用 "$@"、"${array[@]}" 等表达式，它们也会被自动展开，简单例子：
[root@arch ~]# cat test.sh
#!/bin/bash
function main {
    for arg in "$@"; do echo "$arg"; done
}
main $@   # 没引号
echo '-----------'
main "$@" # 双引号
[root@arch ~]# 
[root@arch ~]# ./test.sh 1 2 3 '4 5'
1
2
3
4
5
-----------
1
2
3
4 5

## foreach 与 $IFS 变量
# IFS，即"Internal Field Seprator"，默认为: "空格"、"制表"、"换行"
# 并且，多个连续空格会被当成一个空格进行处理，但是其它的两个则不会合并
# 但是，不要试图改变 IFS 变量的值来改变 foreach 的元素分割符，因为没用
# 比如，我想遍历 IPv4 地址的每个部分（点号作为分隔符），这是最初的例子：

[root@arch ~]# IFS='.'; for byte in 192.168.255.120; do echo "$byte"; done
192.168.255.120

# 那么该如何分割 IPv4 地址呢？目前最靠谱有效的方式就是利用 read 内置命令：

[root@arch ~]# IFS='.' read -ra bytes <<<"192.168.255.120"
[root@arch ~]# for byte in "${bytes[@]}"; do echo "$byte"; done
192
168
255
120

# read 在给 bytes 数组赋值前会先清空原有的元素，所以不用担心数据污染问题
# 稍微解释一下 `read -ra bytes`，-r 选项表示忽略输入中的转义序列，-a 选项
# 表示将输入的字符串按照 IFS 变量进行分割，然后存入指定的数组中，即 bytes
# 因为 read 命令是从标准输入流中读取数据的，所以需要使用 <<<string 重定向
# 最后解释一下 read 命令前面的 IFS='.' 是什么意思（注意它们之间没有分号哦）
# 这其实是一个 shell 技巧，当我们在一条命令前面加上变量赋值（多个空格隔开）
# 语句时，这些变量会自动作为这条命令的环境变量，但是不会影响当前的环境变量
# 因此当你执行完这条命令后，使用 `printf "$IFS"` 看到的依旧是 IFS 原来的值 

# read 命令只会从输入中读取一行，如果要遍历输入的每一行，请将它放在循环中

[root@arch ~]# cat <<<$'www.zfl9.com\nwww.baidu.com\nwww.google.com'
www.zfl9.com
www.baidu.com
www.google.com
[root@arch ~]# read -r line <<<$'www.zfl9.com\nwww.baidu.com\nwww.google.com'
[root@arch ~]# echo "$line"
www.zfl9.com

# read 命令的返回值：正常情况下返回 0；当发生以下情况时，read 会返回非 0 值：
# 读到 EOF
# 发生读取超时
# 变量赋值错误
# 无效的文件描述符

# 其中第一条最常用，也就是读取到 EOF 时，read 会立即返回 1，因此可以退出循环：
[root@arch ~]# while read -r line; do echo "$line"; done <<<$'www.zfl9.com\nwww.baidu.com\nwww.google.com'
www.zfl9.com
www.baidu.com
www.google.com

# 我们可以利用 read 来遍历文件的每一行，不要使用 foreach，因为会被空白符污染
[root@arch ~]# cat data
www zfl9 com
www baidu com
www google com
[root@arch ~]# for line in "$(cat data)"; do echo "$((++i)) $line"; done
1 www zfl9 com
www baidu com
www google com
[root@arch ~]# i=0
[root@arch ~]# for line in $(cat data); do echo "$((++i)) $line"; done
1 www
2 zfl9
3 com
4 www
5 baidu
6 com
7 www
8 google
9 com
[root@arch ~]# i=0
[root@arch ~]# while read -r line; do echo "$((++i)) $line"; done <data
1 www zfl9 com
2 www baidu com
3 www google com

## read 命令的常用选项（read --help）
# -r            不要对输入行中的转义序列进行转义（反斜线转义字符）
# -a array      将读取到的数据行按照 IFS 值进行分割，然后存入数组
# -p prompt     在读取前先打印指定的提示字符串（不自动添加换行符）
# -s            不要显示用户输入的数据（在录入密码等数据时很有用）
# -t timeout    指定读取的超时时间（单位为秒，timeout 可以为小数）
# -u fd         从指定的文件描述符中读取，而不是从标准输入流中读取
</script></code></pre>
<p><strong>for</strong><br>C/C++ 风格的 for() 循环，使用双重圆括号。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">for ((i = 0; i < 10; i++)); do
    echo $i
done
</script></code></pre>
<p><strong>while</strong><br>如果 condition 返回 0，则继续循环，否则退出循环。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">while condition; do
    ...
done

## 无限循环 - 1
while true; do      # 因为 /bin/true 命令总是返回 0
    ...
done

## 无限循环 - 2
while :; do         # 因为 : built-in 命令总是返回 0
    ...
done

## 无限循环 - 3
for ((;;)) do       # for 无限循环
    ...
done
</script></code></pre>
<p><strong>until</strong><br>如果 condition 返回非 0，则继续循环，否则退出循环，和 while 刚好相反。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">until condition; do
    ...
done
</script></code></pre>
<p><strong>case</strong><br>if…elif…elif…else 的简化直观版本，相当于 C 语言的 switch 语句。<br>globbing 即 shell 通配符，case 还在此基础上添加了对<code>|</code>选择元字符的支持。<br>因此，在 case 中，支持<code>*</code>、<code>?</code>、<code>[]</code>、<code>[^]</code>、<code>|</code>五种模式匹配元字符。<br>解释一下<code>|</code>，它和 regex 中的<code>|</code>是一样的，<strong>或</strong>的意思，用来选择多个模式。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">case var in
globbing1)
    command1
    ...
    commandN
    ;;
globbing2)
    command1
    ...
    commandN
    ;;
globbing3)
    command1
    ...
    commandN
    ;;
*)
    command1
    ...
    commandN
    ;;
esac
</script></code></pre>
<p><strong>break、continue</strong><br><code>break</code>：结束当前循环，执行循环后面的语句；<br><code>continue</code>：结束此轮循环，直接开始下轮循环。<br>这两个关键字可用于<code>for</code>、<code>while</code>、<code>until</code>中。</p>
<p><code>break</code> 和 <code>continue</code> 后面可以接一个整数（大于 0），即 <code>break N</code>、<code>continue N</code>。<br>这个 N 是什么意思呢？它表示要跳出几层循环，N 默认为 1，即只跳出当前这层循环。例子：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ cat test.sh 
#!/bin/bash
for ((i = 0; i < 3; i++)); do
    for ((j = 0; j < 3; j++)); do
        [ "$i" -eq 1 ] && continue 2
        echo "$i $j"
    done
done

$ ./test.sh 
0 0
0 1
0 2
2 0
2 1
2 2
</script></code></pre>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>在 shell 中，同样有函数的概念，具体语法如下：<br>其中，<code>function</code>、<code>()</code>、<code>return</code>都可以省略。<br>如果没有<code>return</code>语句，那么默认返回最后一条命令的退出值；<br>如果有<code>return</code>语句，那么返回值类型为 int（<code>[0, 255]</code>）。</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">function func_name() {
    command1
    command2
    ...
    commandN
    return exit_code
}
</script></code></pre>
<p>定义好函数之后，我们就可以使用它了（允许在函数中定义函数，和变量一样）；<br>使用函数很简单，一个函数就和一个普通的命令一样，只需要写函数名，不用加<code>()</code>；<br>如：<code>func_name</code>；还可以传递参数，<code>func_name arg1 arg2 arg3</code>，在函数内部使用<code>$n</code>获取；<br>其中<code>$0</code>为当前可执行文件名，<code>$1</code>为第一个参数、<code>$2</code>为第二个参数，…，以此类推；<br>使用<code>$#</code>获取参数个数，<code>$@</code>或<code>$*</code>获取所有传递的参数，<code>$?</code>可在函数外部获取函数返回值。<br><code>$@</code>和<code>$*</code>的区别说了很多遍，这就不再重复了，你会发现函数其实和一个 shell 脚本没多大区别。</p>
<p><strong>递归调用</strong><br>在 shell 函数中，同样支持递归调用，即自己调用自己。<br>并且，我发现 bash 中没有深度限制，可以一直递归下去；但是在 zsh 中就有 1000 层限制。</p>
<p>关于 bash 函数，还有几点要说明一下：<br>1) 必须先定义函数，才能使用，不支持类似 C/C++ 中的函数声明；<br>2) 在一个函数中，可以调用另一个已定义的函数，也可以调用本身。</p>
<p><strong>函数局部变量</strong><br>在函数中，我们可以访问全局变量（读取、修改）；也可以定义新的变量；<br>但是要注意，在函数中定义的变量默认是全局变量，即在函数外部依旧可以访问；<br>那么，如何定义函数局部变量呢？使用关键字<code>local</code>，如<code>local var_name=value</code>；<br>这时，<code>var_name</code>变量就是一个局部变量，在函数外部不可访问，只能在函数内部使用。<br>如果局部变量和全局变量有命名冲突（变量名一样），则优先使用局部变量（优先级高）。</p>
<p><strong>具名函数、匿名函数</strong><br><code>具名函数</code>：通常情况下我们定义的都是具名函数，也就是都有函数名；<br><code>匿名函数</code>：使用<code>{ command1; command2; ...; commandN; }</code>来定义和使用匿名函数。</p>
<p>匿名函数中不能有 return 语句，如果花括号与命令在同一行，需要空格隔开（左括号）和分号结束（右括号）；<br>比如：<code>{ echo www.zfl9.com; }</code>；如果不在同一行，就不需要使用空格隔开和以分号结束，具体例子如下：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">#!/bin/bash

# 正确
{ echo www.zfl9.com;}
# 正确
{ echo www.zfl9.com; }
# 正确
{
    echo www.zfl9.com
}
</script></code></pre>
<p><strong>函数定义的推荐语法</strong><br>使用标准的、可移植的 <code>func_name() { ... }</code> 形式。此外，再介绍一个特殊的语法：<code>func_name() ( ... )</code>，看例子：</p>
<pre><code class="line-numbers language-bash">#!/bin/bash

func1() {
    echo &quot;[func1] change dir to /etc&quot;
    cd /etc
    echo &quot;[func1] current dir is: $(pwd)&quot;
}

func2() (
    echo &quot;[func2] change dir to /bin&quot;
    cd /bin
    echo &quot;[func2] current dir is: $(pwd)&quot;
)

cd /

echo &quot;[main] before call func1: $(pwd)&quot;
func1
echo &quot;[main] after call func1: $(pwd)&quot;

echo &quot;[main] before call func2: $(pwd)&quot;
func2
echo &quot;[main] after call func2: $(pwd)&quot;
</code></pre>
<pre><code class="line-numbers language-bash"># root @ arch in ~ [20:55:58] 
$ chmod +x test.sh 

# root @ arch in ~ [20:56:25] 
$ ./test.sh 
[main] before call func1: /
[func1] change dir to /etc
[func1] current dir is: /etc
[main] after call func1: /etc
[main] before call func2: /etc
[func2] change dir to /bin
[func2] current dir is: /bin
[main] after call func2: /etc
</code></pre>
<p>区别就是，<code>func_name() { ... }</code> 定义的是一个具名函数，shell 中的函数都是在当前 shell 进程中执行的，所以使用 cd 改变工作目录时会影响到当前 shell 进程；而 <code>func_name() ( ... )</code> 其实定义的是一个具名子程序，当你调用这个“函数”时，其实相当于调用一个外部的 shell script 脚本，该子程序运行在独立的 shell 进程，该 shell 进程与调用者所在的 shell 进程是互不影响的。在某些场合，使用 <code>func_name() ( ... )</code> 有奇效。</p>
<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><p>要彻底理解重定向，我们必须先来了解这些基础知识：</p>
<p><strong>文件描述符</strong><br>文件描述符是一个用于表述指向文件的引用的抽象化概念。<br>文件描述符在形式上是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。<br>当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p>
<p><strong>stdin、stdout、stderr</strong><br>每个进程（除了守护进程）都会默认打开这三个文件：<br><code>stdin</code>：标准输入文件，对应键盘，文件描述符 FD 为 0；<br><code>stdout</code>：标准输出文件，对应显示器，文件描述符 FD 为 1；<br><code>stderr</code>：标准错误文件，对应显示器，文件描述符 FD 为 2；</p>
<p>我们可以使用<code>lsof -p $$</code>命令查看当前 shell 打开的文件描述符信息；<br>从命令输出中可以发现 fd0、fd1、fd2 都是以 rw 读写模式打开的。</p>
<p>了解这些知识之后，我们再来学习一下 shell 重定向操作：<br><code>command 0&lt;data.file</code>：重定向标准输入，0 表示 fd0（stdin），<code>&lt;</code>表示只读方式，即不再从键盘读取数据，而是从 data.file 读取数据；<br><code>command 1&gt;data.file</code>：重定向标准输出，1 表示 fd1（stdout），<code>&gt;</code>表示只写方式（会清空原文件），即不再往显示器写入数据，而是往 data.file 写入数据；<br><code>command 1&gt;&gt;data.file</code>；重定向标准输出，1 表示 fd1（stdout），<code>&gt;&gt;</code>表示追加方式（不清空原文件），即不再往显示器写入数据，而是往 data.file 写入数据；<br><code>command 2&gt;data.file</code>：重定向标准错误，2 表示 fd2（stderr），<code>&gt;</code>表示只写方式（会清空原文件），即不再往显示器写入数据，而是往 data.file 写入数据；<br><code>command 2&gt;&gt;data.file</code>；重定向标准错误，2 表示 fd2（stderr），<code>&gt;&gt;</code>表示追加方式（不清空原文件），即不再往显示器写入数据，而是往 data.file 写入数据；</p>
<blockquote>
<p>其实可以和 C 语言中的 fopen() 中的 mode 联系起来，<code>&lt;</code>即<code>rb</code>、<code>&gt;</code>即<code>wb</code>、<code>&gt;&gt;</code>即<code>ab</code>。</p>
</blockquote>
<p>其中：<code>&lt;</code>默认与<code>fd0</code>关联，即<code>&lt;</code>和<code>0&lt;</code>一样；<code>&gt;</code>或<code>&gt;&gt;</code>默认与<code>fd1</code>关联，即<code>&gt;</code>、<code>&gt;&gt;</code>和<code>1&gt;</code>、<code>1&gt;&gt;</code>一样。</p>
<p>将 stdout、stderr 重定向到不同文件：<br><code>command &gt;out.log 2&gt;err.log</code>（写入）；<code>command &gt;&gt;out.log 2&gt;&gt;err.log</code>（追加）。</p>
<p>将 stdout、stderr 重定向至同一文件：<br>1) <code>command &gt;log 2&gt;&amp;1</code>（写入）；<code>command &gt;&gt;log 2&gt;&amp;1</code>（追加）；<br>2) <code>command 2&gt;log 1&gt;&amp;2</code>（写入）；<code>command 2&gt;&gt;log 1&gt;&amp;2</code>（追加）；<br>3) <code>command &amp;&gt;log</code>（写入）；<code>command &amp;&gt;&gt;log</code>（追加）。</p>
<p>三种方式产生的效果都是一样的（但里面有些细节不一样），其中第三种是简写方式，在某些时候有局限性。<br>如：我要将 stdout 和 stderr 合并，用管道传递给下一个命令，就不能使用方式三，只能为<code>cmd1 2&gt;&amp;1 | cmd2</code>。</p>
<p>合并 stdout、stderr 流到其中一个流：<br><code>command 2&gt;&amp;1</code>：将 stderr 合并到 stdout<br><code>command 1&gt;&amp;2</code>：将 stdout 合并到 stderr</p>
<p><strong>heredoc</strong><br>有时候我不想从 stdin 读取数据，而是想现写，这时候就可以使用<code>&lt;&lt;</code>，打开 heredoc 功能。<br>具体用法：<code>command &lt;&lt;EOF</code>，其中 <code>EOF</code> 只是一个表示结束的字符串，你可以换成任意字符串；<br>当你按下回车后，你就可以写入任意数据了，写完后，新起一行，输入<code>EOF</code>，按下回车就可以了。</p>
<p><code>command &lt;&lt;EOF</code>：不带引号的 EOF，允许变量引用、命令替换；<br><code>command &lt;&lt;&#39;EOF&#39;</code>：单引号的 EOF，关闭变量引用、命令替换；<br><code>command &lt;&lt;&quot;EOF&quot;</code>：双引号的 EOF，关闭变量引用、命令替换。<br>无论带不带引号，heredoc 都使用单独的 EOF 行表示结束（前后不能有任何内容）。</p>
<p>这个功能在 shell 脚本中很常用。比如，我想在脚本中输出一大段内容到一个文件中，heredoc 就派上用场了：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~ [9:51:21]
$ cat test.sh
#!/bin/bash

# 检查参数
if [ $# -lt 2 ]; then
    echo "Usage: $0 <listen_ip> <listen_port>" 1>&2
    exit 1
fi

# 可以在 heredoc 中引用变量，非常方便
cat <<EOF >my.conf
listen_ip=$1
listen_port=$2
EOF

# root @ arch in ~ [9:51:23]
$ chmod +x test.sh

# root @ arch in ~ [9:51:27]
$ ./test.sh
Usage: ./test.sh <listen_ip> <listen_port>

# root @ arch in ~ [9:51:30] C:1
$ ./test.sh 0.0.0.0 1080

# root @ arch in ~ [9:51:39]
$ cat my.conf
listen_ip=0.0.0.0
listen_port=1080
</script></code></pre>
<p><strong>heredoc 变种</strong><br>除了 <code>&lt;&lt;EOF</code> 外，我们还可以直接使用 <code>&lt;&lt;&lt;&#39;string data&#39;</code> 或 <code>&lt;&lt;&lt;&quot;string data&quot;</code> 或 <code>&lt;&lt;&lt;$&#39;string data&#39;</code>（如果没有空白符也可以不加引号，第 3 种会进行转义），它们的作用是一样的（重定向 stdin），<code>&lt;&lt;EOF</code> 适用于多行文本，<code>&lt;&lt;&lt;string</code> 适用于单行文本串（当然也可以多行），例子：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ cat <<EOF
heredoc> www.baidu.com
heredoc> EOF
www.baidu.com

$ cat <<<www.baidu.com  
www.baidu.com

$ cat <<<'www.baidu.com'
www.baidu.com

$ cat <<<"www.baidu.com"
www.baidu.com

$ cat <<<$'www.zfl9.com\nwww.baidu.com\nwww.google.com'
www.zfl9.com
www.baidu.com
www.google.com
</script></code></pre>
<p><strong>重定向汇总</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">命令</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>CMD FD&lt;FILENAME</code></td>
<td style="text-align:center">以<code>rb</code>方式打开 FILENAME，将 FD 指向的文件改为 FILENAME，FD 默认为 0</td>
</tr>
<tr>
<td style="text-align:center"><code>CMD FD&gt;FILENAME</code></td>
<td style="text-align:center">以<code>wb</code>方式打开 FILENAME，将 FD 指向的文件改为 FILENAME，FD 默认为 1</td>
</tr>
<tr>
<td style="text-align:center"><code>CMD FD&gt;&gt;FILENAME</code></td>
<td style="text-align:center">以<code>ab</code>方式打开 FILENAME，将 FD 指向的文件改为 FILENAME，FD 默认为 1</td>
</tr>
<tr>
<td style="text-align:center"><code>CMD FD1&lt;&amp;FD2</code></td>
<td style="text-align:center">将 FD2 合并至 FD1（读取），FD1 默认为 0</td>
</tr>
<tr>
<td style="text-align:center"><code>CMD FD1&gt;&amp;FD2</code></td>
<td style="text-align:center">将 FD1 合并至 FD2（写入），FD1 默认为 1</td>
</tr>
<tr>
<td style="text-align:center"><code>exec FD&lt;FILENAME</code></td>
<td style="text-align:center">以<code>rb</code>方式打开 FILENAME，并分配指定 FD（限制为 0-9），默认 FD 为 0</td>
</tr>
<tr>
<td style="text-align:center"><code>exec FD&gt;FILENAME</code></td>
<td style="text-align:center">以<code>wb</code>方式打开 FILENAME，并分配指定 FD（限制为 0-9），默认 FD 为 1</td>
</tr>
<tr>
<td style="text-align:center"><code>exec FD&gt;&gt;FILENAME</code></td>
<td style="text-align:center">以<code>ab</code>方式打开 FILENAME，并分配指定 FD（限制为 0-9），默认 FD 为 1</td>
</tr>
<tr>
<td style="text-align:center"><code>exec FD&lt;&gt;FILENAME</code></td>
<td style="text-align:center">以<code>rb+</code>方式打开 FILENAME，并分配指定 FD（限制为 0-9），默认 FD 为 0</td>
</tr>
<tr>
<td style="text-align:center"><code>exec FD&lt;&amp;-</code></td>
<td style="text-align:center">关闭 FD 的输入，实际上 FD 会被释放，默认 FD 为 0</td>
</tr>
<tr>
<td style="text-align:center"><code>exec FD&gt;&amp;-</code></td>
<td style="text-align:center">关闭 FD 的输出，实际上 FD 会被释放，默认 FD 为 1</td>
</tr>
</tbody>
</table>
<blockquote>
<p>关于<code>exec</code>打开自定义描述符的一些说明：<br>在 bash-4.4.12 中测试发现，FD 没有限制，可以大于 9；<br>在 zsh-5.4.2 中测试发现，FD 被限制为 0-9，不能是其它值。</p>
</blockquote>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道，即：将上一个命令的标准输出作为下一个命令的标准输入，这两个命令之间使用<code>|</code>管道连接符相连。<br>比如，查找当前系统中是否有用户 zhang3：<code>cat /etc/passwd | grep &#39;zhang3&#39;</code>或<code>grep &#39;zhang3&#39; /etc/passwd</code>。</p>
<p>特别注意：管道只会将前一个命令的 stdout 作为后一个命令的 stdin，而 stderr 则不会被后一个命令读取！<br>如果想要让后一个命令获取前一个命令的 stdout 和 stderr，可以这么写：<code>cat /etc/passwd 2&gt;&amp;1 | grep &#39;zhang3&#39;</code>。</p>
<h2 id="文件包含"><a href="#文件包含" class="headerlink" title="文件包含"></a>文件包含</h2><p>其实在第一节中我们就提到了<code>source</code>命令，用来载入指定的文件内容，并在当前 shell 中执行；此外，<code>source</code>还有一个别名<code>.</code>。<br>其实原理非常简单，当前 shell 一行一行的读取指定文件（文本文件），并在当前 shell 中解释执行，就和手打一样，完全没区别。</p>
<p><strong>sub-shell</strong><br><code>sub-shell</code>即子 shell。我们有 3 种方式启动一个 sub-shell 来执行命令：<br>1) <code>./test.sh</code>：test.sh 需要可执行权限，并且首行有约定标记；<br>2) <code>/bin/bash test.sh</code>：test.sh 不需要可执行权限，并且首行约定标记也不需要；<br>3) <code>(command1; command2; ...; commandN)</code>：直接启动一个 sub-shell 来解释执行给定的命令。</p>
<p>sub-shell 的特点是：<br>1) 必须启动一个新的 bash 解释器来执行给定的脚本/命令；<br>2) sub-shell 会继承当前 shell 的环境变量（拷贝一份）；<br>3) 在 sub-shell 中改变环境变量并不会影响当前 shell 的环境变量。</p>
<p>大部分情况下，sub-shell 都能满足我们的需求；但是如果我们需要让脚本中的语句改变当前 shell 的环境变量，就必须使用<code>source</code>命令。</p>
<h2 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h2><table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">匹配 0 个或多个字符（<code>/</code>除外）</td>
</tr>
<tr>
<td style="text-align:center"><code>**</code></td>
<td style="text-align:center">在<code>*</code>的基础上支持匹配<code>/</code>，即支持匹配多级目录</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">匹配单个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[abc]</code></td>
<td style="text-align:center">匹配集合中的任意单个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[0-9]</code></td>
<td style="text-align:center">同上，可指定范围</td>
</tr>
<tr>
<td style="text-align:center"><code>[^abc]</code></td>
<td style="text-align:center">不匹配集合中的任意单个字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[^0-9]</code></td>
<td style="text-align:center">同上，可指定范围</td>
</tr>
<tr>
<td style="text-align:center"><code>[:alpha:]</code></td>
<td style="text-align:center">字母</td>
</tr>
<tr>
<td style="text-align:center"><code>[:digit:]</code></td>
<td style="text-align:center">数字</td>
</tr>
<tr>
<td style="text-align:center"><code>[:alnum:]</code></td>
<td style="text-align:center">字母 + 数字</td>
</tr>
<tr>
<td style="text-align:center"><code>[:lower:]</code></td>
<td style="text-align:center">小写字母</td>
</tr>
<tr>
<td style="text-align:center"><code>[:upper:]</code></td>
<td style="text-align:center">大写字母</td>
</tr>
<tr>
<td style="text-align:center"><code>[:cntrl:]</code></td>
<td style="text-align:center">控制字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[:space:]</code></td>
<td style="text-align:center">空白字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[:print:]</code></td>
<td style="text-align:center">可打印字符</td>
</tr>
<tr>
<td style="text-align:center"><code>[:xdigit:]</code></td>
<td style="text-align:center">十六进制数</td>
</tr>
</tbody>
</table>
<h2 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h2><table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>()</code></td>
<td style="text-align:center">启动 sub-shell，解释执行括号中的命令</td>
</tr>
<tr>
<td style="text-align:center"><code>{}</code></td>
<td style="text-align:center">1) 匿名函数；2) 枚举，如<code>{a,b,c}</code>、<code>{a..z}</code></td>
</tr>
<tr>
<td style="text-align:center"><code>[]</code></td>
<td style="text-align:center">同<code>test</code>，但是需要使用<code>]</code>来标识边界</td>
</tr>
<tr>
<td style="text-align:center"><code>[[]]</code></td>
<td style="text-align:center">增强版<code>test</code>，支持 shell 通配符，regex 正则表达式、<code>&amp;&amp; ｜｜ ! ()</code>逻辑连接符；如<code>[[ &quot;abc&quot; == * ]]</code>通配符、<code>[[ &quot;a&quot; != [0-9] ]]</code>通配符(取反)、<code>[[ &quot;www&quot; =~ w+ ]]</code>正则匹配</td>
</tr>
<tr>
<td style="text-align:center"><code>${}</code></td>
<td style="text-align:center">变量引用，当然也可以省略花括号，但是强烈建议带上花括号</td>
</tr>
<tr>
<td style="text-align:center"><code>$()</code></td>
<td style="text-align:center">命令替换，执行括号中的命令，并获取它的标准输出结果</td>
</tr>
<tr>
<td style="text-align:center"><code>(())</code></td>
<td style="text-align:center">1) 整数运算；2) 用于 for 循环，如<code>for ((i = 0; i &lt; 10; i++)); do echo $i; done</code></td>
</tr>
<tr>
<td style="text-align:center"><code>$(())</code></td>
<td style="text-align:center">整数运算，并执行命令替换（将计算结果替换出来）</td>
</tr>
<tr>
<td style="text-align:center"><code>$[]</code></td>
<td style="text-align:center">整数运算，并执行命令替换（将计算结果替换出来），过时</td>
</tr>
<tr>
<td style="text-align:center"><code>$&#39;string&#39;</code></td>
<td style="text-align:center">转义单引号中的字符串，支持 echo 的所有转义序列</td>
</tr>
</tbody>
</table>
<p><strong>逻辑运算符</strong></p>
<ul>
<li><code>&amp;&amp;</code>：逻辑与，二元操作符。<code>cmd1 &amp;&amp; cmd2</code>，只有 cmd1 返回 0 才执行 cmd2。</li>
<li><code>||</code>：逻辑或，二元操作符。<code>cmd1 || cmd2</code>，只有 cmd1 返回非 0 才执行 cmd2。</li>
<li><code>!</code>：逻辑非，一元操作符。<code>! cmd</code>，如果 cmd 返回 0 则该命令返回 1，否则返回 0。</li>
</ul>
<p>小技巧：利用 <code>&amp;&amp;</code>、<code>||</code> 来替代 <code>if</code>（命令很短时，这很有用）</p>
<ul>
<li><code>condition &amp;&amp; statement_if_true</code></li>
<li><code>condition || statement_if_false</code></li>
<li><code>condition &amp;&amp; statement_if_true || statement_if_false</code></li>
</ul>
<p>注意，<code>&amp;&amp;</code> 或 <code>||</code> 后面只能跟一个语句，如果有多个语句（分号隔开），那么只有第一个语句作为 statement 块，后面的语句都被视为正常语句，而非 statement 块。如果实在需要多条语句，可以使用匿名函数的语法（<code>{ statement1; statement2; ...; }</code>）。</p>
<p><strong>追加运算符</strong></p>
<ul>
<li><code>string+=newstr</code>：追加 newstr 子串至 string 字符串末尾。</li>
<li><code>array+=(element)</code>：追加 element 元素至 array 数组末尾。</li>
<li>shell 允许未定义 <code>string</code>、<code>array</code> 时使用 <code>+=</code> 追加运算符。</li>
</ul>
<p><strong>变量操作符</strong></p>
<ul>
<li><code>${variable:-default value}</code>：如果 variable 不存在或为空，则表达式返回 default value。</li>
<li><code>${variable:=default value}</code>：如果 variable 不存在或为空，则将 default value 赋值给它。</li>
<li><code>${variable:+alternate value}</code>：如果 variable 存在且不为空，则表达式返回 alternate value。</li>
<li><code>${variable:?error message}</code>：如果 variable 不存在或为空，则表达式报告 error message 错误并结束脚本。</li>
</ul>
<p><strong>文件转换符</strong></p>
<ul>
<li><code>cmd $(&lt;arg.dat)</code>：将 arg.dat 的文件内容作为 cmd 的命令行参数。</li>
<li><code>cmd &lt;(command)</code>：将 <code>&lt;(command)</code> 作为一个可读的文件参数，该文件的内容为 command 的标准输出。</li>
<li><code>cmd &gt;(command)</code>：将 <code>&gt;(command)</code> 作为一个可写的文件参数，写入的内容作为 command 的标准输入。</li>
</ul>
<p><strong>EOF 用法</strong></p>
<ul>
<li><code>cmd &lt;&lt;EOF</code>，以单独的 <code>EOF</code> 行结束：将输入的内容作为 cmd 的 stdin 数据，支持变量引用、命令替换。</li>
<li><code>cmd &lt;&lt;&#39;EOF&#39;</code>，以单独的 <code>EOF</code> 行结束：将输入的内容作为 cmd 的 stdin 数据，关闭变量引用、命令替换。</li>
<li><code>cmd &lt;&lt;&quot;EOF&quot;</code>，以单独的 <code>EOF</code> 行结束：将输入的内容作为 cmd 的 stdin 数据，关闭变量引用、命令替换。</li>
</ul>
<p><strong>参数转发</strong><br>如果你希望为一个命令添加自定义参数，可以考虑使用参数转发功能。比如 tomcat 的启动脚本 catalina.sh，原始脚本只提供 start|stop 等基本参数，我想添加一些自定义的参数，又不影响原有参数，可以吗？当然，在你处理完自定义参数后，只需执行 <code>catalina.sh &quot;$@&quot;</code>，表示将参数原模原样的传递给 catalina.sh，特别注意这个双引号，如果缺少，就不能处理参数中带空白符的情况了，也就失去了参数转发的意义。</p>
<p>没有双引号的情况：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
# root @ arch in ~/tomcat-apps/ROOT/test [16:19:26]
$ ls
forward.sh  showarg.sh

# root @ arch in ~/tomcat-apps/ROOT/test [16:19:27]
$ cat showarg.sh
#!/bin/bash
for arg in "$@"; do
    echo "$arg"
done

# root @ arch in ~/tomcat-apps/ROOT/test [16:19:31]
$ cat forward.sh
#!/bin/bash
exec ./showarg.sh $@

# root @ arch in ~/tomcat-apps/ROOT/test [16:19:33]
$ ./showarg.sh '1 2 3' 'a b c'
1 2 3
a b c

# root @ arch in ~/tomcat-apps/ROOT/test [16:19:48]
$ ./forward.sh '1 2 3' 'a b c'
1
2
3
a
b
c
</script></code></pre>
<p>加了双引号的情况：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">
# root @ arch in ~/tomcat-apps/ROOT/test [16:20:16]
$ cat forward.sh
#!/bin/bash
exec ./showarg.sh "$@"

# root @ arch in ~/tomcat-apps/ROOT/test [16:20:19]
$ ./showarg.sh '1 2 3' 'a b c'
1 2 3
a b c

# root @ arch in ~/tomcat-apps/ROOT/test [16:20:22]
$ ./forward.sh '1 2 3' 'a b c'
1 2 3
a b c
</script></code></pre>
<h2 id="特殊命令"><a href="#特殊命令" class="headerlink" title="特殊命令"></a>特殊命令</h2><p><code>:</code>，内建命令，它总是返回 0，并且不产生任何输出，因此经常用来清空文件；<br><code>true</code>，位于<code>/bin/true</code>，它和<code>:</code>一样，总是返回 0，并且不产生任何输出，通常用于 while 无限循环的测试条件；<br><code>false</code>，位于<code>/bin/false</code>，和<code>true</code>刚好相反，总是返回 1，并且不产生任何输出，暂时没有发现具体用途（开玩笑的）；<br><code>test</code>，位于<code>/bin/test</code>，通常用于 if 的条件测试；<br><code>[</code>，位于<code>/bin/[</code>，通常用于 if 的条件测试，但是它需要使用<code>]</code>来标识结尾；</p>
<p><strong>eval</strong><br>语法：<code>eval COMMAND</code>，用于执行 COMMAND 命令。</p>
<p>是不是觉得很奇怪，我难道不能直接运行 COMMAND 命令吗，为何要多此一举，加个 eval 呢？<br>确实。一般情况下，我们是用不到 eval 的，我们完全可以直接运行 COMMAND；<br>但是，有一种情况除外，我需要使用脚本动态生成命令并执行它，这时候 eval 就能大显身手了。</p>
<p>当然你可能会想，我不是可以使用<code>/bin/bash -c &quot;COMMAND&quot;</code>来执行命令吗，这不是一样可以做到动态生成命令并执行？<br>这种方式确实是可行的，但是如果 COMMAND 中有改变环境变量的语句呢？你用这种方式只会改变 sub-shell 的环境变量！</p>
<p>为了深入理解 eval，我们先来了解 shell 中命令的执行流程，在 shell 中，一个命令有 3 种写法：<br>1) 直接写<code>Normal Command</code>；2) 放在双引号中<code>&quot;Command&quot;</code>；3) 放在单引号中<code>&#39;Command&#39;</code>。区别如图：<br><img src="/images/shell-exec-cmd.png" alt="shell 执行命令的流程"></p>
<p>1) <strong>处理管道<code>|</code></strong><br>2) <strong>alias 替换</strong>，即将命令别名替换为真正的命令；<br>3) <strong>brace 替换</strong>，如将<code>ls {a,b}.txt</code>解析为<code>ls a.txt b.txt</code>；<br>4) <strong>~ 替换</strong>，将<code>~</code>替换为当前登录用户的家目录；<br>5) <strong>变量替换</strong>，即处理<code>${}</code>变量引用；<br>6) <strong>命令替换</strong>，即处理<code>$()</code>命令替换；<br>7) <strong>算数表达式运算</strong>，即处理<code>$(())</code>或<code>$[]</code>的内容；<br>8) <strong>glob 扩展</strong>，也就是 shell 通配符（<code>*</code>、<code>**</code>、<code>?</code>、<code>[]</code>、<code>[^]</code>）；<br>9) <strong>查找可执行文件</strong>，优先级依次降低：function、built-in、$PATH 变量；</p>
<p>放在单引号中的命令执行流程最为简单，直接查找命令，然后执行；而没有引号或双引号中的命令则会进行很多解析步骤。</p>
<p><strong>回到 eval</strong><br>上面我们了解了 shell 执行一个命令的具体流程和细节；很好，eval 也会进行一样的步骤，来解析一条命令！<br>因此，为了避免当前 shell 的解析与 eval 的二次解析出现混乱，我建议使用单引号将命令包围起来，即<code>eval &#39;cmd arg1 arg2 ...&#39;</code>。</p>
<p><strong>mktemp</strong><br><code>mktemp</code>，用于创建临时文件，并打印出 tmp 文件所在的路径，参数如下。</p>
<ul>
<li><code>-d</code>，创建临时文件夹而不是临时文件；</li>
<li><code>-u</code>，仅仅打印 tmp 文件的路径，而不创建（不安全）；</li>
<li><code>-q</code>，在创建文件失败或其他错误时，不输出错误信息；</li>
<li><code>--suffix=SUFF</code>，指定文件后缀；</li>
<li><code>-p</code>，指定文件夹，默认为<code>$TMPDIR</code>，如果该变量为空则使用<code>/tmp</code>目录；</li>
</ul>
<p><strong>cat、sed</strong><br>有时候我们从肉眼上很难区分 tab 和连续空格，不过我们可以借助 cat、sed 来区分：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain">$ echo -e 'www.zfl9.com\twww.baidu.com\nwww.zfl9.com    www.baidu.com'
www.zfl9.com    www.baidu.com
www.zfl9.com    www.baidu.com

$ echo -e 'www.zfl9.com\twww.baidu.com\nwww.zfl9.com    www.baidu.com' | sed -n 'l'
www.zfl9.com\twww.baidu.com$
www.zfl9.com    www.baidu.com$

$ cat --help
Usage: cat [OPTION]... [FILE]...
Concatenate FILE(s) to standard output.
With no FILE, or when FILE is -, read standard input.
  -n, --number             在每个输出行前打印行号
  -b, --number-nonblank    覆盖选项 -n，只显示非空行的行号（空行不计数）
  -s, --squeeze-blank      抑制重复空行的输出（缩减为一个空行）
  -E, --show-ends          显示行尾符 '$'
  -T, --show-tabs          显示制表符 '^I'
  -v, --show-nonprinting   显示不可打印字符 '^'、`M-`，除了 LFD、TAB
  -A, --show-all           等同于 -vET（不可打印字符、行尾符、制表符）
  -e                       等同于 -vE（不可打印字符、行尾符）
  -t                       等同于 -vT（不可打印字符、制表符）

$ echo -e 'www.zfl9.com\twww.baidu.com\nwww.zfl9.com    www.baidu.com'
www.zfl9.com    www.baidu.com
www.zfl9.com    www.baidu.com

$ echo -e 'www.zfl9.com\twww.baidu.com\nwww.zfl9.com    www.baidu.com' | cat -A
www.zfl9.com^Iwww.baidu.com$
www.zfl9.com    www.baidu.com$
</script></code></pre>
<p><strong>xxd、od</strong><br><code>xxd</code>和<code>od</code>都是 Linux 自带的二进制查看器；<code>xxd</code>支持二进制、十六进制；<code>od</code>支持八进制、十进制、十六进制。</p>
<p><code>xxd</code>命令，常用参数：</p>
<ul>
<li><code>-b</code>，以二进制格式查看文件内容，默认为十六进制；</li>
<li><code>-e</code>，以小端字节序显示（不建议），默认为大端字节序；</li>
<li><code>-g</code>，设置每个显示单位的长度（字节），默认为 2 字节；</li>
<li><code>-u</code>，以十六进制显示时，使用大写的 ABCDEF；</li>
<li><code>-i</code>，以 C 语言风格显示（十六进制，前缀 0x）；</li>
<li><code>-l</code>，只输出前 n 个字符；</li>
</ul>
<p><code>xxd</code>命令举例：<code>xxd -g1 /etc/resolv.conf</code>（十六进制）、<code>xxd -b /etc/resolv.conf</code>（二进制）。</p>
<p><code>od</code>命令，常用参数：</p>
<ul>
<li><code>-A</code>，指定地址进制，取值<code>[odxn]</code>，<code>o</code>八进制(default)、<code>d</code>十进制、<code>x</code>十六进制、<code>n</code>不显示地址栏；</li>
<li><code>-t</code>，指定输出格式，<code>c</code>ASCII字符、<code>oN</code>八进制，可指定单位长度 N、<code>xN</code>十六进制，可指定单位长度 N。</li>
</ul>
<p><code>od</code>命令举例：<code>od -An -to1 /etc/resolv.conf</code>（八进制）、<code>od -An -tc /etc/resolv.conf</code>（ASCII 字符 + 转义字符）。</p>
<p><strong>dirname、basename</strong><br><code>dirname path</code>：获取 path 路径字符串的<strong>父目录</strong>部分，如<code>dirname /a/b/c</code>输出<code>/a/b</code>、<code>dirname /a/b/c/</code>输出<code>/a/b</code>；<br><code>basename path</code>：获取 path 路径字符串的<strong>文件（目录）名</strong>，如<code>basename /a/b/c</code>输出<code>c</code>、<code>basename /a/b/c/</code>输出<code>c</code>。</p>
<p><strong>进入脚本所在目录</strong><br>比如，我要在脚本 A 中执行脚本 B，而脚本 B 与脚本 A 在同一个目录，该怎么做？假设 A 脚本为<code>A.sh</code>，B 脚本为<code>B.sh</code>。</p>
<p>初学者可能会使用<code>./B.sh</code>，但是，这条语句执行的是执行者所在目录下的 B 脚本，而并非与 A 脚本同一目录下的 B 脚本！除非 A 脚本就在当前目录下，否则执行到该语句时就会失败。</p>
<p>为什么？你还记得之前一直提的 sub-shell 吗？你启动了 A 脚本后，A 会继承当前 shell 的环境变量，而执行到<code>./B.sh</code>时，它会被 shell 解释器转换为<code>${PWD}/B.sh</code>，<code>${PWD}</code>是当前目录，而这个环境变量是继承自当前 shell 的，因此就会出错了！</p>
<p>因此，我们需要将<code>${PWD}</code>环境变量修改为脚本 A 所在的目录，而<code>cd</code>命令就会改变<code>${PWD}</code>环境变量。好，我们一步一步来：<br>1) 既然脚本 A 不在当前目录，那么我是怎么运行的呢？有两种方式：第一种，使用绝对路径来执行<code>/path/to/A.sh</code>；第二种，使用相对路径来执行<code>path/to/A.sh</code>；<br>2) 对于第一种情况，很简单，直接可以从<code>$0</code>变量中获取脚本的绝对路径；对于第二种情况，也简单，先从<code>$0</code>中获取相对路径，再使用 cd 进去就可以了；<br>3) 因此，我们可以使用这条命令<code>cd $(dirname $0)</code>；是不是很简单，它同时支持第一种和第二种情况，无论是绝对路径还是相对路径都能适应！</p>
<p><strong>pgrep</strong><br><code>pgrep</code>命令，可以理解为<code>processes grep</code>，也就是使用正则表达式来查找与进程相关的信息；<br>比如：<code>pgrep &#39;nginx&#39;</code>查找所有运行的 nginx 进程，并打印出它们的 PID；<code>pgrep -c &#39;nginx&#39;</code>不打印 PID，而是统计进程数目；</p>
<p><code>pgrep</code>的常用参数：</p>
<ul>
<li><code>-i</code>，忽略大小写；</li>
<li><code>-v</code>，反向匹配；</li>
<li><code>-c</code>，统计匹配到的数量；</li>
<li><code>-l</code>，显示 process_name（不带参数）；</li>
<li><code>-a</code>，显示 full_command_line（带启动参数）；</li>
<li><code>-w</code>，显示 TID（线程 ID）；</li>
<li><code>-d</code>，指定分隔符，默认为换行符；</li>
<li><code>-f</code>，使用 full_process_name 去匹配（带启动参数）；</li>
<li><code>-P</code>，查找给定 PPID（父进程 ID）下的进程；</li>
<li><code>-x</code>，只查找与 command_name 完全匹配的进程；</li>
<li><code>-o</code>，查找最先（oldest）启动的进程；</li>
<li><code>-n</code>，查找最后（newest）启动的进程；</li>
<li><code>-F</code>，从给定的 pid 文件中查找进程；</li>
</ul>
<p><strong>lsof</strong><br><code>lsof</code>即<code>list open files</code>，因为在 Unix 中一切皆文件，因此 lsof 支持查找<strong>普通文件</strong>、<strong>套接字文件</strong>等等；</p>
<p>使用详解：</p>
<ul>
<li><code>lsof</code>，显示系统打开的所有文件；</li>
<li><code>lsof filename</code>，显示打开了指定文件的进程；</li>
<li><code>lsof +d dirname</code>，显示指定目录下所有被打开的文件；</li>
<li><code>lsof +D dirname</code>，显示指定目录下所有被打开的文件（递归）；</li>
<li><code>lsof -c command</code>，显示指定进程打开的文件（根据名称）；</li>
<li><code>lsof -p pid</code>，显示指定进程打开的文件（根据 PID）；</li>
<li><code>lsof -u username/uid</code>，显示指定用户打开的文件；</li>
<li><code>lsof -g group_id</code>，显示指定用户组 ID 打开的文件；</li>
<li><code>lsof -d fd/type</code>，显示打开了指定 fd 的进程；</li>
<li><code>lsof -R</code>，显示父进程 PID（PPID）；</li>
<li><code>lsof -n</code>，显示 ip 而不是 hostname；</li>
<li><code>lsof -i [46][tcp|udp][@host|addr][:svc_name|port]</code>，按照给定条件查找；</li>
<li><code>lsof cond1 -a cond2</code>，加了 -a 参数说明须同时满足 cond1 和 cond2，默认为 OR 或。</li>
</ul>
<p>文件描述符：</p>
<ul>
<li>cwd：current work dirctory；</li>
<li>txt：program text (code and data)；</li>
<li>ltx：shared library text (code and data)；</li>
<li>mem：memory-mapped file；</li>
<li>mmap：memory-mapped device；</li>
<li>pd：parent directory；</li>
<li>rtd：root directory；</li>
<li>0u：标准输入文件</li>
<li>1u：标准输出文件</li>
<li>2u：标准错误文件</li>
</ul>
<p>文件状态：</p>
<ul>
<li>r：只读模式；</li>
<li>w：只写模式；</li>
<li>u：读写模式；</li>
<li>空格：文件状态未知且文件未被锁定；</li>
<li>-：文件状态未知且文件已被锁定；</li>
</ul>
<p>文件类型：</p>
<ul>
<li>IPv4：IPv4 套接字文件；</li>
<li>IPv6：IPv6 套接字文件；</li>
<li>unix：Unix 套接字文件；</li>
<li>BLK：块设备；</li>
<li>CHR：字符设备；</li>
<li>DIR：文件夹；</li>
<li>REG：普通文件；</li>
<li>LINK：符号链接文件；</li>
<li>FIFO：管道文件；</li>
</ul>
<p><strong>tail 进阶用法</strong></p>
<ul>
<li><code>tail -n3</code>：显示最后 3 行；</li>
<li><code>tail -n+2</code>：显示第 2 行至最后 1 行（从 1 开始）；</li>
<li><code>tail -c3</code>：显示最后 3 字节；</li>
<li><code>tail -c+2</code>：显示第 2 字节至最后 1 字节（从 1 开始）。</li>
</ul>
<p><strong>守护进程的启动方式</strong></p>
<ol>
<li><code>nohup command args... &lt;/dev/null &amp;&gt;&gt;/var/log/proc.log &amp;</code></li>
<li><code>setsid command args... &lt;/dev/null &amp;&gt;&gt;/var/log/proc.log</code></li>
<li><code>command args... &lt;/dev/null &amp;&gt;&gt;/var/log/proc.log &amp; disown</code></li>
<li><code>(command args... &lt;/dev/null &amp;&gt;&gt;/var/log/proc.log &amp;)</code>（推荐）</li>
</ol>
<h2 id="参数解析"><a href="#参数解析" class="headerlink" title="参数解析"></a>参数解析</h2><p>一般的 shell 脚本都不会有太复杂的命令行参数，这时候使用<code>$n</code>获取位置参数就足够了。<br>但是，有些时候需要解析一些比较复杂的命令行参数，这时候就需要 shift 和 getopts 了。</p>
<p><strong>shift</strong><br><code>shift</code>是 shell 的一个内建命令，常用于位置参数的解析；<br>shift 将所有位置参数（除<code>$0</code>）往前移动一个单位，即丢弃最前边的参数；<br>如：<code>shift 3</code>，往前移动三个位置、不带参数的<code>shift</code>则相当于<code>shift 1</code>。</p>
<p>最简单的用法，依次获取每个位置参数（当然，这只是演示一下 shift 的用法）</p>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~ [15:24:31]
$ cat test.sh
#!/bin/bash

echo "文件名: $0"

while [ $# -gt 0 ]; do
    echo "参数$((++i)): $1"
    shift
done

# root @ arch in ~ [15:24:37]
$ ./test.sh a b c d
文件名: ./test.sh
参数1: a
参数2: b
参数3: c
参数4: d
</script></code></pre>
<p><strong>getopts</strong><br>除了使用 shift，我们还可以使用 getopts 内建命令，它主要是模仿 C 库中的 getopt() 函数。</p>
<p>语法：<code>getopts optstring optname [arguments ...]</code><br>变量<code>$OPTIND</code>：选项所在的索引值，初始值为 1，它会自动递增；<br>变量<code>$OPTARG</code>：选项所附带的参数（如果有的话）。<br>其中，optstring 是选项字符串，用来定义如何处理选项；optname 是一个变量，用来存储捕获到的选项；如果没有 arguments，则从当前的位置参数解析，如果有 arguments，则从给定的 arguments 解析。</p>
<p><code>optstring</code>格式：<br>1) 如果选项后面没有<code>:</code>号，说明该选项后没有参数值；<br>2) 如果选项后面带有<code>:</code>号，说明该选项后需要提供参数，参数值存储在<code>$OPTARG</code>。</p>
<p>当 getopts 遇到<strong>未知选项</strong>、<strong>选项缺少参数</strong>的情况时：<br>1) 如果 optstring 以<code>:</code>开头，getopts 将不会输出默认的出错信息，而是交给我们自己来处理。并且，遇到未知选项时将<code>optname</code>设为<code>?</code>，遇到缺少参数时将<code>optname</code>设为<code>:</code>；<br>2) 如果 optstring 不以<code>:</code>开头，getopts 将输出默认的出错信息，并且不区分未知选项和缺少参数的情况，统一将<code>optname</code>设为<code>?</code>。</p>
<p>简单例子，演示了如何使用 getopts：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~ [17:01:07]
$ cat test.sh
#!/bin/bash

if [ $# -eq 0 ]; then
    echo "Usage ..." 1>&2   # 用法介绍
    exit 1
fi

while getopts ":s:p:m:k:b:l:uvh" OPT; do
    case $OPT in
        s) server_ip=$OPTARG;;
        p) server_port=$OPTARG;;
        m) method=$OPTARG;;
        k) passwd=$OPTARG;;
        b) bind_ip=$OPTARG;;
        l) listen_port=$OPTARG;;
        u) udp_relay=1;;
        v) verbose=1;;
        h) help=1;;
        :)  # 缺少参数
            echo "missing argument to '-$OPTARG'" 1>&2
            exit 1
            ;;
        \?) # 未知选项
            echo "unknown option '-$OPTARG'" 1>&2
            exit 1
            ;;
    esac
done

# TODO  程序主逻辑 ...

# root @ arch in ~ [17:01:10]
$ ./test.sh -s
missing argument to '-s'

# root @ arch in ~ [17:01:23] C:1
$ ./test.sh
Usage ...

# root @ arch in ~ [17:01:26] C:1
$ ./test.sh -y
unknown option '-y'

# root @ arch in ~ [17:01:31] C:1
$ ./test.sh -s server -p 5555 -m rc4-md5 -k password -b 0.0.0.0 -l 1080 -u -v
</script></code></pre>
<p><strong>在函数中使用 getopts</strong><br>因为<code>$OPTIND</code>变量每次都会自增，因此调用一次函数后，<code>$OPTIND</code>的值就不再是 1 了，再调用函数就会无法解析；<br>为了解决这个问题，我们可以在函数中定义一个与<code>$OPTIND</code>同名的 local 变量，并且将其初始值设为 1，就没有问题了。</p>
<h2 id="别名处理"><a href="#别名处理" class="headerlink" title="别名处理"></a>别名处理</h2><p>在交互式 shell(bash) 中，我们可以使用 <code>alias mycmd=&#39;command args...&#39;</code> 语法来创建一个 alias 别名，当我们执行 <code>mycmd</code> 命令时，实际上执行的是 <code>command args...</code> 命令，通常我们会为一个长命令创建一个短别名，方便使用。那么你有尝试过在 shell script 中使用 <code>alias</code> 指令吗？如果你尝试过，你可能已经知道，在 bash 脚本中，默认是不允许使用 alias 指令的，虽然这条指令不会报错，但是实际上是没有生效的，请看例子：</p>
<pre><code class="line-numbers language-bash">#!/bin/bash
alias sayhello=&#39;echo &quot;hello, world!&quot;&#39;
sayhello
</code></pre>
<pre><code class="line-numbers language-bash">$ ./alias.sh 
./alias.sh: line 3: sayhello: command not found
</code></pre>
<p>那么如果一定要在 shell script 中使用 alias 指令，该怎么办呢？简单，在脚本开头添加 <code>shopt -s expand_aliases</code> 命令即可：</p>
<pre><code class="line-numbers language-bash">#!/bin/bash
shopt -s expand_aliases
alias sayhello=&#39;echo &quot;hello, world!&quot;&#39;
sayhello
</code></pre>
<pre><code class="line-numbers language-bash">$ ./alias.sh 
hello, world!
</code></pre>
<h2 id="捕捉信号"><a href="#捕捉信号" class="headerlink" title="捕捉信号"></a>捕捉信号</h2><p>在 C/C++ 中我们可以使用 <code>signal()</code> 函数为某个信号注册一个处理函数，这样当我们的程序收到给定信号时，就会自动执行我们指定的处理函数，这在某些时候非常有用。那么我们能否在 shell 脚本中捕捉指定的信号，然后注册对应的处理函数呢？当然是可以的，使用内置命令 <code>trap</code> 即可，用法非常简单，<code>trap cmd_string signals...</code>，cmd_string 是对应的“处理函数”，可以是任何有效的 shell 语句，建议使用单引号或双引号包含 cmd_string，而 signals 是要捕捉的信号名称，如 <code>INT</code>（用户按下 Ctrl+C）、<code>TERM</code>（kill 的默认信号）等等，多个信号可使用空格隔开，也可以有多个 trap 语句，只要它们捕捉的信号不冲突就行。当 shell 进程捕捉到对应的信号后，会查找通过 trap 注册的处理语句（cmd_string），然后使用 <code>eval</code> 解析并执行我们传递给它的 <code>cmd_string</code>。例子：</p>
<pre><code class="line-numbers language-bash">#!/bin/bash

trap &#39;echo +$0+; exit&#39; INT
trap &#39;echo -$0-; exit&#39; TERM

while true; do
    echo &#39;hello, world&#39;
    sleep 1
done
</code></pre>
<p>添加可执行权限，然后执行脚本，当我们按下 Ctrl+C 组合键，就会执行 <code>echo +$0+; exit</code> 语句，也就是打印当前脚本名称然后退出脚本；当我们使用 <code>kill</code> 给该 shell 进程发送 TERM 信号时，脚本就会执行 <code>echo -$0-; exit</code> 语句，也是打印当前脚本名称然后退出脚本。</p>
<h2 id="脚本调试"><a href="#脚本调试" class="headerlink" title="脚本调试"></a>脚本调试</h2><p>除了使用 <code>shopt</code> 设置 shell options 外，我们还可以使用 <code>set</code> 命令来设置 bash 的一些 options，比如 <code>set -v</code> 表示启用脚本回显功能（即在执行一条命令前都会先打印一下），对应的，<code>set +v</code> 表示禁用脚本回显功能（默认就是禁用），总之你记住，<code>set -XXX</code> 就是启用某选项，而 <code>set +XXX</code> 就是禁用某选项。除了通过 set 命令来设置，我们也可以直接通过 bash 命令行选项来传递，比如 <code>bash -v /path/to/script.sh</code>，当然也可以直接在 script.sh 的脚本第一行加上 <code>-v</code> 选项，即 <code>#!/bin/bash -v</code>，不过有些时候我们只希望在脚本的指定位置启用一些选项，然后又关闭这些选项，这种情况下只能使用 <code>set -v</code>，比如只在某个函数中设置 -v 选项，就可以在函数第一行调用 <code>set -v</code> 来启用该选项，然后在函数最后一行调用 <code>set +v</code> 来关闭该选项，非常灵活和方便。</p>
<p><strong>脚本回显，打印当前执行的命令：<code>set -v</code></strong></p>
<pre><code class="line-numbers language-bash">#!/bin/bash -v
echo &quot;www.zfl9.com&quot;
echo &quot;www.baidu.com&quot;
echo &quot;www.google.com&quot;
</code></pre>
<pre><code class="line-numbers language-bash">$ ./test.sh 
#!/bin/bash -v
echo &quot;www.zfl9.com&quot;
www.zfl9.com
echo &quot;www.baidu.com&quot;
www.baidu.com
echo &quot;www.google.com&quot;
www.google.com
</code></pre>
<p><strong>调试脚本，比 <code>set -v</code> 更详细：<code>set -x</code></strong></p>
<pre><code class="line-numbers language-bash">#!/bin/bash -x
echo &quot;www.zfl9.com&quot;
echo &quot;www.baidu.com&quot;
echo &quot;www.google.com&quot;
</code></pre>
<pre><code class="line-numbers language-bash">$ ./test.sh 
+ echo www.zfl9.com
www.zfl9.com
+ echo www.baidu.com
www.baidu.com
+ echo www.google.com
www.google.com
</code></pre>
<p><strong>严格模式，只要有一个命令返回值非 0 就结束运行：<code>set -e</code></strong></p>
<pre><code class="line-numbers language-bash">#!/bin/bash -e
ech0
echo &quot;www.zfl9.com&quot;
echo &quot;www.baidu.com&quot;
echo &quot;www.google.com&quot;
</code></pre>
<pre><code class="line-numbers language-bash">$ ./test.sh 
./test.sh: line 2: ech0: command not found
</code></pre>
<p><strong><code>set -u</code>，当尝试读取未定义的 shell 变量时，将直接结束运行</strong></p>
<pre><code class="line-numbers language-bash">#!/bin/bash -u
echo &quot;$string&quot;
echo &quot;hello, world&quot;
</code></pre>
<pre><code class="line-numbers language-bash">$ ./test.sh   
./test.sh: line 2: string: unbound variable
</code></pre>
<p><strong><code>set -eo pipefail</code>，如果管道命令的某个子命令返回非 0 则结束运行</strong></p>
<blockquote>
<p>注意单独设置 <code>set -o pipefail</code> 是没效果的，要和 <code>set -e</code> 一起使用才有效果。</p>
</blockquote>
<pre><code class="line-numbers language-bash">#!/bin/bash
set -eo pipefail
foobar | echo &quot;pipe&quot;
echo &quot;hello, world&quot;
</code></pre>
<pre><code class="line-numbers language-bash">$ ./test.sh 
pipe
./test.sh: line 3: foobar: command not found
</code></pre>
<p><strong>个人习惯在 shell 脚本开头加上这几行，可以极大的提高脚本的健壮性</strong></p>
<pre><code class="line-numbers language-bash">#!/bin/bash
set -o nounset
set -o errexit
set -o pipefail
shopt -s expand_aliases
</code></pre>
    </div>
    <div>
    </div>
    <div>
    </div>
    <div>
    </div>
    <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/linux/" rel="tag"># linux</a>
            <a href="/tags/shell/" rel="tag"># shell</a>
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/trash-cli.html" rel="next" title="trash-cli 逃离 rm -rf 阴影">
                <i class="fa fa-chevron-left"></i> trash-cli 逃离 rm -rf 阴影
              </a>
          </div>
          <span class="post-nav-divider"></span>
          <div class="post-nav-prev post-nav-item">
              <a href="/java-zip.html" rel="prev" title="Java Zip压缩">
                Java Zip压缩 <i class="fa fa-chevron-right"></i>
              </a>
          </div>
        </div>
    </footer>
  </article>
    <div class="post-spread">
    </div>
  </div>
          </div>
  <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer" target="_blank">comments powered by Disqus.</a>
        </noscript>
      </div>
  </div>
        </div>
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>
  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Otokaze">
          <p class="site-author-name" itemprop="name">Otokaze</p>
              <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">170</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
        </nav>
        <div class="links-of-author motion-element">
              <span class="links-of-author-item">
                <a href="https://github.com/zfl9" target="_blank" title="GitHub rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-github"></i>
                  GitHub
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="mailto:zfl9.com@gmail.com" target="_blank" title="Email rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-envelope"></i>
                  Email
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://gitlab.com/zfl9" target="_blank" title="GitLab rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-gitlab"></i>
                  GitLab
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://t.me/Otokaze" target="_blank" title="Telegram rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-telegram"></i>
                  Telegram
                </a>
              </span>
        </div>
      </section>
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#入门"><span class="nav-number">1.</span> <span class="nav-text">入门</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#变量"><span class="nav-number">2.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#数组"><span class="nav-number">3.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#位置参数"><span class="nav-number">4.</span> <span class="nav-text">位置参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符"><span class="nav-number">5.</span> <span class="nav-text">运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#echo"><span class="nav-number">6.</span> <span class="nav-text">echo</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#printf"><span class="nav-number">7.</span> <span class="nav-text">printf</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#流程控制"><span class="nav-number">8.</span> <span class="nav-text">流程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#函数"><span class="nav-number">9.</span> <span class="nav-text">函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重定向"><span class="nav-number">10.</span> <span class="nav-text">重定向</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道"><span class="nav-number">11.</span> <span class="nav-text">管道</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件包含"><span class="nav-number">12.</span> <span class="nav-text">文件包含</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通配符"><span class="nav-number">13.</span> <span class="nav-text">通配符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊符号"><span class="nav-number">14.</span> <span class="nav-text">特殊符号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#特殊命令"><span class="nav-number">15.</span> <span class="nav-text">特殊命令</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参数解析"><span class="nav-number">16.</span> <span class="nav-text">参数解析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#别名处理"><span class="nav-number">17.</span> <span class="nav-text">别名处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#捕捉信号"><span class="nav-number">18.</span> <span class="nav-text">捕捉信号</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#脚本调试"><span class="nav-number">19.</span> <span class="nav-text">脚本调试</span></a></li></ol></div>
          </div>
        </section>
      <!--/noindex-->
    </div>
  </aside>
      </div>
    </main>
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Otokaze</span>
</div>
<script src="/js/clipboard.min.js"></script>
<script src="/js/prism/prism.js" async></script>
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
  </div>
<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>
      <script id="dsq-count-scr" src="https://otokaze.disqus.com/count.js" async></script>
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://www.zfl9.com/shell-script.html';
          this.page.identifier = 'shell-script.html';
          this.page.title = 'Shell - 脚本编程';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://otokaze.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("3hhdw6gOg9wavsharVwVjqI3-gzGzoHsz", "O5WfDffqFsgmAVPwNY9of3QU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");
      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });
      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';
          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);
            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);
      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }
    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</body>
</html>
