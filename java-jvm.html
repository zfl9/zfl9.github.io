<!doctype html>
<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">
<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">
<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">
  <meta name="keywords" content="Java 深入理解 JVM 虚拟机">
  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1">
<meta name="description" content="Java 深入理解 JVM 虚拟机，初识 JVM、JVM 内存模型、JVM 类加载机制、Java 对象的访问方式、Java 内存分配机制、GC 机制&amp;amp;算法">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 深入理解 JVM 虚拟机">
<meta property="og:url" content="https://www.zfl9.com/java-jvm.html">
<meta property="og:site_name" content="Otokaze's Blog">
<meta property="og:description" content="Java 深入理解 JVM 虚拟机，初识 JVM、JVM 内存模型、JVM 类加载机制、Java 对象的访问方式、Java 内存分配机制、GC 机制&amp;amp;算法">
<meta property="og:image" content="https://www.zfl9.com/images/java-memory.png">
<meta property="og:image" content="https://www.zfl9.com/images/java-memory-2.jpg">
<meta property="og:image" content="https://www.zfl9.com/images/java-memory-3.png">
<meta property="og:image" content="https://www.zfl9.com/images/java-memory-4.png">
<meta property="og:image" content="https://www.zfl9.com/images/java-classload.png">
<meta property="og:image" content="https://www.zfl9.com/images/java-classloader.png">
<meta property="og:image" content="https://www.zfl9.com/images/java-obj-access-1.png">
<meta property="og:image" content="https://www.zfl9.com/images/java-obj-access-2.png">
<meta property="og:image" content="https://www.zfl9.com/images/java-heap-gen.jpg">
<meta property="og:image" content="https://www.zfl9.com/images/jvm-metaspace.jpg">
<meta property="og:image" content="https://www.zfl9.com/images/java-gc-root.jpg">
<meta property="og:image" content="https://www.zfl9.com/images/jvm-gc.jpg">
<meta property="og:image" content="https://www.zfl9.com/images/jvm-cms.png">
<meta property="og:image" content="https://www.zfl9.com/images/jvm-g1.jpg">
<meta property="og:image" content="https://www.zfl9.com/images/jvm-jpda.jpg">
<meta property="og:image" content="https://www.zfl9.com/images/jvm-jpda-jdb.jpg">
<meta property="og:updated_time" content="2019-02-18T12:48:31.257Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java 深入理解 JVM 虚拟机">
<meta name="twitter:description" content="Java 深入理解 JVM 虚拟机，初识 JVM、JVM 内存模型、JVM 类加载机制、Java 对象的访问方式、Java 内存分配机制、GC 机制&amp;amp;算法">
<meta name="twitter:image" content="https://www.zfl9.com/images/java-memory.png">
<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
  <link rel="canonical" href="https://www.zfl9.com/java-jvm.html">
<link href="/js/prism/prism.css" rel="stylesheet">
  <title>Java 深入理解 JVM 虚拟机 | Otokaze's Blog</title>
</head>
<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-97872912-1', 'auto');
  ga('send', 'pageview');
</script>
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3d58f51dbb2496a0e6d17b85065a5ae5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Otokaze's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">拼一年春夏秋冬，搏一生无怨无悔</h1>
  </div>
  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>
<nav class="site-nav">
    <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            首页
          </a>
        </li>
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            分类
          </a>
        </li>
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            标签
          </a>
        </li>
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            归档
          </a>
        </li>
    </ul>
</nav>
 </div>
    </header>
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
  <div id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.zfl9.com/java-jvm.html">
    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Otokaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>
    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Otokaze's Blog">
    </span>
      <header class="post-header">
          <h2 class="post-title" itemprop="name headline">
                Java 深入理解 JVM 虚拟机
          </h2>
        <div class="post-meta">
          <span class="post-time">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
                <span class="post-meta-item-text">发表于</span>
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-23T18:11:00+08:00">
                2017-09-23
              </time>
          </span>
            <span class="post-category">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
                <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/java-jvm.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="java-jvm.html" itemprop="commentCount"></span>
                </a>
              </span>
             <span id="/java-jvm.html" class="leancloud_visitors" data-flag-title="Java 深入理解 JVM 虚拟机">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
                 <span class="post-meta-item-text">阅读次数 </span>
                 <span class="leancloud-visitors-count"></span>
             </span>
        </div>
      </header>
    <div class="post-body" itemprop="articleBody">
        <p>Java 深入理解 JVM 虚拟机，初识 JVM、JVM 内存模型、JVM 类加载机制、Java 对象的访问方式、Java 内存分配机制、GC 机制&amp;算法</p>
<a id="more"></a>
<h2 id="JVM-和-Java"><a href="#JVM-和-Java" class="headerlink" title="JVM 和 Java"></a>JVM 和 Java</h2><p><strong>JVM</strong><br>JVM，全称 Java Virtual Machine，即 Java 虚拟机。虽然自称为虚拟机，但是 JVM 和 VMware 还是有区别的：</p>
<ul>
<li>JVM：只能运行 Java 字节码（Java bytecode）的虚拟机，不能像其它虚拟机一样，模拟真实的硬件环境；</li>
<li>VMware：可模拟真实的硬件环境（X86），在该环境中可以无障碍的安装任何（几乎）操作系统，功能强大。</li>
</ul>
<p>可以这么说，VMware 提供的虚拟化环境对于运行在其上面的操作系统、应用软件都是透明的，我们可以将一个正常运行在实体机上的软件不经修改的运行在 VMware 环境中；但是 JVM 却不行，它只能运行字节码文件，如果要想在 JVM 上运行程序，必须遵循 JVM 的特有指令集规范，否则是无法正常运行的，也就是说，JVM 对于运行在其上的软件来说是不具备透明性的。</p>
<p>因此如果想使用 JVM 来运行你的程序，就必须生成指定的字节码文件（和可执行文件差不多的概念，只不过是相对 JVM 平台来说的）。</p>
<p><strong>Java</strong><br>Java 只是一个基于 JVM 的编程语言，和 JVM 是不同的两个概念，JVM 是一个平台，除了 Java 外，还有其它的基于 JVM 的编程语言，如 BBj、BeanShell、Ceylon、Clojure、Fantom、Kotlin、Groovy、MIDletPascal、Scala、Xtend。不过，因为 Java 是 JVM 的亲儿子，因此很多时候都对它有特别的照顾。</p>
<p><strong>JRE、JDK</strong><br>JRE，全称 Java Runtime Environment，即 Java 运行时环境。JRE 主要提供两个东西：一是<code>java</code>可执行文件，即 JVM 虚拟机，用来执行字节码的；二是<code>rt.jar</code>以及其它基础类库，单单有一个 JVM 还是不行的，必须要有一个类库，提供最基本的环境支持（比如 String、System、Runtime 类等等），方便 Java 以及其它基于 JVM 的语言调用。</p>
<p>JDK，全称 Java Development Kit，即 Java 开发工具包。JDK 一般自带一个对应的 JRE 环境，除此之外，它主要提供的就是 Java 语言开发工具，如<code>javac</code>Java 编译器，将源码编译为字节码、<code>jdb</code>Java 调试器，调试 Java 程序用的、<code>javadoc</code>Java 文档生成器，比如 Oracle 的 Java 类库文档就是使用 javadoc 生成的。</p>
<p>因此，如果你是开发者，就必须安装 JDK；如果你只是想运行 Java 程序，则只需要安装 JRE。Oracle 官方都有提供相应的下载。</p>
<p><strong>Java 是跨平台的，但 JVM 不是</strong><br>我们都知道 Java 是跨平台的，可以实现”一次编译，到处运行”的目的。但是，跨平台的仅仅是 Java 程序（准确地说，应该是 Java 字节码文件），但是 JVM 虚拟机并不是跨平台的，每个平台都有其特定的 JVM 程序，比如 Windows 版的 JVM 就不可以在 Linux 环境下运行，反之也是。</p>
<p>其实很好理解，所谓的字节码文件，就和一个普通的文本文件一样，只不过字节码文件是不可阅读的，一个普通的文件当然是跨平台的了，而 JVM 虚拟机其实就是一个普通的可执行文件，在不同的系统之间当然是不兼容的，如果可以的话，那么 C/C++ 编译的程序也是跨平台的了（╮(╯_╰)╭）。</p>
<p>比如，我们要执行一个 Java 程序一般要经过两个步骤：</p>
<ol>
<li><code>javac HelloWorld.java</code>，使用 javac 编译器将 Java 源码文件编译成 Java 字节码文件（HelloWorld.class）；</li>
<li><code>java HelloWorld</code>，启动 JVM 虚拟机，然后 JVM 开始解释运行（JIT 即时编译）字节码文件，执行完毕后退出。</li>
</ol>
<p>JVM 和一个普通的可执行文件没有任何区别，在操作系统的层次上讲，并不会对 JVM 有特殊照顾；JVM 有自己的进程空间，和一般的可执行文件一样，分为<code>text</code>、<code>data</code>、<code>bss</code>、<code>heap</code>、<code>stack</code>，heap 和 stack 区域是运行时存在的。</p>
<p>因此，当我们在 shell 中执行<code>java HelloWorld</code>时，经过的步骤有：</p>
<ol>
<li>当前 shell 进程执行 fork() 系统调用，创建一个新的子进程，该新进程拥有属于自己的 PID；</li>
<li>新进程执行 exec() 系统调用（传入 HelloWorld 参数），载入 java 可执行文件，开始执行它的 main() 函数。</li>
</ol>
<p><strong>JVM/Java 版本历史</strong></p>
<ul>
<li>1995年5月23日，Java语言诞生</li>
<li>1996年1月，第一个JDK-JDK1.0诞生</li>
<li>1996年4月，10个最主要的操作系统供应商申明将在其产品中嵌入JAVA技术</li>
<li>1996年9月，约8.3万个网页应用了JAVA技术来制作</li>
<li>1997年2月18日，JDK1.1发布</li>
<li>1997年4月2日，JavaOne会议召开，参与者逾一万人，创当时全球同类会议规模之纪录</li>
<li>1997年9月，JavaDeveloperConnection社区成员超过十万</li>
<li>1998年2月，JDK1.1被下载超过2,000,000次</li>
<li>1998年12月8日，JAVA2企业平台J2EE发布</li>
<li>1999年6月，SUN公司发布Java的三个版本：标准版（J2SE）、企业版（J2EE）和微型版（J2ME）</li>
<li>2000年5月8日，JDK1.3发布</li>
<li>2000年5月29日，JDK1.4发布</li>
<li>2001年6月5日，NOKIA宣布，到2003年将出售1亿部支持Java的手机</li>
<li>2001年9月24日，J2EE1.3发布</li>
<li>2002年2月26日，J2SE1.4发布，自此Java的计算能力有了大幅提升</li>
<li>2004年9月30日18:00PM，J2SE1.5发布，成为Java语言发展史上的又一里程碑。为了表示该版本的重要性，J2SE1.5更名为Java SE 5.0</li>
<li>2005年6月，JavaOne大会召开，SUN公司公开Java SE 6。此时，Java的各种版本已经更名，以取消其中的数字“2”：J2EE更名为Java EE，J2SE更名为Java SE，J2ME更名为Java ME</li>
<li>2006年12月，SUN公司发布JRE6.0</li>
<li>2009年12月，SUN公司发布Java EE 6</li>
<li>2010年11月，由于Oracle公司对于Java社区的不友善，因此Apache扬言将退出JCP[14]</li>
<li>2011年7月28日，Oracle公司发布Java SE 7</li>
<li>2014年3月18日，Oracle公司发表Java SE 8</li>
<li>2017年9月21日，Oracle公司发表Java SE 9</li>
</ul>
<p><strong>JVM Server/Client 模式区别</strong></p>
<pre><code class="language-java line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [14:19:23]
$ java -version
java version "1.8.0_144"
Java(TM) SE Runtime Environment (build 1.8.0_144-b01)
Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)
</script></code></pre>
<p>注意第三行的输出，Server VM，表示当前 JVM 的默认模式是 Server 模式。<br>1) <code>Client模式</code>：启动速度快，运行速度慢；<br>2) <code>Server模式</code>：启动速度慢，运行速度快。</p>
<p>对于 32 位平台，可以通过配置<code>$JAVA_HOME/jre/lib/i386/jvm.cfg</code>文件切换默认模式；<br>对于 64 位平台，只能使用 Server 模式，Client 模式已经不存在了，不能切换为 Client 模式。</p>
<p>而现在大多数服务器都是 64 位的（不明白现在用 32 位还有什么意义），因此可以不用管什么 Client/Server 模式。</p>
<h2 id="JVM-运行时数据区"><a href="#JVM-运行时数据区" class="headerlink" title="JVM 运行时数据区"></a>JVM 运行时数据区</h2><p><img src="/images/java-memory.png" alt="JVM 运行时数据区"><br><img src="/images/java-memory-2.jpg" alt="JVM 运行时数据区"></p>
<p>JVM 运行时数据区被划分为 5 个部分：</p>
<ol>
<li><strong>虚拟机栈<code>VM Stack</code></strong>：执行 Java 方法的内存区域。每次方法调用都会创建一个新的<code>栈帧</code>结构，栈帧包含<strong>局部变量表</strong>、<strong>操作数栈</strong>、<strong>动态链接</strong>、<strong>返回地址</strong>等信息，该区域是线程私有的；</li>
<li><strong>本地方法栈<code>Native Method Stack</code></strong>：执行 Native 方法的内存区域。每次方法调用都会创建一个新的<code>栈帧</code>结构，具体的数据结构并没有强制规定，各厂商可以自由实现，HotSpot 将虚拟机栈和本地方法栈放在一起，不进行区分，该区域是线程私有的；</li>
<li><strong>程序计数器<code>Program Counter</code></strong>：记录当前线程正在执行的字节码地址的内存区域。当线程正在执行一个本地方法时，该计数器的值为空（Undefined，未定义的），此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何<code>OutOfMemoryError</code>的区域，该区域是线程私有的；</li>
<li><strong>堆<code>Heap</code></strong>：用于存储绝大多数的对象以及数组（数组也是对象）。是运行时数据区中最大的一块区域，也是 GC（垃圾回收器）的主战场，该区域是线程共享的；</li>
<li><strong>方法区<code>Method Area</code></strong>：存放方法的代码、已加载的类信息、静态变量、JIT 即时编译器编译后的代码等。同时 JVM 还会为每个已加载的类维护一个<strong>运行时常量池</strong>，常量池是可以动态扩展的，用于存储<strong><code>final</code>静态常量</strong>、<strong>字面量</strong>（整型字面量、浮点型字面量、字符串字面量等）、<strong>符号引用</strong>（即还未链接的偏移地址，有三类：类和接口的全限定名、字段的名称和修饰符、方法的名称和修饰符），方法区也是线程共享的。</li>
</ol>
<blockquote>
<p><code>java.lang.Class</code>对象存储在堆区，不是在方法区！一个类的 Class 对象是由加载它的 ClassLoader 创建的！Class 对象提供了访问对应类的方法区数据结构的接口。</p>
</blockquote>
<p><strong>详细介绍</strong><br><img src="/images/java-memory-3.png" alt="JVM 运行时内存区域"></p>
<p><strong>程序计数器</strong><br><code>程序计数器</code>是当前线程所执行的字节码地址指示器。每个线程都有自己计数器，是私有内存空间，该区域是整个内存中较小的一块。当线程正在执行一个 Java 方法时，PC 计数器记录的是<strong>正在执行</strong>的虚拟机字节码地址；当线程正在执行的一个 Native 方法时，PC 计数器则为<code>空（Undefined）</code>。</p>
<blockquote>
<p>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何<code>OutOfMemoryError</code>情况的区域。</p>
</blockquote>
<p><strong>虚拟机栈</strong><br><code>虚拟机栈</code>的生命周期与线程相同，是 Java 方法执行的内存模型。每个 Java 方法执行的同时都会创建一个<code>栈帧结构</code>，方法执行过程，对应着虚拟机栈的入栈到出栈的过程。</p>
<blockquote>
<p>如果线程请求的空间过大（超过设置的最大值），则抛出<code>StackOverflowError</code>栈溢出错误；如果线程在申请一个新的栈帧时（未超过设置的最大值）没有足够的内存可分配了，则抛出<code>OutOfMemoryError</code>内存溢出错误。</p>
</blockquote>
<p><code>栈帧（Stack Frame）的结构</code><br>每次方法调用都会产生一个新的栈帧结构并被压至栈顶。当方法正常返回或者调用过程中抛出未捕获的异常时，栈帧将出栈。每个栈帧包含：</p>
<ul>
<li>局部变量表：存储方法执行过程中所有的局部变量的数组，包括 this 引用、所有方法参数、其它局部变量。如果是静态方法，则没有 this 引用。局部变量的类型有：<ul>
<li><code>boolean</code>：布尔值</li>
<li><code>byte</code>：字节</li>
<li><code>char</code>：字符</li>
<li><code>short</code>：短整型</li>
<li><code>int</code>：整形</li>
<li><code>long</code>：长整型</li>
<li><code>float</code>：单精度浮点型</li>
<li><code>double</code>：双精度浮点型</li>
<li><code>reference</code>：引用类型<br>除了<code>long</code>、<code>double</code>外，其它类型都占有局部变量数组的一个 Slot 空间，long、double 则占有两个连续的 Slot 空间，因为它们是 64 位双精度的。</li>
</ul>
</li>
<li>操作数栈：所谓的操作数栈其实就是对原生<strong>CPU 寄存器</strong>的抽象，可以理解为方法的工作现场。</li>
<li>动态链接：一个指向当前方法所属类的运行时常量池的指针（引用）。常量池中有大量的符号引用，这些符号引用会在类加载阶段或第一次使用时被转换为直接引用（替换为相对偏移地址），在类加载并校验通过后进行解析的方式称为<code>饥饿方式</code>，在第一次使用时进行解析的方式被称为<code>惰性方式</code>。将符号引用替换为直接引用的过程被称为<code>绑定</code>，在编译期间进行绑定被称为<code>静态绑定</code>，在运行期间进行绑定被称为<code>动态绑定</code>。</li>
<li>返回地址：方法每调用一次，就会产生一个新的栈帧结构，当该方法返回时，当前线程是怎么知道下一条要执行的字节码地址的呢？答案是通过方法的返回地址。调用一个函数之前，线程会先在当前栈帧的栈顶压入函数调用的下一条指令地址，然后才会压入新的栈帧，并开始执行被调用函数的第一条指令，当被调用函数返回时，它所在的栈帧被弹出，这时下一条指令地址被暴露在了当前栈帧的顶部，因此线程开始继续执行当前函数的下一条指令。</li>
</ul>
<p><strong>本地方法栈</strong><br><code>本地方法栈</code>是虚拟机为 Native 方法提供的内存空间，具体的栈帧结构并未强制规定，由虚拟机自行发挥，有些虚拟机的实现直接把本地方法栈和虚拟机栈合二为一，比如我们常用的 HotSpot 虚拟机。</p>
<blockquote>
<p>如果线程请求的空间过大（超过设置的最大值），则抛出<code>StackOverflowError</code>栈溢出错误；如果线程在申请一个新的栈帧时（未超过设置的最大值）没有足够的内存可分配了，则抛出<code>OutOfMemoryError</code>内存溢出错误。</p>
</blockquote>
<p><strong>堆 Heap</strong><br>堆是 JVM 管理的最大的一块内存，也是 GC 的主战场，里面存放的是几乎所有的对象实例和数组数据。为什么说是几乎所有的对象呢？因为 JIT 编译器有栈上分配、标量替换等优化技术的实现导致部分对象实例数据不存在 Java 堆，而是栈内存。此处不考虑这些优化手段，我们依旧认为对象是存储在堆上的。</p>
<ul>
<li><code>内存回收</code>角度，Java 堆被分为<code>新生代</code>和<code>年老代</code>；这样划分的好处是为了更快的回收内存，提高 GC 效率；</li>
<li><code>内存分配</code>角度，Java 堆可以划分出<strong>线程私有</strong>的<code>分配缓冲区(Thread Local Allocation Buffer,TLAB)</code>；这样划分的好处是为了更快的分配内存，避免锁的争用（CAS 重试）。</li>
</ul>
<p>Java 对象的具体结构如图所示：<br><img src="/images/java-memory-4.png" alt="Java 堆中实例对象的存储结构图"></p>
<p>填充数据不一定存在，仅仅是为了字节对齐：HotSpot VM 的自动内存管理要求对象起始地址必须是 8 字节的整数倍；对象头本身是 8 的倍数，当对象的实例数据不是 8 的倍数，便需要填充数据来保证 8 字节的对齐，该功能类似于高速缓存行的对齐。</p>
<p>另外，在堆上的内存分配是<strong>并发进行</strong>的，虚拟机采用 CAS 加失败重试保证原子操作，或者是采用每个线程预先分配 TLAB 内存。</p>
<blockquote>
<p>如果对象占用的内存过大（如超大数组），则 JVM 会抛出<code>OutOfMemoryError</code>内存溢出错误，导致 Java 程序被意外终止。</p>
</blockquote>
<p><strong>方法区</strong><br><code>方法区</code>存放的是已加载的<code>方法代码</code>、<code>类信息</code>、<code>静态变量</code>、JIT 编译器编译后的<code>临时代码</code>等数据。GC 在该区域出现的比较少，因为在此区域执行 GC 的效率很低，因此也被称为<strong>永久代</strong>（HotSpot 专有概念，JDK1.8 中被<code>Metaspace</code>元空间给替代）。</p>
<blockquote>
<p>如果加载的类过多而当前堆内存又不足，则 JVM 会抛出<code>OutOfMemoryError</code>内存溢出错误，导致 Java 程序被意外终止。</p>
</blockquote>
<p><strong>运行时常量池</strong><br><code>运行时常量池</code>是方法区的一部分，用于存放<code>final静态常量</code>、<code>字面量</code>和<code>符号引用</code>。同时还可以在运行期间，将新的常量加入常量池中，应用比较多的就是 String 类的 intern() 方法和各大整型包装类的 valueOf() 方法。</p>
<ul>
<li><code>final静态常量</code>：即被 final 修饰的静态成员变量；</li>
<li><code>字面量</code>：如字符串字面量、整型字面量、浮点型字面量；</li>
<li><code>符号引用</code>：符号引用在被使用之前都会被替换为直接引用，符号引用有 3 类：<code>类和接口的全限定名</code>、<code>字段的名称和描述符</code>、<code>方法的名称和描述符</code>。</li>
</ul>
<h2 id="JVM-类加载机制"><a href="#JVM-类加载机制" class="headerlink" title="JVM 类加载机制"></a>JVM 类加载机制</h2><p><strong>类加载机制</strong><br>定义：把描述类的数据从<code>*.class</code>文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型。</p>
<p>类的<strong>加载</strong>、<strong>连接</strong>、<strong>初始化</strong>过程都是在程序运行期间完成的，这种策略虽然会令类加载时稍微增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点来实现的。</p>
<p><strong>类的生命周期</strong><br><code>加载</code>、<code>验证</code>、<code>准备</code>、<code>解析</code>、<code>初始化</code>、<code>使用</code>、<code>卸载</code>七个阶段。其中<code>验证</code>，<code>准备</code>，<code>解析</code> 3 个部分统称为连接。<br><img src="/images/java-classload.png" alt="JVM 类的七个阶段"></p>
<p><strong>触发类加载的条件</strong></p>
<ul>
<li>遇到<code>new</code>、<code>getstatic</code>、<code>putstatic</code>或<code>invokestatic</code>这 4 条字节码指令时，如果类没有进行过初始化，则需要先触发初始化。生成这 4 条指令的最常见的 Java 代码场景是：<strong>使用 new 关键字实例化对象的时候</strong>，<strong>读取或设置一个类的静态字段的时候（被<code>final</code>修饰，已在编译期把结果放入常量池的静态字段除外）</strong>，以及<strong>调用一个类的静态方法的时候</strong>。</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候。</li>
<li>当初始化一个类的时候，发现其父类还没有进行过初始化，则需要先出发父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含 main() 方法的那个类），虚拟机会先初始化这个主类。</li>
</ul>
<p><strong>类加载的具体过程</strong><br><strong>加载</strong></p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流；</li>
<li>将这个字节流所代表的静态存储结构转换为方法区内的运行时数据结构；</li>
<li>在堆中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<p><strong>验证</strong><br>验证是连接阶段的第一步，目的是为了确保 class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证包含 4 个阶段的校验动作：</p>
<ol>
<li>文件格式验证：验证字节流是否符合 class 文件格式的规范，并且能被当前版本的虚拟机处理；</li>
<li>元数据验证：对类的元数据信息进行语义校验，是否不存在不符合 Java 语言规范的元数据信息；</li>
<li>字节码验证：最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的，符合逻辑的。对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件；</li>
<li>符号引用验证：最后一个阶段的校验发生在虚拟机将符号引用转换为直接引用的时候，这个转换动作将在连接的第三个阶段——解析阶段中发生，符号验证的目的是确保解析动作能正常进行。</li>
</ol>
<p><strong>准备</strong><br>准备阶段是正式<strong>为<code>类变量</code>分配内存并设置类变量初始值</strong>的阶段。这些变量所使用的内存都将在方法区中分配。只包括类变量。初始值“通常情况”下是数据类型的零值。“特殊情况”下，如果类字段的字段属性表中存在 ConstantValue 属性（即 final 常量），那么在准备阶段变量的值就会被初始化为 ConstantValue 属性所指定的值。</p>
<p><strong>解析</strong><br>解析是虚拟机将常量池内的<strong>符号引用替换为直接引用</strong>的过程。符号引用就是 class 文件中的<code>CONSTANT_Class_info</code>、<code>CONSTANT_Field_info</code>、<code>CONSTANT_Method_info</code>等类型的常量。解析也被称为绑定，像这种在类加载期间进行解析的行为叫做<code>动态绑定</code>，而如果是在编译期间进行解析的则被称为<code>静态绑定</code>；并且，JVM 可以自由选择解析的时机，如果是在类加载并校验通过后进行解析则为<code>饥饿方式</code>，如果是在该符号引用第一次被使用时进行解析则为<code>惰性方式</code>。</p>
<p><strong>初始化</strong><br>类加载过程中的最后一步。初始化阶段是<strong>执行类构造器<code>&lt;clinit&gt;()</code>（class init）方法</strong>的过程。<code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生的。<code>&lt;clinit&gt;()</code>与类的构造函数不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的<code>&lt;clinit&gt;()</code>方法执行之前，父类的<code>&lt;clinit&gt;()</code>方法已经执行完毕。简单地说，初始化就是<strong>对类变量进行赋值及执行静态代码块</strong>。</p>
<p><strong>以下几种情况不会执行初始化步骤</strong>：</p>
<ul>
<li>通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化；</li>
<li>定义对象数组，不会触发该类的初始化；</li>
<li>常量在编译期间会存入类的常量池中，本质上并没有直接引用定义常量的类，不会触发定义常量所在的类；</li>
<li>通过类名获取 Class 对象，不会触发类的初始化；</li>
<li>通过<code>Class.forName()</code>加载指定类时，如果指定参数 initialize 为 false 时，也不会触发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化；</li>
<li>通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作。</li>
</ul>
<p><strong>类加载器 ClassLoader</strong><br>通过上述的了解，我们已经知道了类加载机制的大概流程及各个部分的功能。其中<strong><code>加载</code></strong>部分的功能是将类的 class 文件读入内存，并为之创建一个 java.lang.Class 对象。这部分功能就是<strong>由类加载器（ClassLoader）来实现</strong>的。</p>
<p>注意这里不一定非得要从一个 class 文件获取，这里既可以从 ZIP 包中读取（比如从 jar 包和 war 包中读取），也可以在运行时计算生成（动态代理），也可以由其它文件生成（比如将 JSP 文件转换成对应的 Class 类），要做到这些可能需要自定义一个类加载器。</p>
<p><strong>类加载器分类</strong><br>不同的类加载器负责加载不同的类。主要分为两类：</p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：由 C++ 语言实现（针对 HotSpot），负责将<code>$JAVA_HOME/jre/lib/</code>默认目录或<code>-Xbootclasspath</code>JVM 运行参数指定的路径中的类库加载到内存中，即负责<strong>加载 Java 的核心类</strong>。</li>
<li><strong>其它类加载器</strong>：由 Java 语言实现，继承自抽象类 java.lang.ClassLoader。如：<ul>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：负责加载<code>$JAVA_HOME/jre/lib/ext/</code>默认目录或<code>java.ext.dirs</code>JVM 系统属性指定的路径中的类库，即负责<strong>加载 Java 扩展类</strong>。</li>
<li><strong>应用程序类加载器（Application ClassLoader）</strong>：负责加载<code>$CLASSPATH</code>或<code>-classpath/-cp</code>参数指定的路径中的类库（用户类）。如果我们没有自定义类加载器，那么默认就是用这个加载器（使用<code>ClassLoader.getSystemClassLoader()</code>可获取）。</li>
</ul>
</li>
</ul>
<p>以上两大类三小类的类加载器基本上负责了所有 Java 类的加载。下面我们来具体了解上述几个类加载器实现类加载过程时相互配合协作的流程。<br><img src="/images/java-classloader.png" alt="JVM 类加载器"></p>
<blockquote>
<p>JVM 中有多个类加载器，分饰不同的角色。每个类加载器由它的父加载器加载。<code>Bootstrap</code>加载器除外，它是所有最顶层的类加载器。</p>
</blockquote>
<p><strong>双亲委派模型</strong><br>双亲委派模型的工作流程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把请求委托给父加载器去完成，父加载器又将请求委托给它的父加载器，依此类推。因此所有的类加载请求最终都应该被传递到顶层的启动类加载器中，只有当父加载器无法完成该类的加载时，才会将请求传递给它的子加载器，让子加载器去尝试加载该类，如果子加载器也加载不了，则继续传递给它的子加载器，依此类推。如果到了最后也没加载成功，则抛出 ClassNotFoundException 异常。</p>
<p>这样的好处是不同层次的类加载器具有不同优先级，比如所有 Java 对象的超级父类 java.lang.Object，位于 rt.jar，无论哪个类加载器加载该类，最终都是由启动类加载器进行加载，保证安全。即使用户自己编写一个 java.lang.Object 类并放入程序中，虽能正常编译，但不会被加载运行，保证不会出现混乱。</p>
<p><strong>比较两个类是否”相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义</strong>，否则即使这两个类来源于同一个 .class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，这两个类必定不相等。<br>上面说的”相等”，包括类对应的 Class 对象的 equals() 方法、isAssignableFrom() 方法、isInstance() 方法的返回结果，也包括使用 instanceof 关键字做对象所属关系判定等情况。</p>
<p><strong>ClassLoader 类简介</strong></p>
<pre><code class="language-java line-numbers"><script type="text/plain">public abstract class ClassLoader {
    /* 构造方法 */
    protected ClassLoader(ClassLoader parent); // 指定父加载器
    protected ClassLoader(); // parent = getSystemClassLoader()

    /* 静态方法 */
    // 获取 system 加载器
    public static ClassLoader getSystemClassLoader();

    // 使用 system-loader 查找资源，从 classpath 中查找
    // 如: ClassLoader.getSystemResource("com/zfl9/regex/test.txt");
    public static URL getSystemResource(String name);
    public static InputStream getSystemResourceAsStream(String name); // 同上，URL.openStream()
    public static Enumeration<URL> getSystemResources(String name) throws IOException; // all

    /* 类加载相关 */
    // 加载给定的全限定类名的 .class 文件，等价于 loadClass(name, flase)
    public Class<?> loadClass(String name) throws ClassNotFoundException;
    protected Class<?> loadClass(String name, // 全限定类名
                                 boolean resolve) // 是否进行"解析"
                          throws ClassNotFoundException;

    // 此方法应由自定义类加载器重写，默认抛出 ClassNotFoundException 异常
    protected Class<?> findClass(String name) throws ClassNotFoundException;
    // 如果指定类已被加载，则返回它的 Class 对象，否则返回 null
    protected final Class<?> findLoadedClass(String name);

    // 解析 .class 文件字节流，并返回 Class 对象
    protected final Class<?> defineClass(String name,
                                         byte[] b,
                                         int off,
                                         int len);
    // 解析常量池中的符号引用 (此步骤可选)
    protected final void resolveClass(Class<?> c);

    /* 获取资源相关 */
    public URL getResource(String name); // 获取给定路径指定的资源，使用 "/" 分隔
    public Enumeration<URL> getResources(String name) throws IOException; // all
    public InputStream getResourceAsStream(String name); // 调用 URL.openStream()

    // 此方法应由自定义类加载器重写，默认返回 null 值
    protected URL findResource(String name);
    // 此方法应由自定义类加载器重写，默认返回空枚举
    protected Enumeration<URL> findResources(String name) throws IOException;

    /* 父加载器 */
    public final ClassLoader getParent(); // bootstrap-loader 为 null

    /* 启用断言 */
    // 设置当前加载器的断言功能，如果为 true，则启用，默认为 flase
    public void setDefaultAssertionStatus(boolean enabled);
    public void setPackageAssertionStatus(String packageName, boolean enabled); // 指定包，优先级更高
    public void setClassAssertionStatus(String className, boolean enabled); // 指定类，优先级最高

    public void clearAssertionStatus(); // 重置断言状态(default、package、class)，并忽略命令行断言设置
}
</script></code></pre>
<p><strong>Bootstrap 加载器</strong></p>
<ul>
<li>Bootstrap 加载器一般由本地代码实现，因为它在 JVM 加载以后的早期阶段就被初始化了；</li>
<li>Bootstrap 加载器只负责载入基础的 Java API，默认搜索路径（<code>sun.boot.class.path</code>）为：<ul>
<li><code>$JAVA_HOME/jre/lib/rt.jar</code></li>
<li><code>$JAVA_HOME/jre/lib/resources.jar</code></li>
<li><code>$JAVA_HOME/jre/lib/charsets.jar</code></li>
<li><code>$JAVA_HOME/jre/lib/sunrsasign.jar</code></li>
<li><code>$JAVA_HOME/jre/lib/jce.jar</code></li>
<li><code>$JAVA_HOME/jre/lib/jfr.jar</code></li>
<li><code>$JAVA_HOME/jre/lib/jsse.jar</code></li>
<li><code>$JAVA_HOME/jre/classes</code></li>
</ul>
</li>
<li>Bootstrap 只加载拥有较高信任级别的启动路径下找到的类，因此跳过了很多普通类需要做的校验工作。</li>
</ul>
<p><strong>Extension 加载器</strong><br>Extension 加载器只负责载入扩展的 Java API，默认搜索路径（<code>java.ext.dirs</code>）为：<code>$JAVA_HOME/jre/lib/ext</code>、<code>/usr/java/packages/lib/ext</code>。</p>
<p><strong>System 加载器</strong><br>System 加载器是应用的默认类加载器，负责载入除基础、扩展 Java API 外的其它类，也就是<code>$CLASSPATH</code>或<code>-classpath/-cp</code>命令行参数指定的路径下的类。</p>
<p><strong>自定义加载器</strong><br>用户自定义类加载器也可以用来加载应用类；通过继承 java.lang.ClassLoader 实现自定义的类加载器（只需重写<code>findClass()</code>方法）；使用自定义的类加载器有很多特殊的原因，如运行时重新加载类、把加载的类分隔为不同的组、从加密的 class 文件中加载类、从网络中加载类等。</p>
<p>其中，Bootstrap 类加载器为<code>null</code>，Extension 类加载器为<code>sun.misc.Launcher$ExtClassLoader</code>、System 类加载器为<code>sun.misc.Launcher$AppClassLoader</code>，如下所示：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">public class Main {
    public static void main(String[] args) {
        ClassLoader bootstrap = System.class.getClassLoader();
        ClassLoader system = Main.class.getClassLoader();
        ClassLoader extension = system.getParent();

        System.out.println(bootstrap); // null
        System.out.println(extension); // sun.misc.Launcher$ExtClassLoader
        System.out.println(system);    // sun.misc.Launcher$AppClassLoader

        System.out.println(extension instanceof ClassLoader); // true
        System.out.println(system instanceof ClassLoader);    // true
    }
}
</script></code></pre>
<pre><code class="language-java line-numbers"><script type="text/plain"># root @ arch in ~/java8-learn/com/zfl9 on git:master x [11:11:16]
$ javac Main.java

# root @ arch in ~/java8-learn/com/zfl9 on git:master x [11:11:38]
$ java Main
null
sun.misc.Launcher$ExtClassLoader@15db9742
sun.misc.Launcher$AppClassLoader@73d16e93
true
true
</script></code></pre>
<p><strong>如何自定义类加载器</strong>？</p>
<ol>
<li>继承<code>java.lang.ClassLoader</code>抽象类；</li>
<li>重写<code>protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException</code>方法；</li>
<li>使用<code>Class&lt;?&gt; defineClass(String name, byte[] b, int off, int len)</code>方法转换字节流为 Class 对象。</li>
</ol>
<p>例子：使用简单的加密算法（异或）将常规 .class 文件加密为 .cipher 文件，然后使用自定义的类加载器加载它。</p>
<p>1、简单的加密工具，将 .class 加密为 .cipher 文件</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.classloader;

import java.io.File;
import java.io.IOException;
import java.io.FileInputStream;
import java.io.FileOutputStream;

public class EncryptionTool {
    private static final byte KEY = 2;

    public static byte[] encrypt(byte[] data, int beg, int end) {
        for (int i = beg; i < end; i++)
            data[i] = (byte) (data[i] ^ KEY);
        return data;
    }
    public static byte[] encrypt(byte[] data) {
        return encrypt(data, 0, data.length);
    }

    public static byte[] decrypt(byte[] data, int beg, int end) {
        return encrypt(data, beg, end);
    }
    public static byte[] decrypt(byte[] data) {
        return encrypt(data, 0, data.length);
    }

    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.err.println("Missing running parameters");
            System.err.println("Usage: EncryptionTool <src.file> <dst.file>");
            System.exit(1);
        }

        File src = new File(args[0]),
             dst = new File(args[1]);
        if (!src.isFile()) {
            System.err.printf("\"%s\" No such file or directory\n", args[0]);
            System.exit(2);
        }

        FileInputStream input = new FileInputStream(src);
        FileOutputStream output = new FileOutputStream(dst);

        int nbuf = 0;
        byte[] buf = new byte[4096];

        while ((nbuf = input.read(buf, 0, buf.length)) != -1)
            output.write(encrypt(buf), 0, nbuf);

        input.close();
        output.close();
    }
}
</script></code></pre>
<p>2、测试用的类</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.classloader;

public class TestClass {
    @Override
    public String toString() {
        return TestClass.class.getClassLoader().toString();
    }
}
</script></code></pre>
<p>3、自定义的类加载器</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.classloader;

import java.io.File;
import java.io.IOException;
import java.io.FileInputStream;

public class MyClassLoader extends ClassLoader {
    private String rootDir;

    public MyClassLoader(String rootDir) {
        super();
        this.rootDir = rootDir;
    }
    public MyClassLoader(ClassLoader parent, String rootDir) {
        super(parent);
        this.rootDir = rootDir;
    }

    @Override
    protected Class<?> findClass(String name)
        throws ClassNotFoundException
    {
        File file = new File(rootDir + '/' + name.replace('.', File.separatorChar) + ".cipher");
        if (!file.isFile())
            throw new ClassNotFoundException(name);

        try {
            FileInputStream input = new FileInputStream(file);
            byte[] data = new byte[(int) file.length()];
            for (int off = 0, len = data.length;
                 (off = input.read(data, off, len)) != -1 && len != 0;
                 len -= off);
            input.close();
            data = EncryptionTool.decrypt(data);
            return defineClass(name, data, 0, data.length);
        } catch (IOException e) {
            throw new ClassNotFoundException(name, e);
        }
    }

    public static void main(String[] args)
        throws ClassNotFoundException,
               InstantiationException,
               IllegalAccessException
    {
        ClassLoader loader = new MyClassLoader("/root/java8-learn");
        Class<?> clazz = loader.loadClass("com.zfl9.classloader.TestClass");
        Object obj = clazz.newInstance();
        System.out.println(obj);
    }
}
</script></code></pre>
<p>4、测试 &amp; 测试结果</p>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/java8-learn/com/zfl9/classloader on git:master x [13:56:47]
$ ll
total 12K
-rw-r--r-- 1 root root 1.6K Dec 23 13:41 EncryptionTool.java
-rw-r--r-- 1 root root 1.6K Dec 23 13:48 MyClassLoader.java
-rw-r--r-- 1 root root  169 Dec 23 12:38 TestClass.java

# root @ arch in ~/java8-learn/com/zfl9/classloader on git:master x [13:56:51]
$ echo $CLASSPATH
.:/root/java8-learn

# root @ arch in ~/java8-learn/com/zfl9/classloader on git:master x [13:56:57]
$ javac *.java

# root @ arch in ~/java8-learn/com/zfl9/classloader on git:master x [13:57:06]
$ ll
total 24K
-rw-r--r-- 1 root root 1.6K Dec 23 13:57 EncryptionTool.class
-rw-r--r-- 1 root root 1.6K Dec 23 13:41 EncryptionTool.java
-rw-r--r-- 1 root root 2.2K Dec 23 13:57 MyClassLoader.class
-rw-r--r-- 1 root root 1.6K Dec 23 13:48 MyClassLoader.java
-rw-r--r-- 1 root root  380 Dec 23 13:57 TestClass.class
-rw-r--r-- 1 root root  169 Dec 23 12:38 TestClass.java

# root @ arch in ~/java8-learn/com/zfl9/classloader on git:master x [13:57:09]
$ java com.zfl9.classloader.EncryptionTool TestClass.class TestClass.cipher

# root @ arch in ~/java8-learn/com/zfl9/classloader on git:master x [13:57:36]
$ ll
total 28K
-rw-r--r-- 1 root root 1.6K Dec 23 13:57 EncryptionTool.class
-rw-r--r-- 1 root root 1.6K Dec 23 13:41 EncryptionTool.java
-rw-r--r-- 1 root root 2.2K Dec 23 13:57 MyClassLoader.class
-rw-r--r-- 1 root root 1.6K Dec 23 13:48 MyClassLoader.java
-rw-r--r-- 1 root root  380 Dec 23 13:57 TestClass.cipher
-rw-r--r-- 1 root root  380 Dec 23 13:57 TestClass.class
-rw-r--r-- 1 root root  169 Dec 23 12:38 TestClass.java

# root @ arch in ~/java8-learn/com/zfl9/classloader on git:master x [13:57:38]
$ md5sum TestClass.cipher TestClass.class
fa5a1fa8b5351223389d12b21fe5372d  TestClass.cipher
750eafb5f60550500e983aa82821f7ab  TestClass.class

# root @ arch in ~/java8-learn/com/zfl9/classloader on git:master x [13:57:47]
$ rm -fr TestClass.class

# root @ arch in ~/java8-learn/com/zfl9/classloader on git:master x [13:57:56]
$ ll
total 24K
-rw-r--r-- 1 root root 1.6K Dec 23 13:57 EncryptionTool.class
-rw-r--r-- 1 root root 1.6K Dec 23 13:41 EncryptionTool.java
-rw-r--r-- 1 root root 2.2K Dec 23 13:57 MyClassLoader.class
-rw-r--r-- 1 root root 1.6K Dec 23 13:48 MyClassLoader.java
-rw-r--r-- 1 root root  380 Dec 23 13:57 TestClass.cipher
-rw-r--r-- 1 root root  169 Dec 23 12:38 TestClass.java

# root @ arch in ~/java8-learn/com/zfl9/classloader on git:master x [13:57:57]
$ java com.zfl9.classloader.MyClassLoader
com.zfl9.classloader.MyClassLoader@15db9742
</script></code></pre>
<h2 id="JVM-对象访问方式"><a href="#JVM-对象访问方式" class="headerlink" title="JVM 对象访问方式"></a>JVM 对象访问方式</h2><p>在 Java 虚拟机规范中，对于通过 reference 引用类型访问具体对象的方式并未做规定，目前主流的实现方式主要有两种：<br>1、通过<code>句柄</code>访问：<br><img src="/images/java-obj-access-1.png" alt="通过句柄访问 Object"><br>如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为<strong>句柄池</strong>（两个元素的指针数组），reference 变量中存储的就是对象的句柄地址，而句柄中包含了<code>对象实例数据</code>和<code>对象类型数据</code>的地址。使用句柄的优点是 reference 存储的是句柄地址，当对象被移动时，只需改变<code>对象实例数据</code>指针，而 reference 本身不用变动。</p>
<p>2、通过<code>直接指针</code>访问：<br><img src="/images/java-obj-access-2.png" alt="通过直接指针访问 Object"><br>如果使用直接指针访问方式，reference 变量中存储的就是<code>对象实例数据</code>的地址，然后再通过实例数据中的<code>对象类型数据</code>指针访问<code>对象类型数据</code>。这种方法的优点是访问对象实例数据比较快，因为只有一次指针定位操作。</p>
<blockquote>
<p>默认的 HotSpot 虚拟机就是使用的<strong>直接指针</strong>访问方式！</p>
</blockquote>
<h2 id="JVM-内存分代机制"><a href="#JVM-内存分代机制" class="headerlink" title="JVM 内存分代机制"></a>JVM 内存分代机制</h2><p>这里所说的内存分配，主要指的是在堆上的分配，一般的，对象的内存分配都是在堆上进行，但现代技术也支持将对象拆成标量类型（标量类型即原子类型，表示单个值，可以是基本类型或 String 等），然后在栈上分配，在栈上分配的很少见，此处不进行讨论。</p>
<p>Java 虚拟机<code>内存分配</code>和<code>内存回收机制</code>概括的说就是：<strong>分代分配，分代回收</strong>。</p>
<p>对象将根据<strong>存活的时间</strong>被分为：<code>年轻代（Young Generation）</code>、<code>年老代（Old Generation）</code>、<code>永久代（Permanent Generation，即方法区）</code>；</p>
<blockquote>
<p><code>永久代</code>是 HotSpot 特有概念，它采用永久代的方式来实现<code>方法区</code>，其它虚拟机实现没有这一概念；而且 HotSpot 也有取消永久代的趋势，在 JDK1.7 中 HotSpot 已经开始了“去永久化”，但是永久代依然存在，在 JDK1.8 中已经彻底取消了永久代，取而代之的是<code>元空间 Metaspace</code>。</p>
</blockquote>
<p><strong>JVM 堆结构图 - 分代</strong><br><img src="/images/java-heap-gen.jpg" alt="JVM 堆结构图 - 分代"></p>
<p><strong>年轻代 Young Generation</strong><br><code>年轻代（Young Generation）</code>：对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代）。大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的 GC 机制清理掉（IBM 的研究表明，98% 的对象都是很快消亡的），这个 GC 机制被称为<code>Minor GC</code>或叫<code>Young GC</code>。</p>
<p>年轻代一般分为 3 个区域：<br>1) <code>Eden 区</code>：伊甸园，亚当和夏娃偷吃禁果生娃娃的地方，表示内存首次分配的区域，默认大小为 80%；<br>2) <code>Survivor 0</code>：From，存活区 1，默认大小为 10%；<br>3) <code>Survivor 1</code>：To，存活区 2，默认大小为 10%。</p>
<ul>
<li>绝大多数刚创建的对象会被分配在 Eden 区，其中的大多数对象很快就会消亡；Eden 区是连续的内存空间，因此在其上分配内存极快；</li>
<li>最初一次，当 Eden 区满的时候，执行 Minor GC，将消亡的对象清理掉，并将剩余的对象复制到一个存活区 Survivor0（此时，Survivor1 是空白的，两个 Survivor 总有一个是空白的）；</li>
<li>下次 Eden 区满了，再执行一次 Minor GC，将消亡的对象清理掉，将存活的对象复制到 Survivor1 中，然后清空 Eden 区；接着将 Survivor0 中消亡的对象清理掉，将其中可以晋级的对象晋级到 Old 区，将存活的对象复制到 Survivor1 区，然后清空 Survivor0 区；</li>
<li>当一个对象在两个存活区之间切换了几次（HotSpot 虚拟机默认<code>15次</code>，用<code>-XX:MaxTenuringThreshold</code>控制，大于该值进入老年代，但这只是个最大值，并不代表一定是这个值）之后，仍然存活的对象，将被复制到老年代。</li>
</ul>
<p>从上面的过程可以看出，<strong>Eden 区是连续的空间，且 Survivor 总有一个为空</strong>。经过一次 GC 和复制，一个 Survivor 中保存着当前还活着的对象，而 Eden 区和另一个 Survivor 区的内容都不再需要了，可以直接清空，到下一次 GC 时，两个 Survivor 的角色再互换。<br>因此，这种方式分配内存和清理内存的效率都极高，这种垃圾回收的方式就是著名的<strong>停止-复制（stop-and-copy）</strong>清理法；这不代表着停止-复制清理法很高效，其实，它也只在这种情况下高效，如果在老年代采用停止复制，则挺悲剧的。</p>
<p>在 Eden 区，HotSpot 虚拟机使用了两种技术来加快内存分配：</p>
<ul>
<li><code>bump-the-pointer</code>：JVM 内部维护一个指针（allocatedTail），它始终指向先前已分配对象的尾部，当新的对象分配请求到来时，只需检查代中剩余空间（从 allocatedTail 到代尾 geneTail）是否足以容纳该对象，并在“是”的情况下更新 allocatedTail 指针并初始化对象。从而大大加快内存分配速度。</li>
<li><code>TLAB（Thread-Local Allocation Buffers）</code>：对于多线程应用，分配操作必须是线程安全的。如果使用全局锁为此提供保证，则分配操作必定成为一个性能瓶颈。因此 HotSpot 采用了一种被称为<code>线程局部分配缓冲区</code>（Thread-Local Allocation Buffers，TLAB）的技术。该项技术为每个线程提供一个独立的分配缓冲区（伊甸区的一小部分），借此来提高分配操作的吞吐量。因为针对每个 TLAB，只有一个线程从中分配对象，故而分配操作可以使用<code>bump-the-pointer</code>技术快速完成，而不必使用任何锁机制；只有当线程将其已有 TLAB 填满并且需要获取一个新的 TLAB 时，同步才是必须的。同时，为了减少 TLAB 所带来的空间消耗，还使用了一些其它技术，例如，分配器能够把 TLAB 的平均大小限制在伊甸区的１% 以下。</li>
</ul>
<p><strong>bump-the-pointer</strong>和<strong>TLAB</strong>技术的组合保证了分配操作的高效性，类似<code>new Object()</code>这样的操作在大部分时间内只需要大约 10 条机器指令即可完成。</p>
<p><strong>年老代 Old/Tenured Generation</strong><br>一个对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次 Young GC 后存活了下来），则会被复制到年老代。如果对象比较大（比如长字符串或大数组）而 Young 空间不足，则大对象会直接分配到年老代上（大对象可能触发提前 GC，应少用，更应避免使用短命的大对象），使用<code>-XX:PretenureSizeThreshold</code>可控制直接升入年老代的对象大小，大于这个值的对象会直接分配在年老代上。</p>
<p>年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的 GC 次数也比年轻代少；当年老代内存不足时，将执行<code>Major GC</code>，也叫<code>Full GC</code>（个人觉得这种说法不太准确，我的个人理解是：<code>Minor GC</code>针对年轻代，<code>Major GC</code>针对年老代，<code>Minor GC</code>和<code>Major GC</code>统称为<code>Partial GC</code>，而<code>Full GC</code>则针对整个堆，即年轻代、年老代、永久代（如果有的话））。</p>
<p>可以使用<code>-XX:+UseAdaptiveSizePolicy</code>开关来控制是否采用动态控制策略，如果启用动态控制，则动态调整 Java 堆中各个区域的大小以及进入老年代的年龄。</p>
<p>可能存在年老代对象引用新生代对象的情况，如果需要执行 Young GC，则可能需要查询整个老年代以确定是否可以清理回收，这显然是低效的；解决的方法是，年老代中维护一个 512 byte 的块<code>card table</code>，所有老年代对象引用新生代对象的记录都记录在这里；Young GC 时，只要查这里即可，不用再去查全部老年代，因此性能大大提高。</p>
<p><strong>永久代 Permanent Generation</strong><br>永久代的回收有两种：<code>常量池中的常量</code>，<code>无用的类</code>；常量的回收很简单，没有引用了就可以被回收；对于无用的类进行回收，必须保证 3 点：</p>
<ol>
<li>该类的所有实例都已经被回收；</li>
<li>加载该类的 ClassLoader 已经被回收；</li>
<li>该类对应的 Class 对象没有被引用（即没有通过反射引用该类的地方）。</li>
</ol>
<p>因此，在永久代进行 GC 的效率较低，永久代的回收也不是必须的，可以通过参数来设置是否对类进行回收；HotSpot 提供<code>-Xnoclassgc</code>进行控制。</p>
<p><strong>JDK1.8 元空间 Metaspace</strong><br>为什么移除永久代？</p>
<ul>
<li>永久代的大小是固定的，并且很难进行调优。<code>-XX:MaxPermSize</code>究竟设置成多少好呢？</li>
<li>简化 Full GC，因为 HotSpot 每个垃圾收集器都有专门的代码来处理永久代中的元数据。</li>
<li>不想再出现恼人的 java.lang.OutOfMemoryError: PermGen，希望可以更灵活的管理元数据。</li>
</ul>
<p>因此，JDK1.8 使用<code>元空间 Metaspace</code>代替了之前的永久代，而<code>-XX:PermSize</code>、<code>-XX:MaxPermSize</code>选项则被忽略并给出警告。</p>
<p><strong>PermGen 和 Metaspace 的区别</strong><br>PermGen 是 Java Heap 的一部分，而 Metaspace 不是。元空间是在 Native Memory（本地内存）分配的，如果不显式限制元空间最大大小（<code>-XX:MaxMetaspaceSize</code>），则只受到操作系统可用内存的限制。如下图所示：<br><img src="/images/jvm-metaspace.jpg" alt="永久代与元空间的区别"></p>
<p><strong>Metaspace 垃圾回收</strong><br>对于僵死的类及类加载器的垃圾回收将在元数据使用达到<code>MaxMetaspaceSize</code>参数的设定值时进行。适时地监控和调整元空间对于减小垃圾回收频率和减少延时是很有必要的。持续的元空间垃圾回收说明，可能存在类、类加载器导致的内存泄漏或是大小设置不合适。</p>
<p><strong>Metaspace 相关参数</strong><br><code>-XX:MetaspaceSize</code>：设置元空间初始大小，默认值为 16M<br><code>-XX:MaxMetaspaceSize</code>：设置元空间最大大小，默认不限制<br><code>-XX:MinMetaspaceFreeRatio</code>：设置空闲元空间容量的最小占比<br><code>-XX:MaxMetaspaceFreeRatio</code>：设置空闲元空间容量的最大占比<br><code>-XX:MinMetaspaceExpansion</code>：设置元空间每次扩展的最小大小<br><code>-XX:MaxMetaspaceExpansion</code>：设置元空间每次扩展的最大大小（不进行 Full GC）</p>
<h2 id="JVM-垃圾回收机制"><a href="#JVM-垃圾回收机制" class="headerlink" title="JVM 垃圾回收机制"></a>JVM 垃圾回收机制</h2><p><strong>年轻代</strong><br>前面我们说了，在年轻代中，使用<code>停止-复制</code>算法进行垃圾清理，JVM 将年轻代内存分为 2 部分，Eden 区较大，Survivor 比较小，并被划分为两个等量的部分（Survivor From、Survivor To）。</p>
<p>每次进行清理时，将 Eden 区和一个 Survivor 中仍然存活的对象拷贝到另一个 Survivor 中（如果达到成年的年龄，则被复制到年老代中），然后清理掉 Eden 和刚才的 Survivor；由于绝大部分的对象都是短命的，甚至存活不到 Survivor 中，所以，Eden 区与 Survivor 的比例较大；HotSpot 默认是 8:1，即分别占年轻代的 80%，10%，10%。</p>
<p>如果某次回收中，Survivor + Eden 中存活下来的内存超过了 10%（即一个 Survivor 占有的空间），则需要将一部分对象分配到老年代；用<code>-XX:SurvivorRatio</code>参数来配置 Eden 区域、Survivor 区域的容量比值，默认是 8，代表 Eden:Survivor1:Survivor2 = 8:1:1。</p>
<p><strong>年老代</strong><br>年老代存储的对象比年轻代多得多，而且不乏大对象，对年老代进行内存清理时，如果使用<code>停止-复制</code>算法，则相当低效；一般，年老代用的算法是<code>标记-整理</code>算法，即：<strong>标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续</strong>。</p>
<blockquote>
<p>在发生<code>Minor GC</code>时，虚拟机会检查晋升进入老年代的大小是否大于年老代的剩余空间大小，如果大于，则直接触发一次<code>Full GC</code>。</p>
</blockquote>
<p><strong>永久代</strong><br>永久代的回收前面也说了，主要是回收无用的常量和无用的类。不过因为在永久代执行 GC 的效率不高，因此 GC 在永久代中的活动较少。不过，当 JVM 加载的类过多而导致永久代空间不足时，会触发 Full GC，如果 Full GC 后内存空间仍然不足，则抛出 OutOfMemoryError 错误。</p>
<p><strong>Full GC 触发条件</strong></p>
<ul>
<li>调用 System.gc() 时，可能会执行 Full GC；</li>
<li>OldGen 年老代的空间不足时；</li>
<li>PermGen 永久代的空间不足时；</li>
<li>年老代的剩余空间不足以容纳经过 Minor GC 晋升的对象时；</li>
<li>从 Eden、Survivor 区拷贝存活对象至另一 Survivor，该 Survivor 空间不足，则把一些对象转至年老代，但是年老代的空间也不足时。</li>
</ul>
<blockquote>
<p>总而言之，只要<code>年老代</code>、<code>永久代</code>的空间不足，就会触发 Full GC。</p>
</blockquote>
<p><strong>判断对象是否存活</strong><br>GC（Garbage Collection，垃圾回收）是通过对象是否存活来决定是否进行回收的。判断对象是否存活主要有两种算法：<code>引用计数算法</code>、<code>可达性分析算法</code>。</p>
<p>1) <code>引用计数算法</code><br>引用计数的算法原理是给对象添加一个引用计数器，每被引用一次计数器加 1，引用失效时减 1，当计数器 0 后表示对象不在被引用，可以被回收了。引用计数法简单高效，但是存在对象之间<strong>循环引用</strong>问题，可能导致无法被 GC 回收，需要花很大精力去解决循环引用问题。</p>
<blockquote>
<p>Java 没有采用<code>引用计数算法</code>，最主要的原因就是很难解决对象之间循环引用的问题。</p>
</blockquote>
<p>2) <code>可达性分析算法</code><br>可达性分析的算法原理是从<strong>对象根引用(<code>GC Roots</code>)</strong>开始遍历搜索所有可到达对象，形成一个引用链，遍历的同时标记出可达对象和不可达对象，不可达对象表示没有任何引用存在，可以被 GC 回收。如下图所示：<br><img src="/images/java-gc-root.jpg" alt="可达性分析算法"><br><strong>当一个对象到 GC Roots 没有任何引用链相连时，则证明这个对象为可回收的对象</strong>。</p>
<p>GC Roots 是<strong>可以从堆外部访问的对象</strong>（可以有多个），如果一个对象可以被以下途径访问，则可以作为 GC Roots：</p>
<ul>
<li><code>虚拟机栈的本地变量表</code>中所引用的对象可以作为 GC Roots；</li>
<li><code>本地方法栈的局部变量</code>所引用的对象也可以作为 GC Roots；</li>
<li><code>方法区中已加载类的静态字段</code>引用的对象可以作为 GC Roots。</li>
</ul>
<p><strong>四种引用类型</strong><br>1) <code>强引用(StrongReference)</code><br>如<code>Object obj = new Object()</code>，这里的 obj 便是一个强引用，强引用不会被 GC 回收；即使抛出 OutOfMemoryError 错误，使程序异常终止；</p>
<p>2) <code>软引用(SoftReference)</code><br>如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存；软引用可用来实现内存敏感的高速缓存；</p>
<p>3) <code>弱引用(WeakReference)</code><br>垃圾回收器一旦发现了弱引用的对象，不管当前内存空间足够与否，都会回收它的内存；不过由于垃圾回收器是一个优先级很低的线程，因此不一定能很快发现那些弱引用的对象；</p>
<p>4) <code>虚引用(PhantomReference)</code><br>虚引用必须和<code>引用队列（ReferenceQueue）</code>联合使用；</p>
<p>总结：<br>1) <code>强引用</code>：不会被 GC 回收，用于对象的一般状态；<br>2) <code>软引用</code>：在内存不足时被 GC 回收，用于对象缓存；<br>3) <code>弱引用</code>：只要被 GC 发现就会回收，用于对象缓存。</p>
<p><strong>内存回收算法</strong><br>内存回收算法主要有<code>停止-复制</code>、<code>标记-整理</code>、<code>标记-清除</code>；不同算法使用不同的场景，总体来说<code>停止-复制</code>算法适合对象存活时间短，存活率低的<strong>年轻代</strong>，<code>标记-清除</code>和<code>标记-整理</code>算法适合对象存活时间长，存活率高的<strong>年老代</strong>。</p>
<ul>
<li><code>停止-复制(Stop-Copy)</code><br>停止复制算法对于存活率较低的对象回收有着非常高的效率，而且不会形成内存碎片，但是会浪费一定的内存空间，适合对象存活率较低的年轻代使用，如果在对象存活率较高的年老代采用这种算法，那将会是一场灾难。</li>
<li><code>标记-整理(Mark-Compact)</code><br>通过可达性分析算法标记所有不可达对象，然后将存活对象都向一个方向移动，然后清理掉边界外的内存；这种算法是将存活对象向着一个方向聚集，然后将剩余区域清空，这种算法适合对象存活率较高的年老代，该算法不会产生内存碎片。</li>
<li><code>标记-清除(Mark-Sweep)</code><br>通过可达性分析算法标记所有不可达对象，然后清理不可达对象；这种算法会形成大量的内存碎片。</li>
</ul>
<p>一般我们所说的 GC 都是发生在<code>年轻代</code>和<code>年老代</code>：<br>年轻代的对象存活时间短，存活率低，一般采用<code>停止-复制</code>算法；<br>年老代的对象存活时间长，存活率高，一般采用<code>标记-整理</code>、<code>标记-清除</code>算法，具体采用何种算法和具体采用的垃圾收集器有关。</p>
<p><strong>GC 收集器</strong><br>在 GC 机制中，起重要作用的是垃圾收集器，垃圾收集器是 GC 的具体实现，Java 虚拟机规范中对于垃圾收集器没有任何规定，所以不同厂商实现的垃圾收集器各不相同。</p>
<p>GC 收集器分为<code>年轻代收集器</code>和<code>年老代收集器</code>，不同的收集器使用不同的收集算法，有着不同的特点。</p>
<p>目前的收集器在内存回收时均无法消除<code>stop-the-world</code>（即在回收内存时不可避免的停止用户线程）；新出现的收集器只能使停顿时间越来越短，但是无法彻底消除。</p>
<p>年轻代收集器：<code>Serial</code>、<code>ParNew</code>、<code>Parallel Scavenge</code>；<br>年老代收集器：<code>Serial Old</code>、<code>Parallel Old</code>、<code>CMS</code>（Concurrent Mark-Sweep）；<br>整堆收集器：<code>G1</code>（Garbage-First Garbage Collector），计划替代 CMS，Java9 默认收集器。</p>
<p><img src="/images/jvm-gc.jpg" alt="7 种 GC 收集器"><br>（JDK1.7）上图展示了 7 种作用于不同分代的收集器，<strong>如果两个收集器之间存在连线，就说明它们可以搭配使用</strong>。HotSpot 实现了如此多的收集器，正是因为目前并无完美的收集器出现，只是选择对具体应用最适合的收集器。</p>
<ul>
<li><code>Serial + Serial Old</code>：年轻代-单线程收集器、年老代-单线程收集器（Client 模式默认值）；</li>
<li><code>Serial + CMS</code>：年轻代-单线程收集器、年老代-并发收集器；</li>
<li><code>ParNew + Serial Old</code>：年轻代-多线程收集器、年老代-单线程收集器；</li>
<li><code>ParNew + CMS</code>：年轻代-多线程收集器、年老代-并发收集器；</li>
<li><code>Parallel + Serial Old</code>：年轻代-并行收集器、年老代-单线程收集器；</li>
<li><code>Parallel + Parallel Old</code>：年轻代-并行收集器、年老代-并行收集器（Server 模式默认值）；</li>
<li><code>G1</code>：整堆收集器（年轻代、年老代、永久代），JDK1.7 开始提供，JDK1.9 成为默认垃圾收集器。</li>
</ul>
<blockquote>
<p>比较推荐的组合：<code>Parallel + Parallel Old</code>、<code>ParNew + CMS</code>、<code>G1</code>（JDK1.7 起）</p>
</blockquote>
<p><strong>相关概念</strong><br><strong>stop-the-world</strong><br>不管选择什么收集器，<code>stop-the-world</code>都是不可避免的。也就是说，执行 GC 时（不一定是整个 GC 过程），用户线程会被暂停，直到 GC 任务结束。<strong>GC 调优通常就是为了减少<code>stop-the-world</code>的时间</strong>。</p>
<p><strong>串行、并行、并发</strong><br>串行（Serial）：只有一个线程在执行任务；<br>并行（Parallel）：多个线程<code>同时</code>执行任务；<br>并发（Concurrent）：多个线程<code>交替</code>执行任务。</p>
<p><strong>串行垃圾收集、并行垃圾收集、并发垃圾收集</strong><br>串行（Serial）收集：<strong>只有一个 GC 线程在工作</strong>，此时<strong>用户线程处于等待状态</strong>；如<code>Serial</code>、<code>Serial Old</code>。<br>并行（Parallel）收集：<strong>有多个 GC 线程在工作</strong>（不一定并行，可能是交替执行的），此时<strong>用户线程处于等待状态</strong>；如<code>ParNew</code>、<code>Parallel Scavenge</code>、<code>Parallel Old</code>。<br>并发（Concurrent）收集：<strong>用户线程与 GC 线程一起工作</strong>（不一定同时，可能是交替执行的）；如<code>CMS</code>、<code>G1</code>（也有并行）。</p>
<p><strong>吞吐量（Throughput）</strong><br>吞吐量即 CPU 用于运行用户代码的时间与 CPU 总共消耗的时间的比值，即<code>吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间)</code>。假设虚拟机总共运行了 100 分钟，其中垃圾收集花掉 1 分钟，那吞吐量就是 99%。</p>
<p><strong>垃圾收集器的关注点</strong><br>1、<code>停顿时间</code><br>停顿时间越短就适合需要与<strong>用户交互</strong>的程序；<strong>良好的响应速度</strong>能提升用户体验。<br>2、<code>吞吐量</code><br>高吞吐量则可以<strong>高效率地利用 CPU 时间</strong>，尽快完成<strong>运算的任务</strong>；适合<strong>后台计算</strong>而不需要太多交互的任务。</p>
<p><strong>年轻代收集器</strong><br>1) <code>Serial</code><br>采用<strong>停止-复制</strong>算法，因为只有一个 GC 线程，因此被命名为 Serial 串行收集器。<br><code>-XX:+UseSerialGC</code>：启用 Serial 收集器</p>
<p>2) <code>ParNew</code><br>采用<strong>停止-复制</strong>算法，Serial 收集器的多线程版。<strong>关注用户线程停顿时间</strong>。<br><code>-XX:+UseParNewGC</code>：启用 ParNew 收集器<br><code>-XX:ParallelGCThreads</code>：设置 GC 线程数量，默认与可用 CPU 核数相同<br><code>-XX:+UseConcMarkSweepGC</code>：启用 CMS 收集器，默认方案 ParNew + CMS，备用方案 ParNew + Serial Old</p>
<p>3) <code>Parallel Scavenge</code><br>采用<strong>停止-复制</strong>算法，<strong>关注 CPU 吞吐量</strong>，即运行用户代码的时间与总时间的比值。其它收集器的关注点一般是尽量缩短 GC 时用户线程的停顿时间；而 Parallel 的目标则是<strong>达到一个可控的吞吐量</strong>。适合<strong>对暂停时间无高要求、与用户无过多交互</strong>的应用，也即计算密集型任务。<br><code>-XX:+UseParallelGC</code>：启用 Parallel Scavenge 收集器<br><code>-XX:MaxGCPauseMillis</code>：设置用户线程最大停顿时间（毫秒），设置过小可能导致 GC 发生更频繁<br><code>-XX:GCTimeRatio</code>：设置吞吐量大小，即用户线程执行时间与总时间的占比，默认为 99，即只有 %1 的时间用于 GC<br><code>-XX:+UseAdaptiveSizePolicy</code>：自适应调节策略，如自动调整新生代大小、Eden 和 Survivor 比例、晋升年老代的年龄。这是一种值得推荐的方式：<br>1、只需设置好 Heap 堆内存大小（如<code>-Xmx</code>堆空间最大大小）；<br>2、然后使用<code>-XX:MaxGCPauseMillis</code>或<code>-XX:GCTimeRatio</code>给 JVM 设置一个优化目标；<br>3、最后启用<code>-XX:+UseAdaptiveSizePolicy</code>自适应调节策略，让 JVM 自动调整相关参数。</p>
<p><strong>年老代收集器</strong><br>1) <code>Serial Old</code><br>采用<strong>标记-整理</strong>算法，只有一个 GC 线程，是 Serial 收集器的年老代版本。</p>
<p>2) <code>Parallel Old</code><br>采用<strong>标记-整理</strong>算法，有多个 GC 线程，是 Parallel Scavenge 的年老代版本。Parallel Old 出现后（JDK 1.6），与 Parallel Scavenge 配合有很好的效果，充分体现 Parallel Scavenge 收集器吞吐量优先的效果。<br><code>-XX:+UseParallelOldGC</code>：启用 Parallel Old 收集器</p>
<p>3) <code>CMS（Concurrent Mark Sweep）</code><br>采用<strong>标记-清除</strong>算法（存在内存碎片），致力于获取<strong>最短停顿时间</strong>，优点是<strong>并发收集</strong>（用户线程可以和 GC 线程（基本上）同时工作），缺点是<strong>需要更多的内存</strong>，是 JDK1.5 推出的第一款真正意义上的<code>并发（Concurrent）</code>收集器。适用于<strong>与用户交互较多</strong>的应用，比如常见的 WEB、B/S 应用。<br><code>-XX:+UseConcMarkSweepGC</code>：启用 CMS 收集器，默认方案 ParNew + CMS，备用方案 ParNew + Serial Old（内存不足时）</p>
<p><strong>CMS 收集器运作过程</strong>比前面几种收集器更复杂，可以分为 4 个步骤：<br><img src="/images/jvm-cms.png" alt="CMS 收集器的四个过程"></p>
<ul>
<li><code>初始标记（CMS initial mark）</code>：仅标记一下与 GC Roots 直接关联的对象；速度很快；但需要”Stop The World”。</li>
<li><code>并发标记（CMS concurrent mark）</code>：进行 GC Roots Tracing 的过程（遍历 GC Roots）；标记出存活对象，用户线程不需要暂停，但不能保证可以标记出所有存活对象。</li>
<li><code>重新标记（CMS remark）</code>：为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；需要”Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短；采用多线程并行执行来提升效率。</li>
<li><code>并发清除（CMS concurrent sweep）</code>：回收所有的可回收对象（单个 GC 线程）。</li>
</ul>
<p>整个过程中<strong>耗时最长</strong>的<code>并发标记</code>和<code>并发清除</code>都可以<strong>与用户线程一起工作</strong>；所以总体上说，CMS 收集器的内存回收过程与用户线程一起并发执行。</p>
<p><strong>CMS 收集器 3 个明显缺点</strong><br>1、<code>对 CPU 资源非常敏感</code><br>并发收集虽然不会暂停用户线程，但因为占用一部分 CPU 资源，还是会导致应用程序变慢，总吞吐量降低。</p>
<p>CMS 的默认收集线程数量是：<code>(CPU 数量 + 3) / 4</code>。当 CPU 数量多于 4 个，收集线程占用的 CPU 资源多于 25%，对用户程序影响可能较大；不足 4 个时，影响更大，可能无法接受。针对这种情况，曾出现了<code>增量式并发收集器</code>（Incremental Concurrent Mark Sweep/i-CMS）；类似使用抢占式来模拟多任务机制的思想，让收集线程和用户线程交替运行，减少收集线程运行时间；但效果并不理想，JDK1.6 后官方就不再提倡用户使用。</p>
<p>2、<code>无法处理浮动垃圾</code>，可能出现<code>Concurrent Mode Failure</code>失败<br>1）<strong>浮动垃圾（Floating Garbage）</strong><br>在并发清除时，用户线程新产生的垃圾，称为浮动垃圾；这使得并发清除时需要预留一定的内存空间，不能像其它收集器在老年代几乎填满再进行收集；也可以认为 CMS 所需要的空间比其它垃圾收集器大；使用<code>-XX:CMSInitiatingOccupancyFraction</code>设置当年老代内存使用率达到此值时，触发 CMS 收集器（可以理解为 CMS 预留内存）。JDK1.5 默认值为 68%；JDK1.6 变为大约 92%。<br>2）<strong>Concurrent Mode Failure 失败</strong><br>如果 CMS 预留内存空间无法满足程序需要，就会出现一次<code>Concurrent Mode Failure</code>失败；这时 JVM 启用后备预案：临时启用 Serail Old 收集器，而导致另一次 Full GC 的产生；这样的代价是很大的，所以 CMSInitiatingOccupancyFraction 不能设置得太大。</p>
<p>3、<code>产生大量内存碎片</code><br>由于 CMS 基于”标记-清除”算法，清除后不进行压缩操作；  产生大量不连续的内存碎片会导致分配大内存对象时，无法找到足够的连续内存，从而需要提前触发另一次 Full GC 动作。解决方法：</p>
<ul>
<li><code>-XX:+UseCMSCompactAtFullCollection</code><br>使得 CMS 出现上面这种情况时不进行 Full GC，而开启内存碎片的合并整理过程；但合并整理过程无法并发，停顿时间会变长；此选项默认开启（但不会进行，结合下面的 CMSFullGCsBeforeCompaction）；</li>
<li><code>-XX:CMSFullGCsBeforeCompaction</code><br>设置执行多少次不压缩的 Full GC 后，来一次压缩整理；为减少合并整理过程的停顿时间；默认为 0，也就是说每次都执行 Full GC，不会进行压缩整理；由于空间不再连续，CMS 需要使用可用”空闲列表”内存分配方式，这比简单实用”碰撞指针”分配内存消耗大。</li>
</ul>
<blockquote>
<p>以上两个 JVM 启动选项已被标记为 Deprecated，不建议使用</p>
</blockquote>
<p>总体来看，与 Parallel Old 垃圾收集器相比，CMS <strong>减少了执行老年代垃圾收集时应用暂停的时间</strong>；但<strong>却增加了新生代垃圾收集时应用暂停的时间</strong>、降低了吞吐量而且<strong>需要占用更大的堆空间</strong>。</p>
<p><strong><code>G1</code>收集器</strong><br>G1（Garbage-First）是 JDK1.7-u4 才推出商用的收集器，在 JDK1.9 中，被提议作为默认的 GC 收集器。</p>
<p><strong>特点</strong></p>
<ul>
<li><code>并行与并发</code><br>能充分利用多 CPU、多核环境下的硬件优势；可以并行来缩短”Stop The World”停顿时间；也可以并发让垃圾收集与用户程序同时进行。</li>
<li><code>整堆收集</code><br>能独立管理整个 GC 堆（年轻代和年老代），而不需要与其它收集器搭配；能够采用不同方式处理不同时期的对象；<br>虽然保留分代概念，但 Java 堆的内存布局有很大差别；G1 将整个堆划分为多个大小相等的独立<code>区域（Region）</code>；新生代和老年代不再是物理隔离，它们都是一部分 Region（不需要连续）的集合。</li>
<li><code>空间整合</code><br>从整体看，是基于<code>标记-整理</code>算法；从局部（两个 Region 间）看，是基于<code>停止-复制</code>算法。这是一种类似火车算法的实现；不会产生内存碎片，有利于长时间运行。</li>
<li><code>可预测的停顿</code><br>在低停顿的同时实现高吞吐量；G1 除了追求低停顿外，还能建立可预测的停顿时间模型；可以明确指定 M 毫秒时间片内，垃圾收集消耗的时间不超过 N 毫秒。</li>
</ul>
<p><strong>适用场景</strong><br>面向<strong>服务端</strong>应用，针对具有<strong>大内存</strong>、<strong>多处理器</strong>的机器。最主要的应用是为需要低 GC 延迟，并具有大堆的应用程序提供解决方案。比如：在堆大小约 6GB 或更大时，可预测的暂停时间可以低于 0.5 秒。HotSpot 打算用来替换掉 JDK1.5 中的 CMS 收集器。</p>
<p>在下面的情况时，使用 G1 可能比 CMS 好：</p>
<ul>
<li>超过 50% 的 Java 堆被活动数据占用；</li>
<li>对象分配频率或年代提升频率变化很大；</li>
<li>GC 停顿时间过长（长于 0.5 至 1 秒）。</li>
</ul>
<p>是否一定采用 G1 呢？也未必。如果现在采用的收集器没有出现问题，不用急着去选择 G1；如果应用程序追求低停顿，可以尝试选择 G1；是否代替 CMS 需要实际场景测试才知道。</p>
<p><strong>启动参数</strong><br><code>-XX:+UseG1GC</code>：启用 G1 收集器<br><code>-XX:InitiatingHeapOccupancyPercent</code>：当整个 Java 堆的占用率达到参数值时，开始并发标记阶段；默认为 45<br><code>-XX:MaxGCPauseMillis</code>：为 G1 设置暂停时间目标，默认值为 200 毫秒<br><code>-XX:G1HeapRegionSize</code>：设置每个 Region 大小，范围 1MB 到 32MB；目标是在最小 Java 堆时可以拥有约 2048 个 Region</p>
<p><strong>为什么 G1 可实现可预测的停顿</strong>？</p>
<ul>
<li>G1 可以有计划地避免在 Java 堆的进行全区域的垃圾收集；</li>
<li>G1 跟踪各个 Region 获得其收集价值大小，在后台维护一个优先列表；</li>
<li>G1 每次根据允许的收集时间，优先回收价值最大的 Region（名称 Garbage-First 的由来）。</li>
</ul>
<p>这就保证了在有限的时间内可以获取尽可能高的收集效率。</p>
<p><strong>一个对象被不同 Region 引用的问题</strong><br>一个 Region 不可能是孤立的，一个 Region 中的对象可能被其它任意 Region 中对象引用，判断对象存活时，是否需要扫描整个 Java 堆才能保证准确？在其它的分代收集器，也存在这样的问题（而 G1 更突出）：回收新生代也不得不同时扫描老年代？这样的话会降低 Minor GC 的效率。</p>
<p>解决方法：无论 G1 还是其它分代收集器，JVM 都是使用 Remembered Set 来避免全局扫描；即每个 Region 都有一个对应的 Remembered Set；每次 Reference 类型数据写操作时，都会产生一个 Write Barrier 暂时中断操作；然后检查将要写入的引用指向的对象是否和该 Reference 类型数据在不同的 Region（其它收集器：检查老年代对象是否引用了新生代对象）；如果不同，则通过 CardTable 把相关引用信息记录到引用指向对象的所在 Region 对应的 Remembered Set 中；当进行垃圾收集时，在 GC Roots 枚举范围加入 Remembered Set；就可以保证不进行全局扫描，也不会有遗漏。</p>
<p><strong>G1 收集器运作过程</strong><br>如果不计算维护 Remembered Set 的操作，可以分为 4 个步骤（与 CMS 较为相似）<br><img src="/images/jvm-g1.jpg" alt="G1 收集器运作过程"></p>
<ul>
<li><code>初始标记（Initial Marking）</code><br>仅标记一下 GC Roots 能直接关联到的对象；且修改 TAMS（Next Top at Mark Start），让下一阶段并发运行时，用户程序能在正确可用的 Region 中创建新对象。需要”Stop The World”，但速度很快。</li>
<li><code>并发标记（Concurrent Marking）</code><br>进行 GC Roots Tracing 的过程；标记出存活对象；耗时较长，但应用程序也在运行；不过不能保证可以标记出所有存活对象。</li>
<li><code>最终标记（Final Marking）</code><br>为了修正并发标记期间因用户程序继续运作而导致标记变动的那一部分对象的标记记录；上一阶段对象的变化记录在线程的 Remembered Set Log；这里把 Remembered Set Log 合并到 Remembered Set 中；需要”Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短。G1 采用多线程并行执行来提升效率。</li>
<li><code>筛选回收（Live Data Counting and Evacuation）</code><br>首先排序各个 Region 的回收价值和成本；然后根据用户期望的 GC 停顿时间来制定回收计划；最后按计划回收一些价值高的 Region 中垃圾对象；回收时采用”停止-复制”算法，从一个或多个 Region 复制存活对象到堆上的另一个空的 Region，并且在此过程中压缩和释放内存；可以并发进行，降低停顿时间，并增加吞吐量。</li>
</ul>
<p><strong>各版本的默认收集器</strong></p>
<ul>
<li>Java 7：Parallel + Parallel Old；</li>
<li>Java 8：Parallel + Parallel Old；</li>
<li>Java 9：Garbage-First GC（G1）。</li>
</ul>
<h2 id="javac-java-常用参数"><a href="#javac-java-常用参数" class="headerlink" title="javac/java 常用参数"></a>javac/java 常用参数</h2><h3 id="javac-常用参数"><a href="#javac-常用参数" class="headerlink" title="javac 常用参数"></a>javac 常用参数</h3><p><code>-classpath/cp &lt;paths&gt;</code>：import 搜索路径</p>
<p><code>-deprecation</code>：输出使用过时 API 警告<br><code>-Xlint</code>：输出所有警告信息<br><code>-nowarn</code>：不输出任何警告信息<br><code>-Werror</code>：出现警告时终止编译</p>
<p><code>-g</code>：生成调试信息<br><code>-g:none</code>：不生成调试信息</p>
<p><code>-d &lt;目录&gt;</code>：指定存放类文件的目录<br><code>-encoding &lt;encoding&gt;</code>：指定源文件编码</p>
<p><code>-source &lt;jdk版本&gt;</code>：指定源文件 jdk 版本<br><code>-target &lt;jdk版本&gt;</code>：指定类文件 jdk 版本</p>
<p><code>-bootclasspath &lt;paths&gt;</code>：指定 bootstrap 核心类的路径<br><code>-extdirs &lt;dirs&gt;</code>：指定 extension 扩展类的路径</p>
<p><code>@&lt;filename&gt;</code>：从给定文件中读取选项和源文件参数</p>
<h3 id="java-标准参数"><a href="#java-标准参数" class="headerlink" title="java 标准参数"></a>java 标准参数</h3><p><code>java [-options] class [args...]</code>：执行 .class 文件<br><code>java [-options] -jar jarfile [args...]</code>：执行 jar 文件</p>
<p><code>-classpath/cp &lt;paths&gt;</code>：指定 ClassPath 搜索路径</p>
<p><code>-d32</code>：使用 32 位数据模型（如果可用）<br><code>-d64</code>：使用 64 位数据模型（如果可用）</p>
<p><code>-client</code>：使用 Client VM 虚拟机（64-bit 无效）<br><code>-server</code>：使用 Server VM 虚拟机（64-bit 默认）</p>
<p><code>-ea/enableassertions</code>：启用 assert 断言<br><code>-da/disableassertions</code>：禁用 assert 断言（默认）</p>
<p><code>-D&lt;name&gt;=&lt;value&gt;</code>：设置系统属性（Java 属性）</p>
<p><code>-verbose:[class|gc|jni]</code>：启用 class|gc|jni 详细输出</p>
<p><code>-version</code>：打印 JVM 版本信息然后退出<br><code>-showversion</code>：打印 JVM 版本信息然后继续</p>
<h3 id="java-非标参数"><a href="#java-非标参数" class="headerlink" title="java 非标参数"></a>java 非标参数</h3><p><strong>运行模式</strong><br><code>-Xint</code>：纯解释模式<br><code>-Xcomp</code>：纯编译模式<br><code>-Xmixed</code>：混合模式（默认）</p>
<p><strong>查看设置</strong><br><code>-XshowSettings</code>：打印所有设置并继续<br><code>-XshowSettings:all</code>：打印所有设置并继续<br><code>-XshowSettings:vm</code>：打印 VM 设置并继续<br><code>-XshowSettings:properties</code>：打印属性设置并继续<br><code>-XshowSettings:locale</code>：打印本地化设置并继续</p>
<p><strong>查看选项</strong><br><code>-XX:+PrintFlagsInitial</code>：打印 JVM 默认运行参数后退出<br><code>-XX:+PrintFlagsFinal</code>：打印 JVM 当前运行参数后继续运行</p>
<p><strong>核心类路径</strong><br><code>-Xbootclasspath:&lt;dirs/zip/jar&gt;</code>：覆盖 bootstrap 核心类搜索路径<br><code>-Xbootclasspath/a:&lt;dirs/zip/jar&gt;</code>：追加 bootstrap 核心类搜索路径<br><code>-Xbootclasspath/p:&lt;dirs/zip/jar&gt;</code>：插入 bootstrap 核心类搜索路径</p>
<p><strong>内存相关</strong><br><code>-Xss&lt;size&gt;</code>：线程栈大小<br><code>-Xms&lt;size&gt;</code>：初始堆大小<br><code>-Xmx&lt;size&gt;</code>：最大堆大小<br><code>-Xmn&lt;size&gt;</code>：年轻代大小，参考值：堆大小的 3/8<br><code>-XX:SurvivorRatio=&lt;int&gt;</code>：年轻代各区大小比例，默认为 8，即 Eden 80%、Survivor0 10%、Survivor1 10%<br><code>-XX:MaxTenuringThreshold=&lt;age&gt;</code>：进入年老代的对象最大年龄，default 15、CMS 6<br><code>-XX:+UseAdaptiveSizePolicy</code>：动态控制 Java 堆中各个区域的大小以及进入年老代的年龄<br><code>-XX:PretenureSizeThreshold=&lt;size&gt;</code>：如果一个对象的大小大于该值，那么直接进入年老代</p>
<p><strong>永久代相关</strong><br><code>-Xnoclassgc</code>：不对无用的类进行回收<br><code>-XX:Permsize=&lt;size&gt;</code>：初始永久代大小<br><code>-XX:MaxPermsize=&lt;size&gt;</code>：最大永久代大小</p>
<p><strong>元空间相关</strong><br><code>-XX:MetaspaceSize=&lt;size&gt;</code>：设置元空间初始大小，默认值为 16 M<br><code>-XX:MaxMetaspaceSize=&lt;size&gt;</code>：设置元空间最大大小，默认不限制<br><code>-XX:MinMetaspaceFreeRatio=&lt;int&gt;</code>：设置空闲元空间容量的最小占比<br><code>-XX:MaxMetaspaceFreeRatio=&lt;int&gt;</code>：设置空闲元空间容量的最大占比<br><code>-XX:MinMetaspaceExpansion=&lt;size&gt;</code>：设置元空间每次扩展的最小大小<br><code>-XX:MaxMetaspaceExpansion=&lt;size&gt;</code>：设置元空间每次扩展的最大大小（不进行 Full GC）</p>
<p><strong>致命错误</strong><br><code>-XX:OnError=&lt;command&gt;</code>：发生不可恢复错误时运行 command 指定的命令，命令中使用<code>%p</code>可引用 PID 信息<br><code>-XX:ErrorFile=&lt;filename&gt;</code>：发生不可恢复错误时将错误信息写入指定文件，文件名使用<code>%p</code>可引用 PID 信息<br><code>-XX:OnOutOfMemoryError=&lt;command&gt;</code>：发生 OOM 错误时运行 command 指定的命令，使用<code>%p</code>可引用 PID 信息<br><code>-XX:+HeapDumpOnOutOfMemoryError</code>：在发生 OOM 时生成堆转储文件<br><code>-XX:HeapDumpPath=&lt;path&gt;</code>：设置堆转储文件的名称，使用<code>%p</code>可引用 PID 信息，默认为<code>./java_pid%p.hprof</code></p>
<p><strong>类加载跟踪</strong><br><code>-XX:+TraceClassLoading</code>：跟踪类加载信息<br><code>-XX:+TraceClassLoadingPreorder</code>：跟踪类加载信息（按顺序）<br><code>-XX:+TraceClassResolution</code>：跟踪类解析信息<br><code>-XX:+TraceClassUnloading</code>：跟踪类卸载信息</p>
<p><strong>偏向锁相关</strong><br><code>-XX:+UseBiasedLocking</code>：启用偏向锁（默认启用，但有 4000ms 延迟）<br><code>-XX:BiasedLockingStartupDelay=&lt;int&gt;</code>：设置偏向锁启动延迟（毫秒）<br><code>-XX:-UseBiasedLocking</code>：禁用偏向锁</p>
<p><strong>压缩指针</strong><br><code>-XX:+UseCompressedOops</code>：启用压缩指针（64-bit 默认）<br><code>-XX:-UseCompressedOops</code>：禁用压缩指针</p>
<p><strong>GC 收集器</strong><br><code>-XX:+UseSerialGC</code>：启用 Serial 收集器</p>
<p><code>-XX:+UseParNewGC</code>：启用 ParNew 收集器<br><code>-XX:ParallelGCThreads=&lt;int&gt;</code>：设置 GC 线程数量，默认与可用 CPU 核数相同</p>
<p><code>-XX:+UseParallelGC</code>：启用 Parallel Scavenge 收集器<br><code>-XX:+UseParallelOldGC</code>：启用 Parallel Old 收集器<br><code>-XX:MaxGCPauseMillis=&lt;int&gt;</code>：设置用户线程最大停顿时间（毫秒），设置过小可能导致 GC 发生更频繁<br><code>-XX:GCTimeRatio=&lt;int&gt;</code>：设置吞吐量大小，即用户线程执行时间与总时间的占比，默认为 99，即只有 %1 的时间用于 GC</p>
<p><code>-XX:+UseConcMarkSweepGC</code>：启用 CMS 收集器，默认方案 ParNew + CMS，备用方案 ParNew + Serial Old（内存不足时）<br><code>-XX:CMSInitiatingOccupancyFraction=&lt;int&gt;</code>：当年老代的内存使用率达到此值时，触发 CMS 垃圾收集器</p>
<p><code>-XX:+UseG1GC</code>：启用 G1 收集器<br><code>-XX:InitiatingHeapOccupancyPercent=&lt;int&gt;</code>：当整个堆的使用率达到此值时，开始并发标记阶段；默认为 45<br><code>-XX:MaxGCPauseMillis=&lt;int&gt;</code>：为 G1 设置暂停时间目标，默认值为 200 毫秒<br><code>-XX:G1HeapRegionSize=&lt;int&gt;</code>：设置每个 Region 大小（1~32 MB）；目标是在最小 Java 堆时可拥有约 2048 个 Region</p>
<p><strong>GC 调试相关</strong><br><code>-verbose:gc</code>：打印 GC 详细日志<br><code>-Xloggc:&lt;file&gt;</code>：记录 gc 详细日志（带时间戳）</p>
<p><code>-XX:+PrintGC</code>：打印 GC 基本日志<br><code>-XX:+PrintGCDetails</code>：打印 GC 详细日志<br><code>-XX:+PrintGCTimeStamps</code>：打印 GC 时间戳信息</p>
<p><code>-XX:+PrintGCApplicationStoppedTime</code>：打印 GC 期间程序暂停的时间<br><code>-XX:+PrintGCApplicationConcurrentTime</code>：打印每次垃圾回收前，程序未中断的执行时间</p>
<h2 id="JDK-常用自带工具"><a href="#JDK-常用自带工具" class="headerlink" title="JDK 常用自带工具"></a>JDK 常用自带工具</h2><p><code>jar</code>：jar 打包工具，用法与 tar 命令基本一致<br><code>javadoc</code>：Java 文档生成工具 - <a href="/java-javadoc.html">Java 文档生成</a><br><code>javah</code>：Java 头文件生成工具 - <a href="/java-jni.html">Java JNI 入门</a><br><code>javap</code>：Java 自带反编译工具，仅用于调试，如需完整反编译请尝试其它第三方工具<br><code>jdb</code>：Java 自带 Debug 工具，主要用于 Java 程序的断点调试<br><code>jconsole</code>：图形化用户界面的监测工具，主要用于监测并显示运行于 Java 平台上的应用程序的性能和资源占用等信息<br><code>jdeps</code>：JDK1.8 提供的依赖分析工具，用于查看 .class/.jar/dir 的依赖关系<br><code>jhat</code>：Java 堆分析工具（Java Heap Analysis Tool），用于分析 Java 堆内存中的对象信息<br><code>jinfo</code>：Java 配置信息工具（Java Configuration Information），用于打印指定 Java 进程、核心文件或远程调试服务器的配置信息<br><code>jmap</code>：Java 内存映射工具（Java Memory Map），主要用于打印指定 Java 进程、核心文件或远程调试服务器的共享对象内存映射或堆内存细节<br><code>jmc</code>：Java 任务控制工具（Java Mission Control），主要用于 HotSpot JVM 的生产时间监测、分析、诊断<br><code>jps</code>：JVM 进程状态工具（JVM Process Status Tool），用于显示当前系统上的 HotSpot JVM 的 Java 进程信息<br><code>jstack</code>：Java 堆栈跟踪工具，主要用于打印指定 Java 进程、核心文件或远程调试服务器的 Java 线程的堆栈跟踪信息<br><code>jstat</code>：JVM 统计监测工具（JVM Statistics Monitoring Tool），主要用于监测并显示 JVM 的性能统计信息<br><code>jstatd</code>：RMI 服务器应用，用于监测 HotSpot JVM 的创建和终止，并提供一个接口，允许远程监测工具附加到运行于本地主机的 JVM 上<br><code>jvisualvm</code>：JVM 监测、故障排除、分析工具，主要以图形化界面的方式提供运行于指定虚拟机的Java应用程序的详细信息<br><code>keytool</code>：Java 密钥和证书管理工具，主要用于密钥和证书的创建、修改、删除等<br><code>serialver</code>：Java 序列化 ID 生成工具，用于生成并返回 serialVersionUID 值<br><code>native2ascii</code>：Native 编码与 ASCII 码的转换器（将 Native 编码转换为 UTF-16 编码）</p>
<h3 id="jdb-调试器"><a href="#jdb-调试器" class="headerlink" title="jdb 调试器"></a>jdb 调试器</h3><p>相信很多人都听过 gdb，这可以说是调试界的鼻祖，在 Linux 中，通常都是使用 gdb 来进行 C/C++ 程序的调试。如果一个程序需要使用 gdb 来调试，必须先使用 gcc/g++ 的 -g 选项，生成 debug 信息。</p>
<p>同样的，在 Java 中，JDK 也提供了类似的命令行调试工具 - jdb（Java Debugger），不过，jdb 没有 gdb 这么多的玩法，比如 gdb 支持条件断点，jdb 就不行。同时，在调试 java 程序之前，我们通常会先使用<code>javac -g</code>编译源文件，来生成完整的 debug 信息（<code>source</code>、<code>lines</code>、<code>vars</code>），默认情况下只会生成<code>source</code>、<code>lines</code>两种 debug 信息。</p>
<p><strong>gdb 工作原理</strong></p>
<blockquote>
<p>在介绍 jdb 之前，我们先来看一下传统的 gdb 是怎么调试程序的。</p>
</blockquote>
<p>gdb 主要功能的实现依赖于<code>ptrace</code>系统调用，通过 man 手册可以了解到，ptrace 可以让父进程观察和控制其子进程的检查、执行，改变其寄存器和内存的内容，主要应用于打断点（也是 gdb 的主要功能）和打印系统调用轨迹。</p>
<p><strong>建立跟踪关系</strong><br>用 gdb 调试程序有 2 种模式，包括使用 gdb 启动程序，以及 attach 到现有进程。分别对应下面 2 种建立调试关系的方法：</p>
<ol>
<li>fork：利用 fork+execve 执行被测试的程序，子进程在执行 execve 之前调用 ptrace(PTRACE_TRACEME)，建立了与父进程（debugger）的跟踪关系。</li>
<li>attach：debugger 可以调用 ptrace(PTRACE_ATTACH, pid, …)，建立自己与进程号为 pid 的进程间的跟踪关系。即利用 PTRACE_ATTACH，使自己变成被调试程序的父进程。用 attach 建立起来的跟踪关系，可以调用 ptrace(PTRACE_DETACH, pid, …) 来解除。注意 attach 进程时的权限问题，如一个非 root 权限的进程是不能 attach 到一个 root 进程上的。</li>
</ol>
<p>在使用 ptrace 系统调用建立调试关系之后，发送给被调试程序的任何信号（SIGKILL 除外）都将被 gdb 先行截获，因此 gdb 有机会对信号进行相应的处理。</p>
<p><strong>gdb 断点功能的实现原理</strong><br>断点功能是通过内核信号实现的，以 x86 为例，内核向某个地址打入断点，实际上就是往该地址写入断点指令 INT 3，即 0xCC。被调试程序运行到这条指令之后就会触发 SIGTRAP 信号，gdb 捕获到这个信号，根据被调试程序当前停止位置查询 gdb 维护的断点链表，若发现在该地址确实存在断点，则可判定为断点命中。</p>
<p>可以看出，gdb 只能调试本机上的进程，对于运行在不同主机上的进程是无法进行调试的。但是 jdb 却可以，那么 jdb 的调试原理是什么呢？</p>
<p><strong>JPDA 体系</strong><br>无论是 IDE 自带的 debug 工具还是 JDK 自带的 jdb 工具，都支持<strong>本地</strong>和<strong>远程</strong>的程序调试，那么它们是如何被开发的？它们之间存在着什么样的联系呢？我们不得不提及 Java 的调试体系 —— JPDA（Java Platform Debugger Architecture）。</p>
<p>我们知道，Java 程序都是运行在 JVM 上的，我们要调试 Java 程序，事实上就是向 JVM 请求当前运行态的状态，并对 JVM 发送一定的指令，设置一些回调等等，那么 Java 的调试体系，就是 JVM 的一整套<strong>用于调试的工具和接口</strong>。</p>
<p>对于 JVM 接口熟悉的人来说，您一定还记得 Java 提供了两个接口体系，<code>JVMPI（Java Virtual Machine Profiler Interface）</code>和<code>JVMDI（Java Virtual Machine Debug Interface）</code>，以及在 Java SE 5 中准备代替它们的<code>JVMTI（Java Virtual Machine Tool Interface）</code>，都是<code>Java 平台调试体系（Java Platform Debugger Architecture，JPDA）</code>的重要组成部分。Java SE 自 1.2.2 版就开始推出 Java 平台调试体系结构（JPDA）工具集，而从 JDK 1.3.x 开始，Java SDK 就提供了对 Java 平台调试体系结构的直接支持。顾名思义，这个体系为开发人员提供了一整套用于调试 Java 程序的 API，是一套用于开发 Java 调试工具的接口和协议。本质上说，它是我们通向 JVM，考察 JVM 运行态的一个通道，一套工具。理解这一点对于学习 JPDA 非常重要。</p>
<p>换句话说，通过 JPDA 这套接口，我们就可以开发自己的调试工具。通过这些 JPDA 提供的接口和协议，调试器开发人员就能根据特定开发者的需求，扩展定制 Java 调试应用程序，开发出吸引开发人员使用的调试工具。前面我们提到的 IDE 调试工具都是基于 JPDA 体系开发的，区别仅仅在于它们可能提供了不同的图形界面、具有一些不同的自定义功能。另外，我们要注意的是，JPDA 是一套标准，任何的 JDK 实现都必须完成这个标准，因此，通过 JPDA 开发出来的调试工具先天具有跨平台、不依赖虚拟机实现、JDK 版本无关等移植优点，因此大部分的调试工具都是基于这个体系的。</p>
<p><strong>JPDA 组成模块</strong><br>JPDA 定义了一个完整独立的体系，它由<strong>三个相对独立的层次</strong>共同组成，而且规定了它们三者之间的交互方式，或者说定义了它们通信的接口。这三个层次<strong>由低到高</strong>分别是：</p>
<ul>
<li><code>Java 虚拟机工具接口（JVMTI）</code>：被调试者（debuggee）</li>
<li><code>Java 调试线协议（JDWP）</code>：通信协议，主要方式为 socket</li>
<li><code>Java 调试接口（JDI）</code>：调试者（debugger）</li>
</ul>
<p>JVMTI、JDWP、JDI 三者之间的关系：<br><img src="/images/jvm-jpda.jpg" alt="JPDA 各模块之间的关系"></p>
<p>在 JDB 中的实现方式：<br><img src="/images/jvm-jpda-jdb.jpg" alt="JPDA 各模块之间的关系 - JDB"></p>
<ol>
<li><strong>被调试者</strong>运行于我们想调试的 JVM 之上，它可以通过 JVMTI 这个标准接口，监控当前 JVM 的信息；</li>
<li><strong>调试者</strong>定义了用户可使用的调试接口，通过这些接口，用户可以对<strong>被调试者</strong>发送调试命令，同时<strong>调试者</strong>接受并显示调试结果；</li>
<li>在<strong>调试者</strong>和<strong>被调试者</strong>之间，调试命令和调试结果，都是通过 JDWP 协议传输的。<ul>
<li><strong>调试者</strong>发送的命令被封装成 JDWP 命令包，通过传输层发送给<strong>被调试者</strong>，<strong>被调试者</strong>接收到 JDWP 命令包后，解析这个命令并转化为 JVMTI 的调用，在<strong>被调试者</strong>上运行；</li>
<li>类似的，JVMTI 的运行结果，被格式化成 JDWP 数据包，发送给<strong>调试者</strong>并返回给 JDI 调用。而调试器开发人员就是通过 JDI 得到数据，发出指令的。</li>
</ul>
</li>
</ol>
<p>当然，开发人员完全可以不使用完整的三个层次，而是基于其中的某一个层次开发自己的应用。比如您完全可以仅仅依靠通过 JVMTI 函数开发一个调试工具，而不使用 JDWP 和 JDI，只使用自己的通讯和命令接口。当然，除非是有特殊的需求，利用已有的实现会使您事半功倍，避免重复发明轮子。</p>
<p><strong>Java 虚拟机工具接口（JVMTI）</strong><br><code>JVMTI（Java Virtual Machine Tool Interface）</code>即指 Java 虚拟机工具接口，它是一套由 JVM 直接提供的 native 接口，它处于整个 JPDA 体系的<strong>最底层</strong>，<strong>所有调试功能本质上都需要通过 JVMTI 来提供</strong>。通过这些接口，开发人员不仅调试在该虚拟机上运行的 Java 程序，还能查看它们运行的状态，设置回调函数，控制某些环境变量，从而优化程序性能。</p>
<p>我们知道，JVMTI 的前身是 JVMDI 和 JVMPI，它们原来分别被用于提供调试 Java 程序和调节 Java 程序的性能。在 J2SE 5.0 之后，JDK 取代了 JVMDI 和 JVMPI 这两套接口，JVMDI 在最新的 Java SE 6 中已经不提供支持，而 JVMPI 也计划在 Java SE 7 后被彻底取代。</p>
<p><strong>Java 调试线协议（JDWP）</strong><br><code>JDWP（Java Debug Wire Protocol）</code>是一个为 Java 调试而设计的一个通讯交互协议，它<strong>定义了<code>调试器</code>和<code>被调试程序</code>之间传递的信息的<code>格式</code></strong>。在 JPDA 体系中，调试者与被调试者进程之间的交互数据的格式就是由 JDWP 来描述的。它详细完整地定义了<strong>请求命令</strong>、<strong>回应数据</strong>和<strong>错误代码</strong>，保证了 JVMTI 和 JDI 的通信通畅。</p>
<p>比如在 Sun 公司提供的实现中，它提供了一个名为<code>jdwp.dll(jdwp.so)</code>的动态链接库文件，这个动态库文件实现了一个 Agent（代理人），它会负责解析接收到的请求或者命令，并将其转化为 JVMTI 调用，然后将 JVMTI 函数的返回信息封装成 JDWP 数据返回给发送者。</p>
<p>另外，这里需要注意的是 JDWP 本身并不包括传输层的实现，传输层需要独立实现，但是 JDWP 包括了和传输层交互的严格的定义，就是说，JDWP 协议虽然不规定我们是通过 EMS 还是快递运送货物的，但是它规定了我们传送的货物的摆放的方式。</p>
<p>在 Sun 公司提供的 JDK 中，在传输层上，它提供了 socket 方式，以及在 Windows 上的 shared memory 方式。当然，传输层本身无非就是本机内进程间通信方式和远端通信方式，用户有兴趣也可以按 JDWP 的标准自己实现。</p>
<p><strong>Java 调试接口（JDI）</strong><br><code>JDI（Java Debug Interface）</code>是三个模块中<strong>最高层</strong>的接口，在多数的 JDK 中，它是<strong>由 Java 语言实现</strong>的。通过 JDI，调试工具开发人员就能通过前端 JVM 上的调试器来远程操控后端 JVM 上被调试程序的运行。JDI 不仅能帮助开发人员格式化 JDWP 数据，而且还能为 JDWP 数据传输提供队列、缓存等优化服务。从理论上说，开发人员只需使用 JDWP 和 JVMTI 即可支持跨平台的远程调试，但是直接编写 JDWP 程序费时费力，而且效率不高。因此基于 Java 的 JDI 层的引入，简化了操作，提高了开发人员开发调试程序的效率。</p>
<p><strong>JVMTI、JDWP、JDI 比较</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">模块</th>
<th style="text-align:center">层次</th>
<th style="text-align:center">语言</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>JVMTI</code></td>
<td style="text-align:center">底层</td>
<td style="text-align:center">C</td>
<td style="text-align:center">获取及控制当前虚拟机状态</td>
</tr>
<tr>
<td style="text-align:center"><code>JDWP</code></td>
<td style="text-align:center">中介层</td>
<td style="text-align:center">C</td>
<td style="text-align:center">定义 JVMTI 和 JDI 交互的数据格式</td>
</tr>
<tr>
<td style="text-align:center"><code>JDI</code></td>
<td style="text-align:center">高层</td>
<td style="text-align:center">Java</td>
<td style="text-align:center">提供 Java API 来远程控制被调试虚拟机</td>
</tr>
</tbody>
</table>
<p><strong>Java 调试接口的特点</strong><br>Java 语言是第一个使用虚拟机概念的流行的编程语言，正是因为虚拟机的存在，使很多事情变得简单而轻松，掌握了虚拟机，就掌握了内存分配、线程管理、即时优化等等运行态。同样的，Java 调试的本质，就是和虚拟机打交道，通过操作虚拟机来达到观察调试我们自己代码的目的。这个特点决定了 Java 调试接口和以前其他编程语言的巨大区别。</p>
<p>以 C/C++ 的调试为例，目前比较流行的调试工具是 GDB 和微软的 Visual Studio 自带的 debugger，在这种 debugger 中，首先，我们必须编译一个“debug”模式的程序，这个会比实际的 release 模式程序大很多。其次，在调试过程中，debugger 将会深层接入程序的运行，掌握和控制运行态的一些信息，并将这些信息及时返回。这种介入对运行的效率和内存占用都有一定的需求。基于这些需求，这些 Debugger 本身事实上是提供了，或者说，创建和管理了一个运行态，因此他们的程序算法比较复杂，个头都比较大。对于远端的调试，GDB 也没有很好的默认实现，当然，C/C++ 在这方面也没有特别大的需求。</p>
<p>而 Java 则不同，由于 Java 的运行态已经被 JVM 很好地管理，因此作为 Java 的 Debugger 无需再自己创造一个可控的运行态，而仅仅需要去操作虚拟机就可以了。Java 的 JPDA 就是一套为调试和优化服务的虚拟机的操作工具，其中，<strong>JVMTI 是整合在虚拟机中的接口</strong>，<strong>JDWP 是一个通讯层</strong>，而<strong>JDI 是为开发人员准备好的工具和运行库</strong>。</p>
<p>从构架上说，我们可以把 JPDA 看作成是一个 C/S 体系结构的应用，在这个构架下，我们可以方便地通过网络，在任意的地点调试另外一个 JVM 上的程序，这个就很好地解决了部署和测试的问题，尤其满足解决了很多网络时代中的开发应用的需求。前端和后端的分离，也方便用户开发适合于自己的调试工具。</p>
<p>从效率上看，由于 Java 程序本身就是编译成字节码，运行在 JVM 上的，因此调试前后的程序、内存占用都不会有大变化（仅仅是启动一个 JDWP 所需要的内存），任意程度都可以很好地调试，非常方便。而 JPDA 构架下的几个组成部分，JDWP 和 JDI 都比较小，主要的工作可以让虚拟机自己完成。</p>
<p>从灵活性上，Java 调试工具是建立在强大的 JVM 上的，因此，很多前沿的应用，比如动态编译运行，字节码的实时替换等等，都可以通过对 JVM 的改进而得到实现。随着虚拟机技术的逐步发展和深入，各种不同种类，不同应用领域中虚拟机的出现，各种强大的功能的加入，给我们的调试工具也带来很多新的应用。</p>
<p>总而言之，一个先天的，可控的运行态给 Java 的调试工作，给 Java 调试接口带来了极大的优势和便利。通过 JPDA 这个标准，我们可以从 JVM 中得到我们所需要的信息，完成我们所希望的操作，更好地开发我们的程序。</p>
<p><strong>如何使用 JDB 调试 Java 程序</strong>？<br>首先我们知道，被调试者（debuggee）就是<strong>运行被调试程序的 JVM</strong>。不过 JVM 并没有在内部集成 JDWP 中间层，而是将 JDWP 的具体实现打包为<code>jdwp.so/jdwp.dll</code>动态链接库，在要用到的时候动态的挂接到 JVM 中。因此，我们要给 JVM 传递一个启动参数，让它先加载 JDWP 动态链接库，使用<code>java -agentlib:&lt;libname&gt;[=&lt;options&gt;]</code>选项。</p>
<p>因为 JPDA 是 C/S 体系结构，因此，我们有两种连接方式可选择：</p>
<ol>
<li><strong>JDB 作为服务端，被调试者作为客户端</strong><ul>
<li>JDB 先启动，监听一个 socket 地址，假设为 127.0.0.1:8080，然后等待被调试者 attach 到 JDB 上；</li>
<li>被调试者挂接 JDWP，然后在本地随机选择一个可用端口，attach 到 JDB 的 socket 地址上，开始调试。</li>
</ul>
</li>
<li><strong>被调试者作为服务端，JDB 作为客户端</strong><ul>
<li>被调试者挂接 JDWP，监听一个 socket 地址，假设为 127.0.0.1:8080，然后等待 JDB attach；</li>
<li>启动 JDB，在本地随机选择一个可用端口，然后 attach 到被调试者的 socket 地址上，开始调试。</li>
</ul>
</li>
</ol>
<p>第一种方式的具体操作：<br>服务端：<code>jdb -connect com.sun.jdi.SocketListen:localAddress=127.0.0.1,port=8080</code><br>客户端：<code>java -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:8080 Test</code></p>
<p>第二种方式的具体操作：<br>服务端：<code>java -agentlib:jdwp=transport=dt_socket,address=127.0.0.1:8080,server=y Test</code><br>客户端：<code>jdb -connect com.sun.jdi.SocketAttach:hostname=127.0.0.1,port=8080</code></p>
<p>不过，JDB 提供了更简便的方法，直接使用<code>jdb Test</code>即可，执行完毕后，JDB 首先监听某个端口，作为服务端，然后 fork 一个新进程，运行 JVM，然后让它 attach 到这个监听的端口，开始进行 JDB 调试。这其实就是我们说的第一种方式。</p>
<p><strong>启动 JDB</strong><br><code>jdb</code>：启动 JDB 调试器，启动后，可以通过<code>run [class [args]]</code>内置命令运行给定的类并传递命令行参数，<strong>推荐此方式</strong><br><code>jdb Test</code>：启动 JDB 调试器，与 Test.class 关联，只有无参<code>run</code>才会使用关联的类，使用<code>run [class [args]]</code>会覆盖它</p>
<p><strong>调试命令</strong></p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 相关说明 */
<expr>              a Java(TM) Programming Language expression.
<class id>          a full class name with package qualifiers
<class pattern>     a class name with a leading or trailing wildcard ('*')
<thread id>         thread number as reported in the 'threads' command

/* 注释、帮助 */
# <command>               -- discard (no-op)
help (or ?)               -- list commands
version                   -- print version information
exit (or quit)            -- exit debugger

/* 重复历史命令 */
!!                        -- repeat last command
<n> <command>             -- repeat command n times

/* 从文件中读取命令并执行 */
read <filename>           -- read and execute a command file

/* 可用的连接器 */
connectors                -- list available connectors and transports in this VM
/* 查看 classpath */
classpath                 -- print classpath info from target VM

/* 查看源代码 */
list [line number|method] -- print source code
use (or sourcepath) [source file path]
                          -- display or change the source path
/* 重载源代码 */
redefine <class id> <class file name>
                          -- redefine the code for a class

/* 类/方法/字段信息 */
classes                   -- list currently known classes
class <class id>          -- show details of named class
methods <class id>        -- list a class's methods
fields <class id>         -- list a class's fields

/* 忽略指定类的跟踪 */
// 默认忽略的类有：java.*、javax.*、sun.*、com.sun.*
exclude [<class pattern>, ... | "none"]
                          -- do not report step or method events for specified classes

/* 设置断点 */
stop in <class id>.<method>[(argument_type,...)]
                          -- set a breakpoint in a method
stop at <class id>:<line> -- set a breakpoint at a line
/* 管理断点 */
clear <class id>.<method>[(argument_type,...)]
                          -- clear a breakpoint in a method
clear <class id>:<line>   -- clear a breakpoint at a line
clear                     -- list breakpoints

/* 运行给定主类 */
run [class [args]]        -- start execution of application's main class

/* 查看/修改变量 */
print <expr>              -- print value of expression
dump <expr>               -- print all object information
eval <expr>               -- evaluate expression (same as print)
locals                    -- print all local variables in current stack frame
set <lvalue> = <expr>     -- assign new value to field/variable/array element

/* 单步调试 */
step                      -- execute current line
step up                   -- execute until the current method returns to its caller
stepi                     -- execute current instruction
next                      -- step one line (step OVER calls)
cont                      -- continue execution from breakpoint

/* 自动命令 (程序停止时自动执行) */
monitor <command>         -- execute command each time the program stops
monitor                   -- list monitors
unmonitor <monitor#>      -- delete a monitor

/* 线程控制相关 */
threads [threadgroup]     -- list threads
thread <thread id>        -- set default thread

threadgroups              -- list threadgroups
threadgroup <name>        -- set current threadgroup

suspend [thread id(s)]    -- suspend threads (default: all)
resume [thread id(s)]     -- resume threads (default: all)

where [<thread id> | all] -- dump a thread's stack
wherei [<thread id> | all]-- dump a thread's stack, with pc info

up [n frames]             -- move up a thread's stack
down [n frames]           -- move down a thread's stack

interrupt <thread id>     -- interrupt a thread
kill <thread id> <expr>   -- kill a thread with the given exception object

/* 弹出/重入栈帧 */
pop                       -- pop the stack through and including the current frame
reenter                   -- same as pop, but current frame is reentered

/* 捕获异常 */
catch [uncaught|caught|all] <class id>|<class pattern>
                          -- break when specified exception occurs
ignore [uncaught|caught|all] <class id>|<class pattern>
                          -- cancel 'catch' for the specified exception

/* 监视字段 (字段变化时自动暂停程序) */
watch [access|all] <class id>.<field name>
                          -- watch access/modifications to a field
unwatch [access|all] <class id>.<field name>
                          -- discontinue watching access/modifications to a field

/* 跟踪方法 (进入/退出方法时，暂停程序/打印相关信息) */
trace [go] methods [thread]
                          -- trace method entries and exits.
                          -- All threads are suspended unless 'go' is specified
trace [go] method exit | exits [thread]
                          -- trace the current method's exit, or all methods' exits
                          -- All threads are suspended unless 'go' is specified
untrace [methods]         -- stop tracing method entrys and/or exits

/* 查看 lock 锁信息 */
lock <expr>               -- print lock info for an object
threadlocks [thread id]   -- print lock info for a thread

/* 关闭/启用 GC */
disablegc <expr>          -- prevent garbage collection of an object
enablegc <expr>           -- permit garbage collection of an object
</script></code></pre>
<p><strong>JDB 调试例子</strong><br>一个简单的测试类：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">public class Test {
    public static void main(String[] args) {
        int a = 10;
        int b = 20;
        int c = add(a, b);
        System.out.printf("%d + %d = %d\n", a, b, c);
    }

    private static int add(int x, int y) {
        int z = x + y;
        return z;
    }
}
</script></code></pre>
<p>使用 JDB 进行调试：</p>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/java8-learn/com/zfl9/debug on git:master x [20:25:10]
$ javac -g Test.java

# root @ arch in ~/java8-learn/com/zfl9/debug on git:master x [20:25:15]
$ jdb
Initializing jdb ...
> stop in Test.main
Deferring breakpoint Test.main.
It will be set after the class is loaded.
> run Test
run  Test
Set uncaught java.lang.Throwable
Set deferred uncaught java.lang.Throwable
>
VM Started: Set deferred breakpoint Test.main

Breakpoint hit: "thread=main", Test.main(), line=3 bci=0
3            int a = 10;

main[1] list
1    public class Test {
2        public static void main(String[] args) {
3 =>         int a = 10;
4            int b = 20;
5            int c = add(a, b);
6            System.out.printf("%d + %d = %d\n", a, b, c);
7        }
8
9        private static int add(int x, int y) {
10            int z = x + y;
main[1] clear
Breakpoints set:
    breakpoint Test.main
main[1] locals
Method arguments:
args = instance of java.lang.String[0] (id=403)
Local variables:
main[1] step
>
Step completed: "thread=main", Test.main(), line=4 bci=3
4            int b = 20;

main[1] locals
Method arguments:
args = instance of java.lang.String[0] (id=403)
Local variables:
a = 10
main[1] list
1    public class Test {
2        public static void main(String[] args) {
3            int a = 10;
4 =>         int b = 20;
5            int c = add(a, b);
6            System.out.printf("%d + %d = %d\n", a, b, c);
7        }
8
9        private static int add(int x, int y) {
10            int z = x + y;
main[1] step
>
Step completed: "thread=main", Test.main(), line=5 bci=6
5            int c = add(a, b);

main[1] list
1    public class Test {
2        public static void main(String[] args) {
3            int a = 10;
4            int b = 20;
5 =>         int c = add(a, b);
6            System.out.printf("%d + %d = %d\n", a, b, c);
7        }
8
9        private static int add(int x, int y) {
10            int z = x + y;
main[1] locals
Method arguments:
args = instance of java.lang.String[0] (id=403)
Local variables:
a = 10
b = 20
main[1] set a = 100
 a = 100 = 100
main[1] set b = 200
 b = 200 = 200
main[1] locals
Method arguments:
args = instance of java.lang.String[0] (id=403)
Local variables:
a = 100
b = 200
main[1] next
>
Step completed: "thread=main", Test.main(), line=6 bci=12
6            System.out.printf("%d + %d = %d\n", a, b, c);

main[1] list
2        public static void main(String[] args) {
3            int a = 10;
4            int b = 20;
5            int c = add(a, b);
6 =>         System.out.printf("%d + %d = %d\n", a, b, c);
7        }
8
9        private static int add(int x, int y) {
10            int z = x + y;
11            return z;
main[1] print a
 a = 100
main[1] print b
 b = 200
main[1] print c
 c = 300
main[1] cont
> 100 + 200 = 300

The application exited
</script></code></pre>
    </div>
    <div>
    </div>
    <div>
    </div>
    <div>
    </div>
    <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/java/" rel="tag"># java</a>
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/java-reflect.html" rel="next" title="Java 反射">
                <i class="fa fa-chevron-left"></i> Java 反射
              </a>
          </div>
          <span class="post-nav-divider"></span>
          <div class="post-nav-prev post-nav-item">
              <a href="/java-lang-util.html" rel="prev" title="Java Random、regex正则、Math类、String字符串">
                Java Random、regex正则、Math类、String字符串 <i class="fa fa-chevron-right"></i>
              </a>
          </div>
        </div>
    </footer>
  </article>
    <div class="post-spread">
    </div>
  </div>
          </div>
  <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer" target="_blank">comments powered by Disqus.</a>
        </noscript>
      </div>
  </div>
        </div>
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>
  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Otokaze">
          <p class="site-author-name" itemprop="name">Otokaze</p>
              <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">170</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
        </nav>
        <div class="links-of-author motion-element">
              <span class="links-of-author-item">
                <a href="https://github.com/zfl9" target="_blank" title="GitHub rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-github"></i>
                  GitHub
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="mailto:zfl9.com@gmail.com" target="_blank" title="Email rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-envelope"></i>
                  Email
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://gitlab.com/zfl9" target="_blank" title="GitLab rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-gitlab"></i>
                  GitLab
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://t.me/Otokaze" target="_blank" title="Telegram rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-telegram"></i>
                  Telegram
                </a>
              </span>
        </div>
      </section>
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-和-Java"><span class="nav-number">1.</span> <span class="nav-text">JVM 和 Java</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-运行时数据区"><span class="nav-number">2.</span> <span class="nav-text">JVM 运行时数据区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-类加载机制"><span class="nav-number">3.</span> <span class="nav-text">JVM 类加载机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-对象访问方式"><span class="nav-number">4.</span> <span class="nav-text">JVM 对象访问方式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-内存分代机制"><span class="nav-number">5.</span> <span class="nav-text">JVM 内存分代机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JVM-垃圾回收机制"><span class="nav-number">6.</span> <span class="nav-text">JVM 垃圾回收机制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#javac-java-常用参数"><span class="nav-number">7.</span> <span class="nav-text">javac/java 常用参数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#javac-常用参数"><span class="nav-number">7.1.</span> <span class="nav-text">javac 常用参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-标准参数"><span class="nav-number">7.2.</span> <span class="nav-text">java 标准参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#java-非标参数"><span class="nav-number">7.3.</span> <span class="nav-text">java 非标参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK-常用自带工具"><span class="nav-number">8.</span> <span class="nav-text">JDK 常用自带工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#jdb-调试器"><span class="nav-number">8.1.</span> <span class="nav-text">jdb 调试器</span></a></li></ol></li></ol></div>
          </div>
        </section>
      <!--/noindex-->
    </div>
  </aside>
      </div>
    </main>
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Otokaze</span>
</div>
<script src="/js/clipboard.min.js"></script>
<script src="/js/prism/prism.js" async></script>
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
  </div>
<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>
      <script id="dsq-count-scr" src="https://otokaze.disqus.com/count.js" async></script>
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://www.zfl9.com/java-jvm.html';
          this.page.identifier = 'java-jvm.html';
          this.page.title = 'Java 深入理解 JVM 虚拟机';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://otokaze.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("3hhdw6gOg9wavsharVwVjqI3-gzGzoHsz", "O5WfDffqFsgmAVPwNY9of3QU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");
      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });
      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';
          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);
            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);
      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }
    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</body>
</html>
