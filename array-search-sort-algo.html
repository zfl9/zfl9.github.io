<!doctype html>
<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">
<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">
<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">
  <meta name="keywords" content="数组查找算法 数组排序算法 二分查找 七大排序">
  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1">
<meta name="description" content="两大查找：线性查找、二分查找。七大排序：插入排序、希尔排序、选择排序、堆排序、冒泡排序、快速排序、归并排序。">
<meta name="keywords" content="数据结构与算法">
<meta property="og:type" content="article">
<meta property="og:title" content="数组查找、排序算法">
<meta property="og:url" content="https://www.zfl9.com/array-search-sort-algo.html">
<meta property="og:site_name" content="Otokaze's Blog">
<meta property="og:description" content="两大查找：线性查找、二分查找。七大排序：插入排序、希尔排序、选择排序、堆排序、冒泡排序、快速排序、归并排序。">
<meta property="og:image" content="https://www.zfl9.com/images/insertion-sort.gif">
<meta property="og:image" content="https://www.zfl9.com/images/shell-sort.png">
<meta property="og:image" content="https://www.zfl9.com/images/full-binary-tree.png">
<meta property="og:image" content="https://www.zfl9.com/images/complete-binary-tree.png">
<meta property="og:image" content="https://www.zfl9.com/images/general-binary-tree.png">
<meta property="og:image" content="https://www.zfl9.com/images/max-heap.png">
<meta property="og:image" content="https://www.zfl9.com/images/min-heap.png">
<meta property="og:image" content="https://www.zfl9.com/images/merge-sort-gif.gif">
<meta property="og:image" content="https://www.zfl9.com/images/merge-sort.gif">
<meta property="og:updated_time" content="2019-02-18T12:42:42.234Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="数组查找、排序算法">
<meta name="twitter:description" content="两大查找：线性查找、二分查找。七大排序：插入排序、希尔排序、选择排序、堆排序、冒泡排序、快速排序、归并排序。">
<meta name="twitter:image" content="https://www.zfl9.com/images/insertion-sort.gif">
<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
  <link rel="canonical" href="https://www.zfl9.com/array-search-sort-algo.html">
<link href="/js/prism/prism.css" rel="stylesheet">
  <title>数组查找、排序算法 | Otokaze's Blog</title>
</head>
<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-97872912-1', 'auto');
  ga('send', 'pageview');
</script>
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3d58f51dbb2496a0e6d17b85065a5ae5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Otokaze's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">拼一年春夏秋冬，搏一生无怨无悔</h1>
  </div>
  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>
<nav class="site-nav">
    <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            首页
          </a>
        </li>
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            分类
          </a>
        </li>
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            标签
          </a>
        </li>
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            归档
          </a>
        </li>
    </ul>
</nav>
 </div>
    </header>
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
  <div id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.zfl9.com/array-search-sort-algo.html">
    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Otokaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>
    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Otokaze's Blog">
    </span>
      <header class="post-header">
          <h2 class="post-title" itemprop="name headline">
                数组查找、排序算法
          </h2>
        <div class="post-meta">
          <span class="post-time">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
                <span class="post-meta-item-text">发表于</span>
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-01-14T16:47:00+08:00">
                2018-01-14
              </time>
          </span>
            <span class="post-category">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
                <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/数据结构与算法/" itemprop="url" rel="index">
                    <span itemprop="name">数据结构与算法</span>
                  </a>
                </span>
            </span>
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/array-search-sort-algo.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="array-search-sort-algo.html" itemprop="commentCount"></span>
                </a>
              </span>
             <span id="/array-search-sort-algo.html" class="leancloud_visitors" data-flag-title="数组查找、排序算法">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
                 <span class="post-meta-item-text">阅读次数 </span>
                 <span class="leancloud-visitors-count"></span>
             </span>
        </div>
      </header>
    <div class="post-body" itemprop="articleBody">
        <p>两大查找：<strong>线性查找</strong>、<strong>二分查找</strong>。<br>七大排序：<strong>插入排序</strong>、<strong>希尔排序</strong>、<strong>选择排序</strong>、<strong>堆排序</strong>、<strong>冒泡排序</strong>、<strong>快速排序</strong>、<strong>归并排序</strong>。</p>
<a id="more"></a>
<h2 id="线性查找-linearSearch"><a href="#线性查找-linearSearch" class="headerlink" title="线性查找 linearSearch"></a>线性查找 linearSearch</h2><p>线性查找又称顺序查找，是一种最简单的查找方法，它的基本思想是从第一个记录开始，逐个比较记录的关键字，直到和给定的 K 值相等，则查找成功；若比较结果与文件中 n 个记录的关键字都不等，则查找失败。</p>
<p>假设一个数组中有 n 个元素，最好的情况就是要寻找的特定值就是数组里的第一个元素，这样仅需要 1 次比较就可以。而最坏的情况是要寻找的特定值不在这个数组或者是数组里的最后一个元素，这就需要进行 n 次比较。</p>
<p>算法实现（Java）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 线性查找，查找给定 key 所在的位置.
 * @param arr   被查找的数组
 * @param key   要查找的元素
 * @return int  返回元素的索引，如果不存在则返回 -1
 */
public static int linearSearch(int[] arr, int key) {
    for (int i = 0; i < arr.length; i++)
        if (key == arr[i])
            return i;
    return -1;
}
</script></code></pre>
<p>时间复杂度：平均情况<code>O(n)</code>、最好情况<code>O(1)</code>、最坏情况<code>O(n)</code><br>空间复杂度：<code>O(1)</code></p>
<h2 id="二分查找-binarySearch"><a href="#二分查找-binarySearch" class="headerlink" title="二分查找 binarySearch"></a>二分查找 binarySearch</h2><p>二分搜索（英语：binary search），也称折半搜索（英语：half-interval search）、对数搜索（英语：logarithmic search），是一种在<strong>有序数组</strong>中查找某一特定元素的搜索算法。搜索过程从数组的<strong>中间元素</strong>开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p>
<p>算法实现（Java）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 二分查找，被查找的数组必须是已排序的.
 * @param arr   被查找的数组
 * @param key   要查找的元素
 * @return int  返回元素的索引，如果不存在则返回 -1
 */
public static int binarySearch(int[] arr, int key) {
    int beg = 0;
    int end = arr.length - 1;
    int mid;
    while (beg <= end) { // 只要还有元素就循环
        mid = (beg + end) / 2; // 取中值
        if (key == arr[mid]) // 如果正好命中则返回当前索引
            return mid;
        else if (key > arr[mid]) // 如果大于则继续查找右边的子序列
            beg = mid + 1;
        else // 如果小于则继续查找左边的子序列
            end = mid - 1;
    }
    return -1; // 如果循环体内未查找到则说明该元素不存在
}
</script></code></pre>
<p>时间复杂度：平均情况<code>O(logn)</code>、最好情况<code>O(1)</code>、最坏情况<code>O(logn)</code><br>空间复杂度：<code>O(1)</code></p>
<p>时间复杂度是怎么算来的？这里只讨论最坏情况，很明显，无非就是看<code>while (beg &lt;= end)</code>的循环次数。<code>beg &lt;= end</code>条件的意思就是：只要还有至少一个元素，就继续循环下去。因为每次循环都会过滤掉 1/2 的元素（要么选择左边要么选择右边），假设数组长度为 n，第一次循环后，长度为 n/2，第二次循环后，长度为 n/4，第三次循环后，长度为 n/8，第 k 次循环后（最后一次），长度为 n/(2^k) = 1，2^k = n，k = log2(n)，因此时间复杂度为<code>O(logn)</code>。</p>
<h2 id="插入排序-insertionSort"><a href="#插入排序-insertionSort" class="headerlink" title="插入排序 insertionSort"></a>插入排序 insertionSort</h2><p>插入排序（英语：Insertion Sort）是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中<strong>从后向前扫描</strong>，找到相应位置并插入。插入排序在实现上，通常采用 in-place（原地）排序（即只需用到<code>O(1)</code>的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素腾出插入空间。</p>
<p><img src="/images/insertion-sort.gif" alt="直接插入排序 - 动图演示"></p>
<p>一般来说，插入排序都采用 in-place 在数组上实现。具体算法描述如下：</p>
<ol>
<li>从第一个元素开始，该元素可以认为已经被排序</li>
<li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li>
<li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li>
<li>重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置</li>
<li>将新元素插入到该位置后</li>
<li>重复步骤 2~5</li>
</ol>
<p>如果<strong>比较操作的代价比交换操作大</strong>，可以采用<strong>二分查找法</strong>来减少比较操作的数目。该算法可以认为是插入排序的一个变种，称为<strong>二分查找插入排序</strong>（稍后介绍）。</p>
<p>算法实现（Java）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 直接插入排序(线性查找).
 * @param arr    待排数组
 * @return int[] 已排数组
 */
public static int[] insertionSort(int[] arr) {
    for (int i = 1, j, curVal; i < arr.length; i++) { // 待排序列的范围
        curVal = arr[i]; // 取出待排元素
        for (j = i - 1; j >= 0 && arr[j] > curVal; j--) // 从后往前扫描
            arr[j + 1] = arr[j]; // 往后移动
        arr[j + 1] = curVal; // 放入待排元素
    }
    return arr;
}
</script></code></pre>
<p>时间复杂度：平均情况<code>O(n^2)</code>、最好情况<code>O(n)</code>、最坏情况<code>O(n^2)</code><br>空间复杂度：<code>O(1)</code><br>算法稳定性：稳定</p>
<p>最好情况，即待排数组为升序排列。这种情况下，内层 for 循环的条件<code>arr[j] &gt; curVal</code>将不成立，因此只需考虑外层 for 循环的次数，即为 n-1 次。因此时间复杂度为<code>O(n)</code>。<br>最坏情况，即待排数组为降序排列。这种情况下，内层 for 循环的条件<code>arr[j] &gt; curVal</code>始终成立，因此只需考虑<code>j = i - 1; j &gt;= 0</code>，i 的取值范围为<code>[1, n-1]</code>，则 j 的取值范围为<code>[0, n-2]</code>，j = 0，循环 1 次，j = 1，循环 2 次，j = n-2，循环 n-1 次。总共循环的次数为 1 + 2 + 3 + … + n-1，即<code>n(n-1)/2</code>，因此时间复杂度为<code>O(n^2)</code>。</p>
<p><strong>排序算法稳定性</strong>：假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的<strong>相对次序保持不变</strong>，即在原序列中，<code>ri=rj</code>，且 ri 在 rj 之前，而在排序后的序列中，ri 仍在 rj 之前，则称这种排序算法是稳定的；否则称为不稳定的。</p>
<p>在上述的插入排序中，会改变元素位置的就是<code>arr[j + 1] = arr[j]</code>语句，因为是从后往前扫描的，而又只有比待排元素大的才会往后挪动，当遇到与之相等的元素时，循环条件已经不成立了，因此待排元素只会插入到它的后面，它们之间的相对顺序没有改变，即<strong>直接插入排序是稳定的</strong>。</p>
<p>在直接插入排序中，找到插入位置 k 之前，必须经过 i - k 次比较，如果比较操作的开销比移动操作的开销大，可以考虑使用<strong>二分查找法</strong>来寻找合适的插入位置，即直接插入排序的变种 - <strong>折半插入排序</strong>。算法实现如下（Java）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 折半插入排序(二分查找).
 * @param arr    待排数组
 * @return int[] 已排数组
 */
public static int[] binaryInsertionSort(int[] arr) {
    int curVal, beg, mid, end, j;
    for (int i = 1; i < arr.length; i++) { // 待排序列的范围
        curVal = arr[i]; // 取出待排元素
        beg = 0; // 已排序序列的起始位置
        end = i - 1; // 已排序序列的结束位置
        while (beg <= end) { // 只要还有元素就继续循环
            mid = (beg + end) / 2; // 计算中值
            if (curVal >= arr[mid]) // 如果待插值大于等于当前值，则比较右边的序列
                beg = mid + 1;
            else // 如果待插值小于当前值，则比较左边的序列
                end = mid - 1;
        }
        for (j = i - 1; j >= beg; j--) // 将 [beg, i-1] 的元素往后挪一个位置
            arr[j + 1] = arr[j]; // 往后移动一个位置
        arr[beg] = curVal; // 放入待排元素
    }
    return arr;
}
</script></code></pre>
<p>直接插入排序和折半插入排序的元素移动次数是一样的，但是折半插入排序的元素比较次数总体上会更少一些。因为存在额外的二分查找过程，如果元素之间的比较操作开销很小（如基本类型的比较）可能会得不偿失。也就是说，除非你确定元素之间的比较操作开销大（如引用类型，比较操作要调用 Comparable.compareTo() 或 Comparator.compare() 方法），否则不要尝试折半插入排序。</p>
<p>为了说明这个问题，我们分别使用直接插入排序和折半插入排序，将拥有 10000 个元素的 int[] 和 Integer[] 数组升序排列。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">import java.util.Arrays;
import java.util.Random;

public class Main {
    public static void main(String[] args) {
        int[] arr1 = new int[10000];
        Integer[] arr2 = new Integer[10000];

        Arrays.setAll(arr1, ind -> ind);
        Arrays.setAll(arr2, ind -> ind);

        long beg, end, time1, time2, time3, time4;

        // int[] 直接插入排序
        shuffle(arr1);
        beg = System.nanoTime();
        insertionSort(arr1);
        end = System.nanoTime();
        time1 = end - beg;

        // int[] 折半插入排序
        shuffle(arr1);
        beg = System.nanoTime();
        binaryInsertionSort(arr1);
        end = System.nanoTime();
        time2 = end - beg;

        // Integer[] 直接插入排序
        shuffle(arr2);
        beg = System.nanoTime();
        insertionSort(arr2);
        end = System.nanoTime();
        time3 = end - beg;

        // Integer[] 折半插入排序
        shuffle(arr2);
        beg = System.nanoTime();
        binaryInsertionSort(arr2);
        end = System.nanoTime();
        time4 = end - beg;

        System.out.println("    int[] 直接插入排序: " + time1 + " ns, " +
                           time1 / 1000000 + " ms");
        System.out.println("    int[] 折半插入排序: " + time2 + " ns, " +
                           time2 / 1000000 + " ms");
        System.out.println("Integer[] 直接插入排序: " + time3 + " ns, " +
                           time3 / 1000000 + " ms");
        System.out.println("Integer[] 折半插入排序: " + time4 + " ns, " +
                           time4 / 1000000 + " ms");
    }

    // 随机洗牌(int)
    public static int[] shuffle(int[] arr) {
        Random rnd = new Random();
        for (int i = arr.length - 1, j, tmp; i > 0; i--) {
            j = rnd.nextInt(i + 1);
            if (i != j) {
                tmp = arr[j];
                arr[j] = arr[i];
                arr[i] = tmp;
            }
        }
        return arr;
    }
    // 随机洗牌(泛型)
    public static <T> T[] shuffle(T[] arr) {
        Random rnd = new Random(); T tmp;
        for (int i = arr.length - 1, j; i > 0; i--) {
            j = rnd.nextInt(i + 1);
            if (i != j) {
                tmp = arr[j];
                arr[j] = arr[i];
                arr[i] = tmp;
            }
        }
        return arr;
    }

    // 直接插入排序(int)
    public static int[] insertionSort(int[] arr) {
        for (int i = 1, j, curVal; i < arr.length; i++) { // 待排序列的范围
            curVal = arr[i]; // 取出待排元素
            for (j = i - 1; j >= 0 && arr[j] > curVal; j--) // 从后往前扫描
                arr[j + 1] = arr[j]; // 往后移动
            arr[j + 1] = curVal; // 放入待排元素
        }
        return arr;
    }
    // 折半插入排序(int)
    public static int[] binaryInsertionSort(int[] arr) {
        int curVal, beg, mid, end, j;
        for (int i = 1; i < arr.length; i++) { // 待排序列的范围
            curVal = arr[i]; // 取出待排元素
            beg = 0; // 已排序序列的起始位置
            end = i - 1; // 已排序序列的结束位置
            while (beg <= end) { // 只要还有元素就继续循环
                mid = (beg + end) / 2; // 计算中值
                if (curVal >= arr[mid]) // 如果待插值大于等于当前值，则比较右边的序列
                    beg = mid + 1;
                else // 如果待插值小于当前值，则比较左边的序列
                    end = mid - 1;
            }
            for (j = i - 1; j >= beg; j--) // 将 [beg, i-1] 的元素往后挪一个位置
                arr[j + 1] = arr[j]; // 往后移动一个位置
            arr[beg] = curVal; // 放入待排元素
        }
        return arr;
    }

    // 直接插入排序(泛型)
    public static <T extends Comparable<? super T>>
        T[] insertionSort(T[] arr)
    {
        T curVal;
        for (int i = 1, j; i < arr.length; i++) {
            curVal = arr[i];
            for (j = i - 1; j >= 0 && arr[j].compareTo(curVal) > 0; j--)
                arr[j + 1] = arr[j];
            arr[j + 1] = curVal;
        }
        return arr;
    }
    // 折半插入排序(泛型)
    public static <T extends Comparable<? super T>>
        T[] binaryInsertionSort(T[] arr)
    {
        T curVal;
        int beg, mid, end, j;
        for (int i = 1; i < arr.length; i++) {
            curVal = arr[i];
            beg = 0;
            end = i - 1;
            while (beg <= end) {
                mid = (beg + end) / 2;
                if (curVal.compareTo(arr[mid]) >= 0)
                    beg = mid + 1;
                else
                    end = mid - 1;
            }
            for (j = i - 1; j >= beg; j--)
                arr[j + 1] = arr[j];
            arr[beg] = curVal;
        }
        return arr;
    }
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/java8-learn/com/zfl9 on git:master x [13:32:15]
$ javac Main.java && java Main
    int[] 直接插入排序: 23540884 ns, 23 ms
    int[] 折半插入排序: 30823407 ns, 30 ms
Integer[] 直接插入排序: 154724114 ns, 154 ms
Integer[] 折半插入排序: 107765155 ns, 107 ms
</script></code></pre>
如果改成 100000（十万）个元素，差距更加明显：
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/java8-learn/com/zfl9 on git:master x [13:32:59]
$ javac Main.java && java Main
    int[] 直接插入排序: 1245121607 ns, 1245 ms
    int[] 折半插入排序: 2479161110 ns, 2479 ms
Integer[] 直接插入排序: 11503634437 ns, 11503 ms
Integer[] 折半插入排序: 7499126837 ns, 7499 ms
</script></code></pre>
<h2 id="希尔排序-shellSort"><a href="#希尔排序-shellSort" class="headerlink" title="希尔排序 shellSort"></a>希尔排序 shellSort</h2><p>希尔排序算法是按其设计者希尔（Donald Shell）的名字命名，该算法由 1959 年公布，是插入排序的一种更高效的改进版本。它的做法不是每次一个元素挨一个元素的比较，而是初期选用大跨步（增量较大）间隔比较，使记录跳跃式接近它的排序位置，然后增量缩小，最后增量为 1 ，这样记录移动次数大大减少，提高了排序效率。希尔排序对增量序列的选择没有严格规定。</p>
<p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p>
<ol>
<li>插入排序在对几乎已经排好序的数据操作时，效率高，可以达到线性排序的效率</li>
<li>但插入排序一般来说是低效的，因为插入排序每次只能将数据往前移动一个位置</li>
</ol>
<p>希尔排序的算法思路：</p>
<ol>
<li>取一正整数<code>d1 (d1 &lt; n)</code>，把全部记录分成 d1 个组，所有距离为 d1 倍数的记录看成一组，在各组内进行插入排序</li>
<li>然后取<code>d2 (d2 &lt; d1)</code></li>
<li>重复上述分组和排序操作，直到取<code>di = 1 (i &gt;= 1)</code>位置，即所有记录成为一个组，最后对这个组进行直接插入排序</li>
</ol>
<blockquote>
<p>一般选 d1 约为 n/2，d2 为 d1 / 2，d3 为 d2 / 2，…，di = 1</p>
</blockquote>
<p><img src="/images/shell-sort.png" alt="希尔排序 - 图解"></p>
<p>算法实现（Java）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 希尔排序(缩小增量排序).
 * @param arr    待排数组
 * @return int[] 已排数组
 */
public static int[] shellSort(int[] arr) {
    int i, j, curVal;
    for (int gap = arr.length / 2; gap > 0; gap /= 2) { // 步长
        for (i = gap; i < arr.length; i++) { // 待排序列的范围
            curVal = arr[i]; // 取出待排元素
            for (j = i - gap; j >= 0 && arr[j] > curVal; j -= gap) // 往后挪动 gap 长度
                arr[j + gap] = arr[j];
            arr[j + gap] = curVal; // 放入待排元素
        }
    }
    return arr;
}
</script></code></pre>
<p>时间复杂度：平均情况<code>O(nlogn) ~ O(n^2)</code>、最好情况<code>O(n^1.3)</code>、最坏情况<code>O(n^2)</code><br>空间复杂度：<code>O(1)</code><br>算法稳定性：不稳定</p>
<p>为什么希尔排序是不稳定的呢？举个例子 [5, 1, 2, 1, 3, 4]，数组长度为 6，初始步长为 6 / 2 = 3，索引为 3 的元素 1 小于 5，将 1 插入到索引 0 处，因此改变了原索引 1 和原索引 3 的两个相同元素的相对位置，因此<strong>希尔排序是不稳定的</strong>。</p>
<h2 id="选择排序-selectionSort"><a href="#选择排序-selectionSort" class="headerlink" title="选择排序 selectionSort"></a>选择排序 selectionSort</h2><p>选择排序（Selection Sort）是一种简单直观的排序算法。它的工作原理如下：首先在未排序序列中找到最小的元素，将其与未排序序列的第一个元素交换位置。然后，再从剩余的未排序序列中寻找最小的元素，将其与未排序序列的第一个元素交换位置。以此类推，直到所有元素均排序完毕。</p>
<p>算法实现（Java）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 简单选择排序.
 * @param arr    待排数组
 * @return int[] 已排数组
 */
public static int[] selectionSort(int[] arr) {
    for (int i = 0, j, min, tmp; i < arr.length - 1; i++) { // 存放最小值的位置
        min = i; // 先假设当前元素就是最小的
        for (j = i + 1; j < arr.length; j++) // 从剩余的序列中寻找最小元素
            if (arr[j] < arr[min])
                min = j;
        if (min != i) { // 如果当前元素不是最小的则进行交换
            tmp = arr[i];
            arr[i] = arr[min];
            arr[min] = tmp;
        }
    }
    return arr;
}
</script></code></pre>
<p>时间复杂度：平均情况<code>O(n^2)</code>、最好情况<code>O(n^2)</code>、最坏情况<code>O(n^2)</code><br>空间复杂度：<code>O(1)</code><br>算法稳定性：不稳定</p>
<p>为什么选择排序是不稳定的呢？举个例子 [5, 2, 3, 4, 5, 1]，在第一轮选择中，最小值为 1，将其与第一个 5 交换位置，此时两个 5 之间的相对顺序被改变，因此<strong>简单选择排序是不稳定的</strong>。</p>
<h2 id="堆排序-heapSort"><a href="#堆排序-heapSort" class="headerlink" title="堆排序 heapSort"></a>堆排序 heapSort</h2><blockquote>
<p>要了解堆排序，首先要了解什么是<strong>堆</strong>（二叉堆），要了解二叉堆，还要先了解什么是<strong>完全二叉树</strong>。</p>
</blockquote>
<p>堆（英语：Heap）是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构。</p>
<p>除非特别指明，否则堆一般均指<strong>二叉堆</strong>，二叉堆实际是一颗完全二叉树，二叉堆性质如下：</p>
<ul>
<li>任意节点小于（或大于）它的所有后裔节点，最小元（或最大元）在堆的根上（堆序性）。</li>
<li>因为是完全二叉树，因此除最底层外，其它层的节点均被元素填满，且最底层尽可能地从左到右填入。</li>
</ul>
<p><strong>根节点最大的堆</strong>叫做<strong>最大堆</strong>或大根堆，<strong>根节点最小的堆</strong>叫做<strong>最小堆</strong>或小根堆。</p>
<p>满二叉树：<img src="/images/full-binary-tree.png" alt="满二叉树"><br>完全二叉树：<img src="/images/complete-binary-tree.png" alt="完全二叉树"><br>普通二叉树：<img src="/images/general-binary-tree.png" alt="普通二叉树"></p>
<p>最大堆：<img src="/images/max-heap.png" alt="最大堆"><br>最小堆：<img src="/images/min-heap.png" alt="最小堆"></p>
<p>完全二叉树的几个性质（序号从 1 开始，从上到下，从左到右，依次编号）：</p>
<ul>
<li>第 n 个节点的左子节点：<code>2n</code></li>
<li>第 n 个节点的右子节点：<code>2n + 1</code></li>
<li>第 n 个节点的双亲节点：<code>floor(n / 2)</code></li>
<li>最后一个非叶子节点：<code>floor(len / 2)</code></li>
</ul>
<p>完全二叉树的几个性质（序号从 0 开始，从上到下，从左到右，依次编号）：</p>
<ul>
<li>第 n 个节点的左子节点：<code>2n + 1</code></li>
<li>第 n 个节点的右子节点：<code>2n + 2</code></li>
<li>第 n 个节点的双亲节点：<code>floor((n - 1) / 2)</code></li>
<li>最后一个非叶子节点：<code>floor(len / 2) - 1</code></li>
</ul>
<blockquote>
<p>因为数组都是 Zero-Based（下标从 0 开始），因此我们主要关注后者。</p>
</blockquote>
<p>因为这里主要讨论<strong>升序排列</strong>，因此选择最大堆，如果是降序排列，则应选择最小堆。</p>
<p>堆排序的算法思路：</p>
<ol>
<li>首先，将数组看作一颗完全二叉树，将其构造成一个最大堆</li>
<li>此时，数组的头部元素就是最大的元素，将其与数组尾部元素交换</li>
<li>交换后，可能破坏了最大堆的性质，因此需要将剩下的序列调整为最大堆</li>
<li>调整完成后，头部元素又成为了最大的元素，然后将其与序列尾部元素交换</li>
<li>重复步骤 3~4</li>
</ol>
<p>两个主要操作：<strong>最大堆构造</strong>、<strong>最大堆调整</strong>，而最大堆构造本质还是最大堆调整，只不过是<strong>从最后一个非叶子节点开始，从后往前，从下往上，递归的调整</strong>。因此，我们只要实现了<strong>最大堆调整</strong>，就可以轻而易举的写出一个堆排序。</p>
<p>调整最大堆的思路：在交换首尾元素之前，最大堆的特性还在，将根节点与序列尾部元素交换后，很有可能破坏了最大堆的特性，因此，需要在<strong>根节点</strong>、<strong>左子节点</strong>、<strong>右子节点</strong>中找到最大值，如果根节点依旧是最大的，则无需调整，如果不是，则将其与最大的子节点交换，交换后，又有可能破坏了该子节点所在的二叉堆的性质，因此我们需要递归的进行调整，直到无需调整或到达序列末尾时为止。</p>
<p>堆排序的算法实现（Java）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 最大堆调整.
 * @param arr   被调整的数组
 * @param from  起始位置（包含）
 * @param to    结束位置（排除）
 */
static void maxHeapAdjust(int[] arr, int from, int to) {
    int parent = from;
    int child = 2 * parent + 1; // left-child，先假设左子节点更大
    int temp;
    while (child < to) {
        if (child + 1 < to && arr[child + 1] > arr[child]) // 如果右子节点更大
            child++; // right-child
        if (arr[parent] >= arr[child]) // 如果根节点已经是最大的，则结束调整
            return;
        else { // 如果根节点不是最大的，则与大的子节点交换，然后循环调整下去
            temp = arr[parent];
            arr[parent] = arr[child];
            arr[child] = temp;
            parent = child;
            child = 2 * parent + 1; // left-child
        }
    }
}
/**
 * 最大堆排序.
 * @param arr    待排数组
 * @return int[] 已排数组
 */
public static int[] heapSort(int[] arr) {
    // 最大堆构造，从最后一个非叶结点开始从后往前调整
    for (int i = arr.length / 2 - 1; i >= 0; i--)
        maxHeapAdjust(arr, i, arr.length);
    // 取出根节点，然后调整最大堆，保持最大堆性质
    for (int i = arr.length - 1, tmp; i > 0; i--) { // 存放"根节点"的位置
        tmp = arr[i];
        arr[i] = arr[0];
        arr[0] = tmp;
        maxHeapAdjust(arr, 0, i);
    }
    return arr;
}
</script></code></pre>
<p>时间复杂度：平均情况<code>O(nlogn)</code>、最好情况<code>O(nlogn)</code>、最坏情况<code>O(nlogn)</code><br>空间复杂度：<code>O(1)</code><br>算法稳定性：不稳定</p>
<p>为什么堆排序是不稳定的呢？举个例子 [1, 0, 1]，初始时，无需调整即满足最大堆的定义，因此，将第一个 1 交换到数组末尾，交换后，仍然满足最大堆的定义，于是又将另一个 1 交换到数组倒数第二个位置，因此这两个 1 之间的相对顺序被改变了，即<strong>堆排序是不稳定的</strong>。</p>
<h2 id="冒泡排序-bubbleSort"><a href="#冒泡排序-bubbleSort" class="headerlink" title="冒泡排序 bubbleSort"></a>冒泡排序 bubbleSort</h2><p>冒泡排序（英语：Bubble Sort，台湾另外一种译名为：泡沫排序）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>
<p>冒泡排序对 n 个项目需要<code>O(n^2)</code>的比较次数，且可以原地排序。尽管这个算法是最简单了解和实现的排序算法之一，但它对于包含大量的元素的数列排序是很没有效率的。</p>
<p>冒泡排序是与插入排序拥有相等的运行时间，但是两种算法在需要的交换次数却很大地不同。在最坏的情况，冒泡排序需要 O(n^2) 次交换，而插入排序只要最多 O(n) 交换。冒泡排序的实现通常会对已经排序好的数列拙劣地运行（O(n^2)），而插入排序在这个例子只需要 O(n) 个运算。因此很多现代的算法教科书避免使用冒泡排序，而用插入排序取代之。冒泡排序如果能在内部循环第一次运行时，使用一个 flag 来表示有无需要交换的可能，也可以把最优情况下的复杂度降低到 O(n)。在这个情况，已经排序好的数列就无交换的需要。若在每次走访数列时，把走访顺序反过来，也可以稍微地改进效率。有时候称为<strong>鸡尾酒排序</strong>（稍后介绍），因为算法会从数列的一端到另一端之间穿梭往返。</p>
<p>冒泡排序的算法思路：</p>
<ul>
<li>比较相邻的元素，如果第一个比第二个大，就交换它们两个。</li>
<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>
<li>针对所有的元素重复以上的步骤，除了最后一个。</li>
<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>
</ul>
<p>由于它的简洁，冒泡排序通常被用来对于程序设计入门的学生介绍算法的概念。</p>
<p>对于序列 [4, 2, 1, 3]，长度为 4，排序过程（升序）如下：</p>
<ol>
<li>第一轮交换，需要走访的索引范围为<code>[0, 2]</code><ul>
<li>比较 4 和 2，因为 4 比 2 大，因此交换它们的位置，交换后序列为 [2, 4, 1, 3]</li>
<li>比较 4 和 1，因为 4 比 1 大，因此交换它们的位置，交换后序列为 [2, 1, 4, 3]</li>
<li>比较 4 和 3，因为 4 比 3 大，因此交换它们的位置，交换后序列为 [2, 1, 3, 4]</li>
<li>第一轮交换结束，最大值 4 已经浮到了序列末尾，因此下轮交换不需要再考虑它</li>
</ul>
</li>
<li>第二轮交换，需要走访的索引范围为<code>[0, 1]</code><ul>
<li>比较 2 和 1，因为 2 比 1 大，因此交换它们的位置，交换后序列为 [1, 2, 3, 4]</li>
<li>比较 2 和 3，因为 2 比 3 小，因此不需要进行交换，此时序列仍为 [1, 2, 3, 4]</li>
<li>第二轮交换结束，最大值 3 已经浮到了序列末尾，因此下轮交换不需要再考虑它</li>
</ul>
</li>
<li>第三轮交换，需要走访的索引范围为<code>[0, 0]</code><ul>
<li>比较 1 和 2，因为 1 比 2 小，因此不需要进行交换，此时序列仍为 [1, 2, 3, 4]</li>
<li>第三轮交换结束，最大值 2 已经浮到了序列末尾，因为只剩一个元素，结束排序</li>
</ul>
</li>
</ol>
<p>可以看出，长度为 4 的数组最多进行 3 轮交换，而每一次需走访的范围都逐步缩小，直到为 1。</p>
<p>算法实现（Java）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 冒泡排序(原始版本).
 * @param arr    待排数组
 * @return int[] 已排数组
 */
public static int[] bubbleSort1(int[] arr) {
    for (int i = 0, j, tmp; i < arr.length - 1; i++) { // 进行 len - 1 轮循环
        for (j = 0; j < arr.length - 1 - i; j++) { // 需要走访的索引范围
            if (arr[j] > arr[j + 1]) { // 如果前面的值大于后面的值则交换
                tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
            }
        }
    }
    return arr;
}
/**
 * 冒泡排序(优化版本).
 * @param arr    待排数组
 * @return int[] 已排数组
 */
public static int[] bubbleSort2(int[] arr) {
    boolean sorted; int i, j, tmp;
    for (i = 0; i < arr.length - 1; i++) { // 进行 len - 1 轮循环
        sorted = true; // 先假设序列已排好序
        for (j = 0; j < arr.length - 1 - i; j++) { // 需要走访的索引范围
            if (arr[j] > arr[j + 1]) { // 如果前面的值大于后面的值则交换
                sorted = false; // 此时说明序列未排好序
                tmp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = tmp;
            }
        }
        if (sorted) break; // 如果此轮走下来没有交换元素，则结束排序
    }
    return arr;
}
</script></code></pre>
<p>时间复杂度：平均情况<code>O(n^2)</code>、最好情况<code>O(n)</code>、最坏情况<code>O(n^2)</code><br>空间复杂度：<code>O(1)</code><br>算法稳定性：稳定</p>
<p>为什么冒泡排序是稳定的呢？举个例子 [1, 2, 1]，第一轮交换后，2 浮到末尾，变成 [1, 1, 2]；第二轮交换时，因为前面的 1 不会大于后面的 1，因此排序结束后，它们的相对顺序没有改变，即<strong>冒泡排序是稳定的</strong>。</p>
<p><strong>鸡尾酒排序</strong>（双向冒泡排序）<br>为什么叫鸡尾酒排序？其实我也不知道，其实它还有很多奇怪的名称，比如双向冒泡排序（Bidirectional Bubble Sort）、波浪排序（Ripple Sort）、摇曳排序（Shuffle Sort）、飞梭排序（Shuttle Sort）和欢乐时光排序（Happy Hour Sort）。本文中就以鸡尾酒排序来称呼它。</p>
<p><strong>鸡尾酒排序是冒泡排序的轻微变形</strong>。不同的地方在于，鸡尾酒排序是从低到高然后从高到低来回排序，而冒泡排序则仅从低到高去比较序列里的每个元素。它可比冒泡排序的效率稍微好一点，原因是冒泡排序只从一个方向进行比对（由低到高），每次循环只移动一个项目。</p>
<p>以序列 (2, 3, 4, 5, 1) 为例，鸡尾酒排序只需要访问一次序列就可以完成排序（先从后往前再从前往后），但如果使用冒泡排序则需要四次。但是在乱数序列状态下，鸡尾酒排序与冒泡排序的效率都很差劲。</p>
<p>鸡尾酒排序的算法思路：</p>
<ol>
<li>先对数组<strong>从左到右</strong>进行冒泡排序（升序），结束后，最大的元素浮到最右端</li>
<li>再对数组<strong>从右到左</strong>进行冒泡排序（降序），结束后，最小的元素浮到最左端</li>
<li>以此类推，依次改变冒泡的方向，并不断缩小未排序元素的范围，直到只剩一个元素</li>
</ol>
<p>鸡尾酒排序的算法实现（Java）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 鸡尾酒排序(原始版本).
 * @param arr    待排数组
 * @return int[] 已排数组
 */
public static int[] cocktailSort1(int[] arr) {
    int beg = 0; // 左边界
    int end = arr.length - 1; // 右边界
    int i, tmp;
    while (beg < end) { // 只要有至少两个元素就循环
        for (i = beg; i < end; i++) // 从左往右
            if (arr[i] > arr[i + 1]) { // 如果左值大于右值则进行交换
                tmp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = tmp;
            }
        end--; // 缩小右边界
        for (i = end; i > beg; i--) // 从右往左
            if (arr[i - 1] > arr[i]) { // 如果左值大于右值则进行交换
                tmp = arr[i - 1];
                arr[i - 1] = arr[i];
                arr[i] = tmp;
            }
        beg++; // 缩小左边界
    }
    return arr;
}
/**
 * 鸡尾酒排序(优化版本).
 * @param arr    待排数组
 * @return int[] 已排数组
 */
public static int[] cocktailSort2(int[] arr) {
    int beg = 0;
    int end = arr.length - 1;
    int i, tmp;
    boolean sorted;
    while (beg < end) {
        sorted = true; // 先假设序列已有序
        for (i = beg; i < end; i++)
            if (arr[i] > arr[i + 1]) {
                sorted = false; // 此时说明序列未有序
                tmp = arr[i];
                arr[i] = arr[i + 1];
                arr[i + 1] = tmp;
            }
        if (sorted) break; // 如果序列已有序则结束排序
        end--;
        for (i = end; i > beg; i--)
            if (arr[i - 1] > arr[i]) {
                tmp = arr[i - 1];
                arr[i - 1] = arr[i];
                arr[i] = tmp;
            }
        beg++;
    }
    return arr;
}
</script></code></pre>
<p>时间复杂度：平均情况<code>O(n^2)</code>、最好情况<code>O(n)</code>、最坏情况<code>O(n^2)</code><br>空间复杂度：<code>O(1)</code><br>算法稳定性：稳定</p>
<h2 id="快速排序-quickSort"><a href="#快速排序-quickSort" class="headerlink" title="快速排序 quickSort"></a>快速排序 quickSort</h2><p>快速排序（英语：Quicksort），又称划分交换排序（partition-exchange sort），一种排序算法，最早由东尼·霍尔提出。在平均状况下，排序 n 个项目要<code>O(nlogn)</code>（大 O 符号）次比较。在最坏状况下则需要<code>O(n^2)</code>次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 O(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p>
<p>快速排序使用<strong>分治法（Divide and conquer）</strong>策略来把一个序列（list）分为两个子序列（sub-lists）。</p>
<blockquote>
<p>分治法的基本思想：将原问题分解为若干个规模更小但结构与原问题相似的子问题，递归地解这些子问题，然后将这些子问题的解组合为原问题的解。</p>
</blockquote>
<p>快速排序的算法思路：</p>
<ol>
<li>从数列中挑出一个元素，称为<strong>基准（pivot）</strong>。</li>
<li>所有比基准值小的元素移到基准前面，所有比基准值大的元素移到基准后面（相等的可到任意一边）。该操作称为<strong>分区（partition）操作</strong>，分区结束后，基准元素所处的位置就是最终排序后它的位置。</li>
<li>对”基准”左边和右边的两个子集，不断重复第 1 步和第 2 步，直到所有子集只剩下一个元素为止。</li>
</ol>
<p>分区（partition）是快速排序的主要内容，用伪代码可以表示如下（原地分区版本）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * in-place 原地分区.
 * @param a             待分区的序列
 * @param left          起始索引（含）
 * @param right         结束索引（含）
 * @param pivotIndex    基准元素的索引
 */
function partition(a, left, right, pivotIndex)
     pivotValue := a[pivotIndex] // 取出 pivot 元素
     swap(a[pivotIndex], a[right]) // 将 pivot 移至结尾
     storeIndex := left // 存储"小于等于"基准的元素位置
     for i from left to right-1 // 从剩余序列中找出小于等于基准的元素
         if a[i] <= pivotValue
             swap(a[storeIndex], a[i])
             storeIndex := storeIndex + 1
     swap(a[right], a[storeIndex]) // 将 pivot 移至正确位置
     return storeIndex
</script></code></pre>
<p>首先，把基准元素移到末尾（如果直接选择最后一个元素为基准元素，那就不用移动），然后从左到右（除了最后的基准元素），循环移动小于等于基准元素的元素到数组的开头，每次移动 storeIndex 自增 1，表示下一个小于等于基准元素将要移动到的位置。循环结束后 storeIndex 所代表的位置就是基准元素的最终摆放位置。所以最后将基准元素所在位置（这里是 right）与 storeIndex 所代表的位置的元素交换。要注意的是，一个元素在到达它的最后位置前，可能会被交换很多次。</p>
<p>一旦我们有了这个分区算法，要写快速排列本身就很容易：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 快速排序(递归分区).
 * @param a     待分区的序列
 * @param left  起始索引（含）
 * @param right 结束索引（含）
 */
function quicksort(a, left, right)
    if left < right // 只要有至少两个元素，就进行分区
        select a pivot value a[pivotIndex] // 选择一个 pivot 元素
        pivotNewIndex := partition(a, left, right, pivotIndex) // 分区操作
        quicksort(a, left, pivotNewIndex - 1) // 将左边的序列进行分区
        quicksort(a, pivotNewIndex + 1, right) // 将右边的序列进行分区
</script></code></pre>
<p>快速排序的算法实现（Java）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 分区操作(原地分区).
 * @param arr   待分区数组
 * @param left  起始索引（含）
 * @param right 结束索引（含）
 * @return int  返回基准元素的排序位置
 */
static int partition(int[] arr, int left, int right) {
    int pivotInd = (left + right) / 2; // 选择中间的元素作为基准元素
    int pivotVal = arr[pivotInd]; // 取出 pivot 基准元素
    // 为了运算方便，先将基准元素放到末尾
    arr[pivotInd] = arr[right];
    arr[right] = pivotVal;
    // 初始时，storeInd 为 left 位置
    int storeInd = left, temp;
    for (int i = left; i < right; i++) { // 遍历除基准元素外的元素
        if (arr[i] <= pivotVal) { // 如果当前元素小于等于基准元素则进行交换
            if (storeInd != i) {
                temp = arr[storeInd];
                arr[storeInd] = arr[i];
                arr[i] = temp;
            }
            storeInd++;
        }
    }
    // 分区完成后，再将基准元素放回正确位置
    arr[right] = arr[storeInd];
    arr[storeInd] = pivotVal;
    return storeInd;
}

/**
 * 快速排序(递归版本) - 内部.
 * @param arr   待分区数组
 * @param left  起始索引（含）
 * @param right 结束索引（含）
 */
static void qSort(int[] arr, int left, int right) {
    if (left < right) { // 只要有至少两个元素就进行分区
        int pivot = partition(arr, left, right);
        qSort(arr, left, pivot - 1); // 递归分区左子序列
        qSort(arr, pivot + 1, right); // 递归分区右子序列
    }
}
/**
 * 快速排序(递归版本) - 外部.
 * @param arr    待排数组
 * @return int[] 已排数组
 */
public static int[] quickSort1(int[] arr) {
    qSort(arr, 0, arr.length - 1);
    return arr;
}

/**
 * 快速排序(迭代版本).
 * @param arr    待排数组
 * @return int[] 已排数组
 */
public static int[] quickSort2(int[] arr) {
    if (arr.length > 1) { // 数组长度小于 2 直接返回
        int[] stack = new int[arr.length * 2]; // "栈"，与递归版本的函数调用栈对应
        int top = 0, pivot, left, right;
        stack[top++] = arr.length - 1; // 先将右边界"压栈"
        stack[top++] = 0; // 再将左边界"压栈"
        while (top != 0) { // 只要"栈"非空就继续循环
            left = stack[--top]; // 先将左边界"出栈"
            right = stack[--top]; // 再将右边界"出栈"
            if (left >= right) continue; // 如果只剩一个元素或更少则进行下轮循环
            pivot = partition(arr, left, right); // 将 [left, right] 进行分区
            stack[top++] = right; // 先将右子序列的右边界"压栈"
            stack[top++] = pivot + 1; // 再将右子序列的左边界"压栈"
            stack[top++] = pivot - 1; // 先将左子序列的右边界"压栈"
            stack[top++] = left; // 再将左子序列的左边界"压栈"
        }
    }
    return arr;
}
</script></code></pre>
<p>时间复杂度：平均情况<code>O(nlogn)</code>、最好情况<code>O(nlogn)</code>、最坏情况<code>O(n^2)</code><br>空间复杂度：最好情况<code>O(logn)</code>、最坏情况<code>O(n)</code><br>算法稳定性：不稳定</p>
<p>关于迭代版的几点说明：</p>
<ul>
<li>快速排序的最小递归深度为<code>O(logn)</code>，最大递归深度为<code>O(n)</code>，因此栈的容量至少为 arr.length，而又因为序列范围包含左右边界，因此需要<code>2 * arr.length</code>长度的数组来存储。</li>
<li>因为”栈”这种数据结构是后进先出（LIFO）的，因此，后入栈的元素会比先入栈的元素更先出栈。在上例中，先将右边界入栈，再将左边界入栈，出栈时，就反过来了，左边界先出栈，右边界后出栈。</li>
</ul>
<h2 id="归并排序-mergeSort"><a href="#归并排序-mergeSort" class="headerlink" title="归并排序 mergeSort"></a>归并排序 mergeSort</h2><p>归并排序（Merge Sort，台湾译作：合并排序）是建立在归并操作上的一种有效的排序算法。该算法是采用<strong>分治法（Divide and Conquer）</strong>的一个非常典型的应用。</p>
<p>归并操作（Merge），也叫归并算法，指的是将两个已经排序的序列合并成一个有序序列的操作。归并排序算法依赖归并操作。归并排序有多路归并排序、两路归并排序，可用于内排序，也可以用于外排序。这里仅对内排序的<strong>两路归并</strong>方法进行讨论。</p>
<p>归并排序的算法思路：</p>
<ul>
<li>把 n 个记录看成 n 个长度为 1 的有序子表</li>
<li>进行两两归并，得到 n/2 个长度为 2 的有序子表</li>
<li>重复第 2 步直到所有记录归并成一个长度为 n 的有序表</li>
</ul>
<p>归并排序（动图演示）：<img src="/images/merge-sort-gif.gif" alt="归并排序 - 动图演示"><br>[5, 2, 4, 6, 1, 3, 2, 6] 排序过程：<img src="/images/merge-sort.gif" alt="归并排序 - 静态图示"></p>
<p>归并排序的算法实现（Java）：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 归并排序 - 内部.
 * @param arr   待排数组
 * @param beg   起始索引
 * @param end   结束索引
 * @param tmp   临时数组
 */
static void mSort(int[] arr, int beg, int end, int[] tmp) {
    if (beg < end) { // 至少两个元素才继续
        /* 递归地分解序列 */
        int mid = (beg + end) / 2; // 计算中间值
        mSort(arr, beg, mid, tmp); // 递归分解左子序列
        mSort(arr, mid + 1, end, tmp); // 递归分解右子序列
        /* 合并两个子序列 */
        int i = beg; // 左子序列的索引
        int j = mid + 1; // 右子序列的索引
        int k = 0; // temp 临时序列的索引
        // 逐个比较，小的在前，大的在后
        while (i <= mid && j <= end)
            tmp[k++] = arr[i] <= arr[j] ? arr[i++] : arr[j++];
        // 将(可能)剩余的左子序列元素放进去
        while (i <= mid)
            tmp[k++] = arr[i++];
        // 将(可能)剩余的右子序列元素放进去
        while (j <= end)
            tmp[k++] = arr[j++];
        // 最后，将合并后的序列拷贝回原数组
        for (i = 0; i < k; i++)
            arr[beg + i] = tmp[i];
    }
}
/**
 * 归并排序 - 外部
 * @param arr    待排数组
 * @return int[] 已排数组
 */
public static int[] mergeSort(int[] arr) {
    mSort(arr, 0, arr.length - 1, new int[arr.length]);
    return arr;
}
</script></code></pre>
<p>时间复杂度：平均情况<code>O(nlogn)</code>、最好情况<code>O(nlogn)</code>、最坏情况<code>O(nlogn)</code><br>空间复杂度：<code>O(n)</code><br>算法稳定性：稳定</p>
<h2 id="七大排序算法总结"><a href="#七大排序算法总结" class="headerlink" title="七大排序算法总结"></a>七大排序算法总结</h2><table>
<thead>
<tr>
<th style="text-align:center">排序算法</th>
<th style="text-align:center">平均情况</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">辅助空间</th>
<th style="text-align:center">稳定性</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入排序</td>
<td style="text-align:center"><code>O(n^2)</code></td>
<td style="text-align:center"><code>O(n)</code></td>
<td style="text-align:center"><code>O(n^2)</code></td>
<td style="text-align:center"><code>O(1)</code></td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">n 小时较好</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center"><code>O(nlogn)</code><br>~<code>O(n^2)</code></td>
<td style="text-align:center"><code>O(n^1.3)</code></td>
<td style="text-align:center"><code>O(n^2)</code></td>
<td style="text-align:center"><code>O(1)</code></td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">都比较合适</td>
</tr>
<tr>
<td style="text-align:center">选择排序</td>
<td style="text-align:center"><code>O(n^2)</code></td>
<td style="text-align:center"><code>O(n^2)</code></td>
<td style="text-align:center"><code>O(n^2)</code></td>
<td style="text-align:center"><code>O(1)</code></td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">n 小时较好</td>
</tr>
<tr>
<td style="text-align:center">堆排序</td>
<td style="text-align:center"><code>O(nlogn)</code></td>
<td style="text-align:center"><code>O(nlogn)</code></td>
<td style="text-align:center"><code>O(nlogn)</code></td>
<td style="text-align:center"><code>O(1)</code></td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">n 大时较好</td>
</tr>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center"><code>O(n^2)</code></td>
<td style="text-align:center"><code>O(n)</code></td>
<td style="text-align:center"><code>O(n^2)</code></td>
<td style="text-align:center"><code>O(1)</code></td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">n 小时较好</td>
</tr>
<tr>
<td style="text-align:center">快速排序</td>
<td style="text-align:center"><code>O(nlogn)</code></td>
<td style="text-align:center"><code>O(nlogn)</code></td>
<td style="text-align:center"><code>O(n^2)</code></td>
<td style="text-align:center"><code>O(logn)</code><br>~<code>O(n)</code></td>
<td style="text-align:center">不稳定</td>
<td style="text-align:center">n 大时较好</td>
</tr>
<tr>
<td style="text-align:center">归并排序</td>
<td style="text-align:center"><code>O(nlogn)</code></td>
<td style="text-align:center"><code>O(nlogn)</code></td>
<td style="text-align:center"><code>O(nlogn)</code></td>
<td style="text-align:center"><code>O(n)</code></td>
<td style="text-align:center">稳定</td>
<td style="text-align:center">n 大时较好</td>
</tr>
</tbody>
</table>
<p>相关参考资料：<br><a href="http://bubkoo.com/2014/01/17/sort-algorithm/archives/" rel="external nofollow noopener noreferrer" target="_blank">常见排序算法【归档】</a><br><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/" rel="external nofollow noopener noreferrer" target="_blank">经典排序算法总结与实现</a><br><a href="https://zh.wikipedia.org/wiki/%E7%BA%BF%E6%80%A7%E6%90%9C%E7%B4%A2" rel="external nofollow noopener noreferrer" target="_blank">线性搜索 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95" rel="external nofollow noopener noreferrer" target="_blank">二分搜索 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F" rel="external nofollow noopener noreferrer" target="_blank">插入排序 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" rel="external nofollow noopener noreferrer" target="_blank">希尔排序 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F" rel="external nofollow noopener noreferrer" target="_blank">选择排序 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/%E5%A0%86%E6%8E%92%E5%BA%8F" rel="external nofollow noopener noreferrer" target="_blank">堆排序 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F" rel="external nofollow noopener noreferrer" target="_blank">冒泡排序 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/%E9%B8%A1%E5%B0%BE%E9%85%92%E6%8E%92%E5%BA%8F" rel="external nofollow noopener noreferrer" target="_blank">鸡尾酒排序 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F" rel="external nofollow noopener noreferrer" target="_blank">快速排序 - 维基百科，自由的百科全书</a><br><a href="https://zh.wikipedia.org/wiki/%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F" rel="external nofollow noopener noreferrer" target="_blank">归并排序 - 维基百科，自由的百科全书</a></p>
    </div>
    <div>
    </div>
    <div>
    </div>
    <div>
    </div>
    <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/数据结构与算法/" rel="tag"># 数据结构与算法</a>
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/java-xml.html" rel="next" title="Java XML 解析">
                <i class="fa fa-chevron-left"></i> Java XML 解析
              </a>
          </div>
          <span class="post-nav-divider"></span>
          <div class="post-nav-prev post-nav-item">
              <a href="/data-structures-algorithms.html" rel="prev" title="数据结构与算法 - 概述">
                数据结构与算法 - 概述 <i class="fa fa-chevron-right"></i>
              </a>
          </div>
        </div>
    </footer>
  </article>
    <div class="post-spread">
    </div>
  </div>
          </div>
  <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer" target="_blank">comments powered by Disqus.</a>
        </noscript>
      </div>
  </div>
        </div>
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>
  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Otokaze">
          <p class="site-author-name" itemprop="name">Otokaze</p>
              <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">170</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
        </nav>
        <div class="links-of-author motion-element">
              <span class="links-of-author-item">
                <a href="https://github.com/zfl9" target="_blank" title="GitHub rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-github"></i>
                  GitHub
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="mailto:zfl9.com@gmail.com" target="_blank" title="Email rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-envelope"></i>
                  Email
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://gitlab.com/zfl9" target="_blank" title="GitLab rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-gitlab"></i>
                  GitLab
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://t.me/Otokaze" target="_blank" title="Telegram rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-telegram"></i>
                  Telegram
                </a>
              </span>
        </div>
      </section>
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#线性查找-linearSearch"><span class="nav-number">1.</span> <span class="nav-text">线性查找 linearSearch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#二分查找-binarySearch"><span class="nav-number">2.</span> <span class="nav-text">二分查找 binarySearch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#插入排序-insertionSort"><span class="nav-number">3.</span> <span class="nav-text">插入排序 insertionSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#希尔排序-shellSort"><span class="nav-number">4.</span> <span class="nav-text">希尔排序 shellSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#选择排序-selectionSort"><span class="nav-number">5.</span> <span class="nav-text">选择排序 selectionSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#堆排序-heapSort"><span class="nav-number">6.</span> <span class="nav-text">堆排序 heapSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#冒泡排序-bubbleSort"><span class="nav-number">7.</span> <span class="nav-text">冒泡排序 bubbleSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#快速排序-quickSort"><span class="nav-number">8.</span> <span class="nav-text">快速排序 quickSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#归并排序-mergeSort"><span class="nav-number">9.</span> <span class="nav-text">归并排序 mergeSort</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#七大排序算法总结"><span class="nav-number">10.</span> <span class="nav-text">七大排序算法总结</span></a></li></ol></div>
          </div>
        </section>
      <!--/noindex-->
    </div>
  </aside>
      </div>
    </main>
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Otokaze</span>
</div>
<script src="/js/clipboard.min.js"></script>
<script src="/js/prism/prism.js" async></script>
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
  </div>
<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>
      <script id="dsq-count-scr" src="https://otokaze.disqus.com/count.js" async></script>
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://www.zfl9.com/array-search-sort-algo.html';
          this.page.identifier = 'array-search-sort-algo.html';
          this.page.title = '数组查找、排序算法';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://otokaze.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("3hhdw6gOg9wavsharVwVjqI3-gzGzoHsz", "O5WfDffqFsgmAVPwNY9of3QU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");
      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });
      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';
          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);
            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);
      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }
    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</body>
</html>
