<!doctype html>
<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">
<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">
<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">
  <meta name="keywords" content="php,">
  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1">
<meta name="description" content="PHP（全称：PHP: Hypertext Preprocessor，即 PHP 超文本预处理器）是开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入 HTML 中使用。PHP 的语法借鉴吸收 C 语言、Java 和 Perl 等流行计算机语言的特点，易于一般程序员学习。PHP 的主要目标是允许网络开发人员快速编写动态页面，但 PHP 也被用于其它很多领域。">
<meta name="keywords" content="php">
<meta property="og:type" content="article">
<meta property="og:title" content="PHP 笔记">
<meta property="og:url" content="https://www.zfl9.com/php.html">
<meta property="og:site_name" content="Otokaze's Blog">
<meta property="og:description" content="PHP（全称：PHP: Hypertext Preprocessor，即 PHP 超文本预处理器）是开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入 HTML 中使用。PHP 的语法借鉴吸收 C 语言、Java 和 Perl 等流行计算机语言的特点，易于一般程序员学习。PHP 的主要目标是允许网络开发人员快速编写动态页面，但 PHP 也被用于其它很多领域。">
<meta property="og:image" content="https://www.zfl9.com/images/php-helloworld.png">
<meta property="og:image" content="https://www.zfl9.com/images/php-phpinfo.png">
<meta property="og:image" content="https://www.zfl9.com/images/php-server.png">
<meta property="og:updated_time" content="2020-07-04T13:10:25.312Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="PHP 笔记">
<meta name="twitter:description" content="PHP（全称：PHP: Hypertext Preprocessor，即 PHP 超文本预处理器）是开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入 HTML 中使用。PHP 的语法借鉴吸收 C 语言、Java 和 Perl 等流行计算机语言的特点，易于一般程序员学习。PHP 的主要目标是允许网络开发人员快速编写动态页面，但 PHP 也被用于其它很多领域。">
<meta name="twitter:image" content="https://www.zfl9.com/images/php-helloworld.png">
<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
  <link rel="canonical" href="https://www.zfl9.com/php.html">
<link href="/js/prism/prism.css" rel="stylesheet">
  <title>PHP 笔记 | Otokaze's Blog</title>
</head>
<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-97872912-1', 'auto');
  ga('send', 'pageview');
</script>
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3d58f51dbb2496a0e6d17b85065a5ae5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Otokaze's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">拼一年春夏秋冬，搏一生无怨无悔</h1>
  </div>
  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>
<nav class="site-nav">
    <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            首页
          </a>
        </li>
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            分类
          </a>
        </li>
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            标签
          </a>
        </li>
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            归档
          </a>
        </li>
    </ul>
</nav>
 </div>
    </header>
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
  <div id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.zfl9.com/php.html">
    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Otokaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>
    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Otokaze's Blog">
    </span>
      <header class="post-header">
          <h2 class="post-title" itemprop="name headline">
                PHP 笔记
          </h2>
        <div class="post-meta">
          <span class="post-time">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
                <span class="post-meta-item-text">发表于</span>
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-11-29T08:00:00+08:00">
                2018-11-29
              </time>
          </span>
            <span class="post-category">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
                <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/php/" itemprop="url" rel="index">
                    <span itemprop="name">php</span>
                  </a>
                </span>
            </span>
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/php.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="php.html" itemprop="commentCount"></span>
                </a>
              </span>
             <span id="/php.html" class="leancloud_visitors" data-flag-title="PHP 笔记">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
                 <span class="post-meta-item-text">阅读次数 </span>
                 <span class="leancloud-visitors-count"></span>
             </span>
        </div>
      </header>
    <div class="post-body" itemprop="articleBody">
        <p>PHP（全称：<code>PHP: Hypertext Preprocessor</code>，即 PHP 超文本预处理器）是开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入 HTML 中使用。PHP 的语法借鉴吸收 C 语言、Java 和 Perl 等流行计算机语言的特点，易于一般程序员学习。PHP 的主要目标是允许网络开发人员快速编写动态页面，但 PHP 也被用于其它很多领域。</p>
<a id="more"></a>
<h2 id="PHP-简介"><a href="#PHP-简介" class="headerlink" title="PHP 简介"></a>PHP 简介</h2><p><strong>PHP</strong>（全称：<strong>P</strong>HP：<strong>H</strong>ypertext <strong>P</strong>reprocessor，即“PHP：超文本预处理器”）是一种开源的通用计算机脚本语言，尤其适用于网络开发并可嵌入HTML中使用。PHP的语法借鉴吸收C语言、Java和Perl等流行计算机语言的特点，易于一般程序员学习。PHP的主要目标是允许网络开发人员快速编写动态页面，但PHP也被用于其他很多领域。</p>
<p>PHP最初是由勒多夫在1995年开始开发的；现在PHP的标准由the PHP Group维护。PHP以PHP License作为许可协议，不过因为这个协议限制了PHP名称的使用，所以和开放源代码许可协议GPL不兼容。</p>
<p>PHP的应用范围相当广泛，尤其是在网页程序的开发上。一般来说PHP大多运行在网页服务器上，通过运行PHP代码来产生用户浏览的网页。PHP可以在多数的服务器和操作系统上运行，而且使用PHP完全是免费的。根据2013年4月的统计数据，PHP已经被安装在超过2亿4400万个网站和210万台服务器上。</p>
<p><a href="https://secure.php.net/manual/zh/" rel="external nofollow noopener noreferrer" target="_blank">PHP 手册 - Manual</a> | PHP 官网</p>
<p><code>index.php</code></p>
<pre><code class="language-php line-numbers"><script type="text/plain">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>hello, world!</title>
  </head>
  <body>
    <?php
    echo '<h1>hello, world!</h1>';
    ?>
  </body>
</html>
</script></code></pre>
<p><img src="/images/php-helloworld.png" alt="PHP helloworld"></p>
<p>PHP 是一种脚本语言，常见的脚本语言有：Shell、Perl、AWK。脚本语言通常都是解释运行的，不存在编译、链接过程。比如 Shell 脚本 test.sh（可执行权限），其实质为纯文本文件，但是我们可以直接通过运行 <code>./test.sh</code> 命令来执行该脚本，这是脚本语言最方便的地方。PHP 与 Shell、Perl 脚本有很多相似的地方，都可以使用类似的方法直接运行。例如上述 PHP helloworld 文件 <code>index.php</code>，可以通过 <code>php index.php</code> 或 <code>./index.php</code>（可执行权限，首行约定标记）来获取 HTML 输出，这种方式的输出结果和浏览器接收到的结果是一模一样的，因此，你完全可以将 PHP 当作一种 Shell 来使用（当然，PHP 主要用于 WEB 开发）。</p>
<p>PHP 动态文件与普通的静态文件有一个显著区别，当我们用浏览器打开某个静态资源（如 HTML 文档）时，获取到的数据就是静态资源本身，没有经过任何处理。<br>而当我们用浏览器打开某个 PHP 文件时，获取到的却不是 PHP 文件自身（源码），而是 PHP 文件执行的输出结果！也就是说，在接收该资源前，Web 服务器将 PHP 源码进行了预处理（执行 PHP 文件，获取其输出），这也就是 Hypertext Preprocessor，超文本预处理器名称的意义所在。</p>
<p>PHP 与 Web Server（主要考虑 Apache、Nginx）之间是如何协作的呢？</p>
<ul>
<li>Apache：通过 PHP 模块来执行请求的 PHP 文件</li>
<li>Nginx：通过 PHP-FPM（FastCGI）来执行请求的 PHP 文件</li>
</ul>
<p>因为我自己使用的是 nginx（轻量级嘛），因此以下内容均以 nginx 为例。假设浏览器请求的文件为 index.php，浏览器发送 HTTP 请求，nginx 接收 HTTP 请求，发现浏览器请求的不是静态资源，于是将其交给 php-fpm（FastCGI 进程管理器，只管理 php cgi 进程，所谓的 php cgi 进程就是一个普通的 php 解释器进程，用于解释运行 php 脚本），php-fpm 随机选择一个空闲的 worker 进程（也就是 php cgi 程序），将该请求交由此 worker 进程处理，处理完成后，php-fpm 将结果返回给 nginx，最后 nginx 将结果再返回给浏览器，最终，呈现给用户。</p>
<p>那么，shell 脚本（以此为例）可以经过类似的方法，来作为 web 脚本来使用吗？当然可以。但是我们不能使用 php-fpm 了，而是应使用通用的 fastcgi 进程管理器（比如 spawn-fcgi），此外，我们还需要一个通用的 cgi 包装器（比如 fcgiwrap），因为 shell 不支持 cgi 协议，然后就可以将 shell 脚本作为 web 脚本来使用了。</p>
<p>PHP 中存在三种注释语法：<code>#</code>、<code>//</code>、<code>/* */</code>，第一种是 shell 中的注视风格。</p>
<p>PHP 解释器和其他的脚本语言解释器有一个显著区别：PHP 解释器只会处理 PHP 标记中的内容，而 PHP 标记外的内容会原样输出，这使得在任何文档中都很容易的插入 PHP 代码，而不需要将源文档做大变动。PHP 开始标记 <code>&lt;?php</code>、PHP 结束标记 <code>?&gt;</code>。</p>
<p>注意，在以命令行脚本方式启动 php 解释器时，php 解释器还会忽略脚本首行的 unix 脚本约定标记 <code>#!/bin/php</code>，但 cgi 模式下不会忽略此标记，而是被当作普通文本。</p>
<h2 id="PHP-安装"><a href="#PHP-安装" class="headerlink" title="PHP 安装"></a>PHP 安装</h2><p>安装 PHP 的前提：已安装并配置好 nginx 服务器，可以处理 http 请求。<br>ArchLinux：<code>pacman -S php-fpm</code>，安装 php-fpm（会自动安装 php 解释器）。</p>
<p>修改 <code>/etc/php/php.ini</code>，将 1 改为 0，即 <code>cgi.fix_pathinfo=0</code>。<br>修改 <code>/etc/php-fpm.d/www.conf</code>，<code>user</code>、<code>group</code>、<code>listen.owner</code>、<code>listen.group</code> 改为 <code>nginx</code>、<code>listen.mode</code> 改为 <code>0660</code>。</p>
<p>修改 nginx 站点配置文件，假如为 www.conf，注意 php-fpm 监听 socket 的路径：</p>
<pre><code class="language-nginx line-numbers"><script type="text/plain">
server {
    listen      80;
    server_name www.zfl.com;
    root    /usr/share/nginx/html;
    index   index.php index.html;
    location ~* \.php$ {
        fastcgi_index   index.php;
        #fastcgi_pass    127.0.0.1:9000;
        fastcgi_pass    unix:/run/php-fpm/php-fpm.sock;
        include         fastcgi_params;
        fastcgi_param   SCRIPT_FILENAME    $document_root$fastcgi_script_name;
        fastcgi_param   SCRIPT_NAME        $fastcgi_script_name;
    }
}
</script></code></pre>
<p>启动 php-fpm 服务，重载 nginx 配置文件：<br><code>systemctl start php-fpm</code>、<code>systemctl reload nginx</code></p>
<p>测试 php 是否可以工作，新建页面 index.php：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
<?php
phpinfo();
?>
</script></code></pre>
<p>打开浏览器，<code>http://www.zfl.com/</code>，如果配置正常，则：<br><img src="/images/php-phpinfo.png" alt="PHP phpinfo 测试页面"></p>
<h2 id="PHP-语法"><a href="#PHP-语法" class="headerlink" title="PHP 语法"></a>PHP 语法</h2><p>PHP 解释器只会解释运行位于 PHP 标记内的代码，PHP 开始标记为 <code>&lt;?php</code>，PHP 结束标记为 <code>?&gt;</code>。位于 PHP 标记外的内容只会被原样输出（当然，存在条件判断语句的除外），因为这个特点，在任何文档中插入 PHP 都很容易。</p>
<p>PHP 中存在三种注释语法：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
# 单行注释
// 单行注释
/* 多行注释 */
</script></code></pre>
<h2 id="PHP-输入"><a href="#PHP-输入" class="headerlink" title="PHP 输入"></a>PHP 输入</h2><p><code>$argc</code>：命令行参数的数目，最少为 1<br><code>$argv</code>：命令行参数的数组，<code>$argv[0]</code> 为脚本名称</p>
<h2 id="PHP-输出"><a href="#PHP-输出" class="headerlink" title="PHP 输出"></a>PHP 输出</h2><p>PHP 中用于输出内容的函数/语句：<code>echo</code>、<code>print</code>、<code>print_r</code>、<code>var_dump</code>。<br><code>echo</code>、<code>print</code> 都不是函数，而是 PHP 语言结构，因此不需要添加圆括号。</p>
<ul>
<li><code>echo var1[, var2[, var3, ...]]</code>：输出一个或多个变量的值，不自动换行</li>
<li><code>print var</code>：输出一个变量的值，总是返回 1，比 echo 慢，也不会自动换行</li>
<li><code>print_r(var[, returnResult])</code>：打印变量的值（易读），不自动换行，如果参数 returnResult 为 true，则不打印变量值，而是将要打印的内容返回给调用者</li>
<li><code>var_dump(var1[, var2[, var3, ...]])</code>：打印一个或多个变量的值（易读&amp;调试）</li>
</ul>
<h2 id="PHP-变量"><a href="#PHP-变量" class="headerlink" title="PHP 变量"></a>PHP 变量</h2><p>PHP 变量命名规则：必须以 <code>$</code> 开头，后接 PHP 标识符。<br>PHP 标识符必须以 <strong>字母</strong>、<strong>下划线</strong> 开头，后可接 <strong>字母</strong>、<strong>数字</strong>、<strong>下划线</strong>。</p>
<p>PHP 没有变量声明语句，在第一次给变量赋值的时候会被自动创建，如 <code>$x = 5;</code>。并且我们也不需要声明变量的类型，PHP 会根据变量的值，自动推测实际的数据类型。并且，我们可以在运行过程中给同一个变量赋予不同类型的值，PHP 会自动推测该变量的实际类型，这个和 JS 是一样的。</p>
<p>PHP 有 3 种变量作用域，分别是：</p>
<ul>
<li><strong>全局作用域</strong>：在所有函数外部定义的变量拥有全局作用域。全局变量可以在脚本的任何地方（当然要在声明了之后）被访问，但在函数内部访问需要使用 <code>global</code> 关键字声明，即 <code>global $x, $y;</code> 后，才可以在函数内部被访问，否则报错（真特么奇葩，不知道设计者怎么想的！）</li>
<li><strong>函数作用域</strong>：在函数内部定义的变量拥有函数作用域。局部变量生死于栈中，在函数调用时被创建，在函数返回时被销毁，因此每次函数调用，其中的局部变量都是不一样的。不同函数中允许存在同名局部变量，没有任何影响。局部变量只能在函数内部被访问，其它地方都是无法访问得到的。</li>
<li><strong>静态作用域</strong>：正常情况下，局部作用域中变量都是随函数调用而创建，随函数返回而销毁的；如果你希望某些局部变量不被自动销毁，可以将它们声明为 static 变量，即在函数内部使用 <code>static $cnt = 0;</code>，$cnt 变成静态局部变量，会一直存储在内存中，直到程序结束，但是，此变量仅限函数内部使用，在外部无法访问。</li>
</ul>
<blockquote>
<p>特别注意，PHP 中没有 <strong>块作用域</strong>（语句块），这个和 JavaScript 是一样的。</p>
</blockquote>
<h2 id="PHP-常量"><a href="#PHP-常量" class="headerlink" title="PHP 常量"></a>PHP 常量</h2><p>PHP 中的常量类似于 C/C++ 中的宏定义，常量名就是普通的 PHP 标识符（不以 <code>$</code> 开头），常量一旦定义后，就不可再改变了，因此，建议使用大写字符表示常量。已定义的常量可以在脚本的任意位置被访问，而不需要使用 global 声明（函数中访问全局变量需要此关键字），其实 PHP 已经预定义了许多常量，它们大多以 <code>PHP_</code> 开头，我们平时用的 <code>null</code>、<code>true</code>、<code>false</code>（不区分大小写）就是预定义的常量。</p>
<p>定义常量的两种方式：<br><code>bool define(string $name, mixed $value[, bool $case_insensitive = false])</code><br><code>const CONST_NAME = value</code>：只能在顶层作用域中使用，循环、if 判断、函数中不可用</p>
<h2 id="PHP-超全局变量"><a href="#PHP-超全局变量" class="headerlink" title="PHP 超全局变量"></a>PHP 超全局变量</h2><p>超全局变量是在脚本任何位置都可用的内置变量，这是与全局变量的不同之处。如下：</p>
<ul>
<li><code>$GLOBALS</code>：保存全局变量的数组，键就是变量名（没有 <code>$</code>）</li>
<li><code>$_SERVER</code>：保存请求头、路径、脚本位置等信息的数组，由 Web 服务器创建</li>
<li><code>$_GET</code>：通过 URL 参数传递给当前脚本的变量的数组</li>
<li><code>$_POST</code>：通过 POST 方法传递给当前脚本的变量的数组</li>
<li><code>$_FILES</code>：通过 POST 方法上传给当前脚本的文件的数组</li>
<li><code>$_COOKIE</code>：通过 Cookies 方式传递给当前脚本的变量的数组</li>
<li><code>$_SESSION</code>：当前脚本可用 SESSION 变量的数组</li>
<li><code>$_REQUEST</code>：包含 <code>$_GET</code>、<code>$_POST</code>、<code>$_COOKIE</code> 的数组</li>
<li><code>$_ENV</code>：包含外部环境变量（通常是 Shell 环境变量）的数组</li>
</ul>
<h2 id="PHP-魔术变量"><a href="#PHP-魔术变量" class="headerlink" title="PHP 魔术变量"></a>PHP 魔术变量</h2><p>PHP 向它运行的任何脚本提供了大量的预定义常量。不过很多常量都是由不同的扩展库定义的，只有在加载了这些扩展库时才会出现，或者动态加载后，或者在编译时已经包括进去了。</p>
<p>有八个魔术常量它们的值随着它们在代码中的位置改变而改变。例如 <code>__LINE__</code> 的值就依赖于它在脚本中所处的行来决定。这些特殊的常量不区分大小写，如下：</p>
<ul>
<li><code>__LINE__</code>：当前所在的行号</li>
<li><code>__FILE__</code>：脚本的绝对路径</li>
<li><code>__DIR__</code>：脚本所在的目录</li>
<li><code>__FUNCTION__</code>：当前所在的函数</li>
<li><code>__CLASS__</code>：当前所在的类名</li>
<li><code>__METHOD__</code>：当前所在的方法</li>
<li><code>__NAMESPACE__</code>：当前所在的命名空间</li>
</ul>
<h2 id="PHP-数据类型"><a href="#PHP-数据类型" class="headerlink" title="PHP 数据类型"></a>PHP 数据类型</h2><p><code>Boolean</code> 布尔、<code>Integer</code> 整型、<code>Float</code> 浮点型、<code>String</code> 字符串<br><code>Array</code> 数组（散列表、关联数组）、<code>Object</code> 对象、<code>NULL</code> 空指针/引用</p>
<p><strong>布尔</strong>：字面量 <code>true</code>、<code>false</code>（不区分大小写）<br>可使用 <code>(bool)</code>、<code>(boolean)</code> 进行强制类型转换<br>除 <code>false</code>、<code>0</code>、<code>0.0</code>、<code>&quot;&quot;</code>、<code>&quot;0&quot;</code>、<code>null</code>、空数组外，其它均为 true</p>
<p><strong>整型</strong>：二进制（<code>0b</code>）、八进制（<code>0</code>）、十进制、十六进制（<code>0x</code>）<br>整型的长度是平台相关的，常量 <code>PHP_INT_SIZE</code> 表示整型的长度<br>常量 <code>PHP_INT_MIN</code>、<code>PHP_INT_MAX</code> 分别表示整型的最小值和最大值<br>如果给定的数字超过了 Integer 类型的范围，会被转换为 Float 浮点型<br>使用 <code>(int)</code>、<code>(integer)</code> 可以将其它类型的值强制转换为 integer 整型<br><code>true</code> 为 1，<code>false</code> 为 0，浮点数转换为整数会直接丢弃小数部分，即向下取整<br>字符串也可以转换为整数、浮点数，并且，字符串中允许存在任意的前导空白符<br>对于整型 a、b，进行 <code>a / b</code> 运算，如果可以整除，则返回整型，否则返回浮点型</p>
<p><strong>浮点型</strong>：十进制，浮点数，可使用科学记数法，如 1300 用科学记数法表示为 <code>1.3 * 10^3</code>，在 PHP 中则表示为 <code>1.3e3</code> 或 <code>1.3E3</code>。对于 <code>aEn</code>，a 的取值范围 <code>1 &lt;= |a| &lt; 10</code>，n 是一个整数（可以是正数、负数）。同样的，使用 <code>(float)</code> 语法可将其他类型转换为浮点类型</p>
<p><strong>字符串</strong>：一个字符串可以用四种方式表达：<strong>单引号</strong>、<strong>双引号</strong>、<strong>heredoc</strong>、<strong>nowdoc</strong>。所有方式都可以跨行，即可以键入多行字符串，包括 单引号、双引号 方式。</p>
<p>定义一个字符串最简单的方法就是使用 <strong>单引号</strong> 将字符串内容包围起来（字符 <code>&#39;</code>）。要表达单引号本身，请使用 <code>\&#39;</code>，要表达反斜杠本身，请使用 <code>\\</code>，其余任何转义序列都是无效的，都会被原样输出。不像 双引号 和 heredoc 结构，单引号字符串中的 <strong>变量引用</strong>、<strong>特殊字符转移序列</strong> 均不生效，都会被原样输出。</p>
<p>如果使用 <strong>双引号</strong> 存储字符串，PHP 会对以下特殊字符进行转义：<br>转移序列|具体含义<br>:—:|:—:<br><code>\r</code>|回车符<br><code>\n</code>|换行符<br><code>\t</code>|水平制表<br><code>\v</code>|垂直制表<br><code>\f</code>|换页符<br><code>\e</code>|ESC 符<br><code>\\</code>|反斜杠<br><code>\$</code>|美元符<br><code>\&quot;</code>|双引号<br><code>\[0-7]{1,3}</code>|(regex) 八进制数值表示的字符<br><code>\x[0-9A-Fa-f]{1,2}</code>|(regex) 十六进制数值表示的字符<br><code>\u{unicode-code-point}</code>|Unicode 码点表示的字符（PHP7）</p>
<p>和单引号一样，未在上表的其他任何转移序列都会导致反斜杠被显示出来。除此之外，双引号和 heredoc 结构还有一个重要特征，其中的变量会被解析。变量解析有两种语法规则：<strong>简单规则</strong>、<strong>复杂规则</strong>（不是指语法复杂，而是它可以使用复杂的表达式）。</p>
<p>简单规则是最常用也是最方便的，它可以用最少的代码在一个字符串中嵌入一个 <strong>变量</strong>、<strong>数组的元素</strong>、<strong>对象的属性</strong>。当 PHP 解释器遇到字符串中的 <code>$</code> 时，会组合尽量多的标识以形成一个合法的变量名，如需确定边界，建议使用花括号包住变量名（和 Shell 一样）。比如 <code>&quot;$ABC&quot;</code>，我只是想引用 <code>$A</code> 变量，可是 PHP 解释器却误以为我要引用 <code>$ABC</code> 变量，但是使用 <code>&quot;${A}BC&quot;</code> 就没有这个问题了，因为我们指明了边界。</p>
<p>引用 <strong>关联数组的元素</strong>，<code>&quot;$arr[0]&quot;</code>、<code>&quot;$arr[key]&quot;</code>（注意不需要引号）；<br>引用 <strong>对象的属性</strong>，<code>&quot;$obj-&gt;prop&quot;</code>（注意，箭头符号两边不允许空格符）。</p>
<p>复杂语法不是因为其语法复杂而得名，而是因为它可以使用复杂的表达式。只需在 PHP 表达式两边添加花括号，不过要注意的是，左花括号必须与 PHP 表达式的 <code>$</code> 紧密相联，中间不允许任何空白，否则 PHP 表达式仅被当作普通字符串。与简单规则相似，复杂规则中允许 3 种形式：<strong>变量</strong>、<strong>数组元素</strong>、<strong>对象属性</strong>（语法不需要改变）。</p>
<p>单引号 -&gt; nowdoc、双引号 -&gt; heredoc，它们之间的区别也于单双引号的区别类似。nowdoc、heredoc 都有着类似的语法，heredoc 以 <code>&lt;&lt;&lt;EOF</code> 或 <code>&lt;&lt;&lt;&quot;EOF&quot;</code> 开头（EOF 可为其它任意合法的标识符，下同），nowdoc 以 <code>&lt;&lt;&lt;&#39;EOF&#39;</code> 开头，它们都以 <code>EOF;</code> 结尾（必须顶格写，前后都不允许任何空白，否则会被当作字符串内容）。</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
#!/bin/php
<?php
$str = <<<EOF
www.zfl9.com
www.baidu.com
www.google.com
EOF;
echo $str.PHP_EOL;
?>
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ ./main.php
www.zfl9.com
www.baidu.com
www.google.com
</script></code></pre>
<p>PHP 字符串在实现方式上，类似于 <strong>字节数组</strong>，因此，你可以直接使用下标运算符 <code>[0]</code> 来获取字符串的第 0 个字符，注意是可读可写的哦。如果往超出字符串长度的位置写入，则中间的字符全部被空格填充。不过用此方法修改多字节字符集很不安全，仅应对单字节编码，例如 ASCII、ISO-8859-1 的字符串进行此操作。</p>
<p>使用 <code>.</code> 运算符进行字符串拼接（注意不是 <code>+</code>），使用 <code>(string)</code> 可将其它类型的数据转换为字符串类型，但通常这是没有必要的，因为大多数时候 PHP 会自动进行转换。</p>
<p>PHP 字符串使用的字符编码是没有硬性规定的，默认情况下，字符串会被按照与当前脚本文件相同的字符编码来存储。为了不必要的乱码麻烦，强烈建议使用 UTF-8 编码保存 PHP 文件，并且在操作 PHP 字符串时，也应使用对应的 <code>mb_xxx</code> 函数。</p>
<p><strong>关联数组</strong>：PHP 中的数组其实就是 Java 中的哈希表（LinkedHashMap），也和 JavaScript 中的对象/数组类似。其中 key 为 string 类型，value 可为任意类型。key 如果为非负整数，可以省略引号，PHP 会自动转换为对应的字符串。</p>
<p><code>array(e0, e1, e2, ..., eN)</code>（key 为对应的下标）<br><code>array(k1 =&gt; v1, k2 =&gt; v2, k3 =&gt; v3)</code>（自定义 key）<br><code>array(e0, e1, k1 =&gt; v1, k2 =&gt; v2, e2, e3)</code>（二者混合，e2、e3 下标为 2、3）</p>
<blockquote>
<p>从 PHP 5.4 起，可以使用更简单的语法来定义数组：<code>[]</code> 替代 <code>array()</code></p>
</blockquote>
<p>使用 <code>(array)</code> 可将其它类型的数据转换为数组类型<br>使用 <code>unset(var...)</code> 函数可以删除一个或多个变量、数组的键值对</p>
<p>使用 foreach 遍历数组：<br><code>foreach ($arr as $elem)</code>：按值传递，其中 <code>$elem</code> 在循环体外仍可用<br><code>foreach ($arr as &amp;$elem)</code>：引用传递，其中 <code>$elem</code> 在循环外体仍可用<br><code>foreach ($arr as $key =&gt; $value)</code>：按值传递，<code>$key</code>、<code>$value</code>在循环体外仍可用<br><code>foreach ($arr as $key =&gt; &amp;$value)</code>：引用传递，<code>$key</code>、<code>$value</code>在循环体外仍可用<br>建议在循环结束后，使用 <code>unset()</code> 释放 foreach 定义的引用变量，防止误改数组元素</p>
<p>PHP 中有 <strong>按值传递</strong>（默认）、<strong>引用传递</strong> 两种语法，引用传递使用 <code>&amp;</code> 语法。注意，PHP 中的引用与 C/C++ 中的指针不同，你可以将 PHP 的引用看作 Unix 中的 <strong>硬链接</strong>。如 <code>$a = 10</code>、<code>$b = &amp;$a</code>，此时 <code>$a</code>、<code>$b</code> 是完全等价的，相当于一个文件的两个硬连接，<code>$a</code>、<code>$b</code> 都指向了同一个地方。使用 <code>unset($a)</code> 或 <code>unset($b)</code> 仅仅相当于删除了一个文件的硬链接，只要该文件还有至少一个硬连接，它就还可以被访问。在 PHP 也是这样，只要还有至少一个变量名指向它，就可以被访问的到。</p>
<p><code>count($array)</code>：获取给定数组的元素数目（键值对数目，长度）<br><code>sort($array)</code>：升序排列<br><code>rsort($array)</code>：降序排列<br><code>ksort($array)</code>：（key）升序排列<br><code>krsort($array)</code>：（key）降序排列<br><code>asort($array)</code>：（value）升序排列<br><code>arsort($array)</code>：（value）降序排列</p>
<p><strong>对象</strong>：要创建对象，必须先定义类，然后使用 new 关键字创建该类的实例（对象）。</p>
<p><strong>NULL</strong>：NULL 本身是空指针的意思，不过，我更喜欢理解为 JS 的 <code>undefined</code>、<code>null</code> 的合体。因为，一个未初始化的变量的值为 null，没有返回语句或不返回值的函数的执行结果为 null，这些都与 JS 的 undefined 功能对应。</p>
<p>PHP 中如何判断一个变量的实际类型，使用 <code>is_xxx()</code> 方法可判断变量的实际类型：<br><code>is_bool(var)</code>：是否为 boolean 布尔<br><code>is_int(var) | is_integer(var)</code>：是否为 integer 整型<br><code>is_float(var) | is_double(var)</code>：是否为 float/double 浮点型<br><code>is_numeric(var)</code>：是否为 integer、float/double、对应的字符串<br><code>is_nan(var)</code>：是否为 not-a-number 非数字<br><code>is_string(var)</code>：是否为 string 字符串<br><code>is_array(var)</code>：是否为 array 关联数组<br><code>is_object(var)</code>：是否为 object 实例对象<br><code>is_null(var)</code>：是否为 null 空指针/空引用</p>
<h2 id="PHP-运算符"><a href="#PHP-运算符" class="headerlink" title="PHP 运算符"></a>PHP 运算符</h2><p><strong>算术运算符</strong>：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>取余、<code>**</code>乘方、<code>+var</code>正、<code>-var</code>负<br><strong>赋值运算符</strong>：<code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>**=</code>、<code>.=</code>字符串拼接<br><strong>自增/自减运算符</strong>：<code>++var</code>前自增、<code>var++</code>后自增、<code>--var</code>前自减、<code>var--</code>后自减<br><strong>比较运算符</strong>：<code>==</code>值等、<code>===</code>全等、<code>!=</code>值不等、<code>!==</code>不全等、<code>&gt;</code>、<code>&gt;=</code>、<code>&lt;</code>、<code>&lt;=</code><br><strong>逻辑运算符</strong>：<code>and</code>/<code>&amp;&amp;</code>、<code>or</code>/<code>||</code>、<code>xor</code>异或（两者不同则为真）、<code>!</code>非(单目)<br><strong>字符串连接符</strong>：<code>.</code>字符串拼接、<code>.=</code>字符串拼接并赋值<br><strong>数组运算符</strong>：<code>x + y</code>并集(key)、<code>==</code>值等、<code>===</code>值相等&amp;类型相同&amp;顺序相同、<code>!=</code>、<code>!==</code><br><strong>三元运算符</strong>：<code>expr ? expr1 : expr2</code>，如果 expr 为真则结果为 expr1，否则为 expr2<br><strong>位运算符</strong>：<code>&amp;</code>按位与、<code>|</code>按位或、<code>^</code>按位异或、<code>~</code>按位非(单目)、<code>&gt;&gt;</code>右移、<code>&lt;&lt;</code>左移<br><strong>类型运算符</strong>：<code>instanceof</code>判断给定对象是否为给定类的实例</p>
<h2 id="PHP-流程控制"><a href="#PHP-流程控制" class="headerlink" title="PHP 流程控制"></a>PHP 流程控制</h2><p><strong><code>if</code></strong></p>
<pre><code class="language-php line-numbers"><script type="text/plain">
if (condition)
    statement;
// or
if (condtion)
    statement;
else
    statement;
// or
if (condtion)
    statement;
elseif // or else if
    statement;
elseif // or else if
    statement;
else
    statement;
</script></code></pre>
<p><strong><code>while</code></strong></p>
<pre><code class="language-php line-numbers"><script type="text/plain">
while (condition)
    statement;
</script></code></pre>
<p><strong><code>do...while</code></strong></p>
<pre><code class="language-php line-numbers"><script type="text/plain">
do
    statement;
while (condition);
</script></code></pre>
<p><strong><code>for</code></strong></p>
<pre><code class="language-php line-numbers"><script type="text/plain">
for (expr1; expr2; expr3)
    statement;
</script></code></pre>
<p><strong><code>foreach</code></strong></p>
<pre><code class="language-php line-numbers"><script type="text/plain">
// 值传递
foreach ($array as $value)
    statement;
// 引用传递
foreach ($array as &$value)
    statement;
// 值传递
foreach ($array as $key => $value)
    statement;
// 引用传递
foreach ($array as $key => &$value)
    statement;
</script></code></pre>
<p><strong><code>switch</code></strong></p>
<pre><code class="language-php line-numbers"><script type="text/plain">
// 比较时使用 ==，可理解为 if 的变种
switch ($testValue) {
    case value1:
        statement;
        break;
    case value2:
        statement;
        break;
    ...
    default:
        statement;
}
</script></code></pre>
<p><strong><code>break</code>、<code>continue</code></strong><br><code>break</code>：跳出当前循环，执行循环体后面的代码<br><code>continue</code>：结束此轮循环，直接开始下一轮循环</p>
<p>它们都接收一个可选的数字（正整数）参数，表示跳出多少层循环，默认值为 1，即跳出当前所在的循环（注意是从 1 开始，不是从 0 开始）。</p>
<p><strong>流程控制的替代语法</strong><br>PHP 提供了一些流程控制的替代语法，包括 <code>if</code>，<code>while</code>，<code>for</code>，<code>foreach</code> 和 <code>switch</code>。替代语法的基本形式是把左花括号（<code>{</code>）换成冒号（<code>:</code>），把右花括号（<code>}</code>）分别换成 <code>endif;</code>，<code>endwhile;</code>，<code>endfor;</code>，<code>endforeach;</code> 以及 <code>endswitch;</code>。</p>
<p>但是要注意，不能在同一控制块中混合使用两种语法。PHP 提供替代语法的主要目的就是为了方便控制 HTML 文档（以 HTML 为例）的输出。</p>
<p>例子，当用户使用的是 IE 浏览器时，显示 IE，当使用 Chrome 浏览器时，显示 Chrome，其他浏览器则显示其他。使用传统语法：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>hello, world!</title>
  </head>
  <body>
    <h1>hello, world!</h1>
<?php if (strpos($_SERVER['HTTP_USER_AGENT'], 'IE') !== false) { ?>
    <h1>你使用的是 IE 浏览器</h1>
<?php } elseif (strpos($_SERVER['HTTP_USER_AGENT'], 'Chrome') !== false) { ?>
    <h1>你使用的是 Chrome 浏览器</h1>
<?php } else { ?>
    <h1>你使用的是 其他 浏览器</h1>
<?php } ?>
  </body>
</html>
</script></code></pre>
<p>很多大括号，容易混淆视线，不易检查错误，改用替代语法：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>hello, world!</title>
  </head>
  <body>
    <h1>hello, world!</h1>
<?php if (strpos($_SERVER['HTTP_USER_AGENT'], 'IE') !== false): ?>
    <h1>你使用的是 IE 浏览器</h1>
<?php elseif (strpos($_SERVER['HTTP_USER_AGENT'], 'Chrome') !== false): ?>
    <h1>你使用的是 Chrome 浏览器</h1>
<?php else: ?>
    <h1>你使用的是 其他 浏览器</h1>
<?php endif; ?>
  </body>
</html>
</script></code></pre>
<h2 id="PHP-函数"><a href="#PHP-函数" class="headerlink" title="PHP 函数"></a>PHP 函数</h2><p>PHP 中的函数语法和函数特性与 JavaScript 大致相同。如，简单的求和函数：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
function sum($a, $b) {
    return $a + $b;
}
</script></code></pre>
<p>函数名必须是合法的 PHP 标识符（以字母、下划线开头，后可接字母数字下划线）。<br>函数可以有参数，参数实际就是函数的局部变量，因此它的命名方法和普通变量一致。<br>函数的传参方式默认是<strong>值传递</strong>，如需<strong>引用传递</strong>，使用 <code>&amp;</code> 语法，即 <code>func(&amp;$a, &amp;$b)</code>。<br>函数中的 return 语句不是必须的，如果省略或 <code>return;</code>，则默认为 <code>return null;</code>。<br>任何有效的 PHP 代码都有可能出现在函数体中，包括其它函数的定义、类的定义等。</p>
<p>但是，在函数中嵌套的定义函数（匿名函数不算，那其实是对象）、类是不被推荐的，为什么呢？因为当一个函数中存在其他函数定义、类定义时，此时调用函数的具体表现有点像调用 PHP 解释器来运行函数体的代码，文字叙述可能不太清楚，我们还是看代码吧，外部函数 outer、内部函数 inner（以函数举例子，类定义同理）：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
#!/bin/php
<?php
function outer($msg) {
    function inner($msg) {
        echo $msg . PHP_EOL;
    }
    echo $msg . PHP_EOL;
    inner($msg);
}

// inner('hello, world!'); Call to undefined function
outer('hello, world!');
echo '--------------'.PHP_EOL;
inner('hello, world!');
?>
</script></code></pre>
<p>因此，这样的函数你只能调用一次，因为再调用一次，就会出现重复定义的错误。</p>
<p>默认情况下，内部函数是不能访问外部函数的局部变量的，除非使用 use 关键字（还得是匿名函数），例子如下：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
#!/bin/php
<?php
$a = 10; $b = 20;
$func = function() use($a, $b) {
    echo '$a = ' . $a . ', $b = ' . $b . PHP_EOL;
};
$func();
?>
</script></code></pre>
<p>类似函数的引用传参方式，use 语句也可以使用 <code>&amp;</code> 捕获外部变量的引用。</p>
<p>和大多数编程语言一样，函数定义可以在函数调用语句的后面，在 JS 中，这被称为函数提升，说的就是这个意思。<br>PHP 中的函数名是不区分大小写的，但是通常我们都不会使用与原名不同的函数名。</p>
<p><strong>PHP 不支持函数重载</strong>，也不可能取消定义或者重定义已声明的函数。和 C 语言差不多。PHP 函数接收参数也比 JS 更严格，JS 函数对于传入的参数数目非常随意，管它是多是少，都会保存到函数内部的 arguments 类数组对象中。但是在 PHP 中，只允许参数更多的情况（通常情况下，这是没有意义的），如果传入的实参数目比形参数目更少，会产生语法错误。</p>
<p><strong>PHP 函数支持设置默认参数</strong>，语法和大多数语言类似，默认参数通常只能使用常量表达式（基本类型、Array、NULL），并且，默认参数必须位于参数列表的后头，否则，默认参数的意义就不存在了。</p>
<p><strong>PHP 函数支持可变参数列表</strong>，语法和 JS 相似，也是在变量名前使用 <code>...</code>，可变参数实际上也是一个数组，如果需要将数组解开，也是使用 <code>...</code> 操作符（和 JS 一样），可变参数和默认参数一样，必须位于参数列表的尾部。</p>
<p><strong>PHP 函数支持递归调用</strong>，所谓的递归调用，也就是在函数体中调用自身所在的函数，但是要注意递归条件，递归深度应尽量小，更应该避免无限递归。</p>
<p><strong>PHP 函数参数允许类型声明</strong>，类型声明也称为类型提示，类型声明允许函数在调用时要求参数为特定类型。如果给出的值类型不对，那么将会产生一个错误： 在 PHP 5 中，这将是一个可恢复的致命错误，而在 PHP 7 中将会抛出一个 TypeError 异常。如果需要传入 null 值，需要为指定了类型的参数设置默认值 null，否则会报错。</p>
<p>可用的类型有（放在参数的前面，类似于 C/C++/Java）：<br><code>bool</code>布尔值、<code>int</code>整型、<code>float</code>浮点型、<code>string</code>字符串、<code>array</code>数组<br><code>ClassName/InterfaceName</code>类/接口的实例、<code>self</code>当前方法所属的类的实例</p>
<h2 id="PHP-面向对象"><a href="#PHP-面向对象" class="headerlink" title="PHP 面向对象"></a>PHP 面向对象</h2><p>自 PHP 5 起完全重写了对象模型以得到更佳性能和更多特性。这是自 PHP 4 以来的最大变化。PHP 5 具有完整的对象模型。</p>
<p>PHP 5 中的新特性包括<strong>访问控制</strong>，<strong>抽象类</strong>和 <strong>final 类与方法</strong>，附加的<strong>魔术方法</strong>，<strong>接口</strong>，对象复制和类型约束。</p>
<p>PHP 对待对象的方式与引用和句柄相同，即每个变量都持有对象的<strong>引用</strong>（需要使用 C/C++ 中的成员运算符 <code>-&gt;</code>），而不是整个对象的拷贝。</p>
<p>PHP 的面向对象模型大多都是借鉴 Java 的，如抽象类，接口，继承父类，实现接口。</p>
<p>一个简单的 Student 类：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
#!/bin/php
<?php
class Student {
    private $name, $age, $score;

    public function __construct($name = 'Unnamed', $age = 0, $score = 0.0) {
        $this->name = $name;
        $this->age = $age;
        $this->score = $score;
    }
    public function __destruct() {
        echo 'call Student::__destruct()'.PHP_EOL;
    }

    public function getName() {
        return $this->name;
    }
    public function getAge() {
        return $this->age;
    }
    public function getScore() {
        return $this->score;
    }

    public function setName($name) {
        $this->name = $name;
        return $this;
    }
    public function setAge($age) {
        $this->age = $age;
        return $this;
    }
    public function setScore($score) {
        $this->score = $score;
        return $this;
    }

    public function print() {
        echo "name: $this->name, age: $this->age, score: $this->score\n";
        return $this;
    }
}

$stu = new Student('ZhangSan', 15, 125);
$stu->print();
$stu->setName('Lisi')->setAge(16)->setScore(138)->print();
?>
</script></code></pre>
<p>类可以通过 <code>extends</code> 关键字来继承一个父类，PHP 只支持单继承，不支持多继承。</p>
<p>被继承的方法和属性可以通过用同样的名字重新声明被覆盖（重写 Override）。但是如果父类定义方法时使用了 final，则该方法不可被覆盖。可以通过 <code>parent::</code> 来访问被覆盖（名称遮蔽）的方法或属性。</p>
<p>当覆盖方法时，参数必须保持一致否则 PHP 将发出 E_STRICT 级别的错误信息。但构造函数例外，构造函数可在被覆盖时使用不同的参数（构造函数不存在重写一说）。</p>
<p>访问控制修饰符：<code>public</code>、<code>protected</code>、<code>private</code>，用于修饰类成员的访问权限：<br><code>public</code>：公开访问权限，可以在任何地方被访问；<br><code>protected</code>：受保护访问权限，仅限本类及其子类中访问；<br><code>private</code>：私有访问权限，仅限本类中访问。</p>
<p>类成员变量允许设置默认值，默认值只能是常量（标量、Array、NULL），即可以在编译期间求得值的表达式。为了兼容 PHP4，使用 var 声明的成员变量的访问性为 public，但是强烈建议不要再使用 var 了，要使用 public/protected/private。</p>
<p>实例属性 <code>$this-&gt;propName</code>，静态属性 <code>self::$propName</code>、<code>ClassName::$propName</code></p>
<p>在类体中可使用 <code>const</code> 定义一个类常量，类常量和全局常量一样，不需要 <code>$</code> 开头。</p>
<p>构造函数：<code>public function __construct($args...)</code>，进行对象初始化操作。如果子类中定义了构造函数，则不会隐式的调用父类的构造函数，因此，强烈建议在子类构造函数首行执行 <code>parent::__construct($args...)</code>。如果子类未定义构造函数，则会从父类中继承构造函数（就如同普通成员方法继承一样）。</p>
<p>析构函数：<code>public function __destruct()</code>，进行对象回收操作（和 C++ 类似）。和构造函数一样，如果子类中定义了析构函数，也不会隐式的调用父类的析构函数，因此，强烈建议在子类析构函数尾行执行 <code>parent::__destruct()</code>，如果子类中未定义析构函数，则自动继承父类的析构函数。析构函数即使在显式调用 exit 时也会被执行。</p>
<p><code>static</code> 静态成员：<code>public static $url = &quot;www.zfl9.com&quot;</code>，引用静态成员使用 <code>::</code> 域解析符，如访问本类中的静态成员 url，<code>self::$url</code>。</p>
<p><code>abstract class Foo { ... }</code>：抽象类<br><code>public abstract function func($args...);</code>：抽象方法<br>如果一个类有至少一个抽象方法，那么该类必须声明为抽象类；<br>但是没有抽象方法的类完全可以声明为抽象类，可以防止被实例化。<br>继承抽象类的子类必须实现所有抽象方法，否则，它也必须被声明为抽象类。</p>
<p><code>interface</code> 定义接口（抽象方法+类常量），接口的所有成员必须都是 public 的。<br><code>implements</code> 实现接口（一个类可以实现多个接口，逗号隔开），类与接口的关系。<br><code>extends</code> 接口间的继承（一个接口可以继承多个接口，逗号隔开），接口间的关系。</p>
<p>匿名类（PHP7），利用匿名类，可以创建一次性的简单对象：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
#!/bin/php
<?php
// 一个简单的 Util 类
class Util {
    private $logger;
    public function getLogger() {
        return $this->logger;
    }
    public function setLogger($logger) {
        $this->logger = $logger;
        return $this;
    }
}
$util = new Util();

// PHP 7 之前
class Logger {
    public function log($msg) {
        echo $msg;
    }
}
$util -> setLogger(new Logger());

// PHP 7 之后
$util -> setLogger(new class() {
    public function log($msg) {
        echo $msg;
    }
});
?>
</script></code></pre>
<p>我们可以传递参数给匿名类的构造器，也可以扩展另一个类，实现一个或多个接口：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
<?php
interface IFA {
    public function funcA();
}
interface IFB {
    public function funcB();
}

class Super {
    public function hello() {
        echo 'hello, world!'.PHP_EOL;
    }
}

$obj = new class(250) extends Super implements IFA, IFB {
    private $id;
    public function __construct($id = 0) {
        $this->id = $id;
    }
    public function funcA() {
        echo '匿名类实现接口 A'.PHP_EOL;
    }
    public function funcB() {
        echo '匿名类实现接口 B'.PHP_EOL;
    }
    public function show() {
        echo "ID = $this->id\n";
    }
};

$obj->funcA();
$obj->funcB();
$obj->hello();
$obj->show();
?>
</script></code></pre>
<p><strong>遍历对象的属性</strong>：与遍历 Array 一样，使用 <code>foreach</code> 语句，如：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
<?php
$obj = new class() {
    public $var1 = 'public-var1';
    public $var2 = 'public-var2';
    public $var3 = 'public-var3';
    protected $var4 = 'protected-var4';
    private $var5 = 'private-var5';

    public function func() {
        foreach ($this as $name=>$value) {
            echo "$name = $value\n";
        }
    }
};

foreach ($obj as $name=>$value) {
    echo "$name = $value\n";
}

echo '------------------'.PHP_EOL;

$obj->func();
?>
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ ./main.php
var1 = public-var1
var2 = public-var2
var3 = public-var3
------------------
var1 = public-var1
var2 = public-var2
var3 = public-var3
var4 = protected-var4
var5 = private-var5
</script></code></pre>
<p><strong>final 最终类/方法</strong>：如果在 class 前加上 <code>final</code> 修饰符，则该类将不能被继承；如果父类的方法加上了 <code>final</code> 修饰符，则子类不能够重写父类的该 final 方法。</p>
<p><strong>再谈 PHP 值传递/引用传递</strong><br>前面我们说了，PHP 中有两种变量传递方式：<strong>值传递</strong>（默认）、<strong>引用传递</strong>（<code>&amp;</code>符）。</p>
<p>PHP 中主要的数据类型有：布尔、整型、浮点、字符串、数组、对象。除对象外，其它类型的变量都是直接保存对应的值，而对象则是保存对应对象的指针（地址）。这其实和 Java 很相似（除了 Java 的数组是对象外）。</p>
<p>首先，我们要明确一点：<strong>PHP 中的默认传参方式是 <span style="color: gray">值传递</span></strong>，包括数组、对象！（这个也和 Java 差不多），但是你要注意，对象变量默认保存的是该对象的地址（指针），因此，很多时候，你会觉得将对象传递给函数就是引用传递，因为我在函数内部能够修改对象的属性，并且外部可以看得见修改的结果。其实不然，这个问题，在 Java 中也有很多人被迷惑，说到底，还是没有理解到本质。</p>
<p>整型、字符串、数组（值传递）：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
#!/bin/php
<?php
$var = 10;
echo "整型（值传递，修改前）：".$var.PHP_EOL;
(function ($var) {
    $var = 100;
}) ($var);
echo "整型（值传递，修改后）：".$var.PHP_EOL;

$str = "baidu";
echo "字符串（值传递，修改前）：".$str.PHP_EOL;
(function ($str) {
    $str[0] = 'g';
}) ($str);
echo "字符串（值传递，修改后）：".$str.PHP_EOL;

$arr = [1, 2, 3];
echo "数组（值传递，修改前）："; print_r($arr);
(function ($arr) {
    $arr[0] = 0;
}) ($arr);
echo "数组（值传递，修改后）："; print_r($arr);
?>
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ ./main.php
整型（值传递，修改前）：10
整型（值传递，修改后）：10
字符串（值传递，修改前）：baidu
字符串（值传递，修改后）：baidu
数组（值传递，修改前）：Array
(
    [0] => 1
    [1] => 2
    [2] => 3
)
数组（值传递，修改后）：Array
(
    [0] => 1
    [1] => 2
    [2] => 3
)
</script></code></pre>
<p>整型、字符串、数组（引用传递）：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
#!/bin/php
<?php
$var = 10;
echo "整型（值传递，修改前）：".$var.PHP_EOL;
(function (&$var) {
    $var = 100;
}) ($var);
echo "整型（值传递，修改后）：".$var.PHP_EOL;

$str = "baidu";
echo "字符串（值传递，修改前）：".$str.PHP_EOL;
(function (&$str) {
    $str[0] = 'g';
}) ($str);
echo "字符串（值传递，修改后）：".$str.PHP_EOL;

$arr = [1, 2, 3];
echo "数组（值传递，修改前）："; print_r($arr);
(function (&$arr) {
    $arr[0] = 0;
}) ($arr);
echo "数组（值传递，修改后）："; print_r($arr);
?>
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ ./main.php
整型（值传递，修改前）：10
整型（值传递，修改后）：100
字符串（值传递，修改前）：baidu
字符串（值传递，修改后）：gaidu
数组（值传递，修改前）：Array
(
    [0] => 1
    [1] => 2
    [2] => 3
)
数组（值传递，修改后）：Array
(
    [0] => 0
    [1] => 2
    [2] => 3
)
</script></code></pre>
<p>对象（值传递）：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
#!/bin/php
<?php
$obj = new stdClass();
$obj->prop = 10;
echo "对象（值传递，修改前）："; print_r($obj);
(function ($obj) {
    $obj->prop = 20;
}) ($obj);
echo "对象（值传递，修改后）："; print_r($obj);
?>
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ ./main.php
对象（值传递，修改前）：stdClass Object
(
    [prop] => 10
)
对象（值传递，修改后）：stdClass Object
(
    [prop] => 20
)
</script></code></pre>
<p>这不是能修改吗，即证明对象是引用传递的。如果你这样认为，那么你就大错特错了！这实际上还是值传递，只不过此时传递的“值”有点特殊，它传递的是一个地址，因此，你可以通过这个地址修改对应对象的属性值。但是，你却不能修改此对象的指向：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
#!/bin/php
<?php
$obj = new stdClass();
$obj->prop = 10;
echo "对象（值传递，修改前）："; print_r($obj);
(function ($obj) {
    $obj->prop = 20;
    $obj = null;
}) ($obj);
echo "对象（值传递，修改后）："; print_r($obj);
?>
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ ./main.php
对象（值传递，修改前）：stdClass Object
(
    [prop] => 10
)
对象（值传递，修改后）：stdClass Object
(
    [prop] => 20
)
</script></code></pre>
<p>你看，按道理来说，如果真的是引用传递的话，那么是可以修改变量本身的值的呀。</p>
<p>对象（引用传递）：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
#!/bin/php
<?php
$obj = new stdClass();
$obj->prop = 10;
echo "对象（引用传递，修改前）："; print_r($obj);
(function (&$obj) {
    $obj->prop = 20;
}) ($obj);
echo "对象（引用传递，修改后）："; print_r($obj);
?>
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ ./main.php
对象（引用传递，修改前）：stdClass Object
(
    [prop] => 10
)
对象（引用传递，修改后）：stdClass Object
(
    [prop] => 20
)
</script></code></pre>
<p>再来验证一下，修改变量本身的值，看看能否成功，值传递情况下是不能修改的：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
#!/bin/php
<?php
$obj = new stdClass();
$obj->prop = 10;
echo "对象（引用传递，修改前）："; print_r($obj);
(function (&$obj) {
    $obj->prop = 20;
    $obj = null;
}) ($obj);
echo "对象（引用传递，修改后）："; print_r($obj);
?>
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain">
$ ./main.php
对象（引用传递，修改前）：stdClass Object
(
    [prop] => 10
)
对象（引用传递，修改后）：
</script></code></pre>
<h2 id="PHP-异常处理"><a href="#PHP-异常处理" class="headerlink" title="PHP 异常处理"></a>PHP 异常处理</h2><p>PHP 的异常处理和 Java、JavaScript 类似，与异常处理相关的关键字：<br><code>throw</code>：抛出一个 Exception/Error 对象<br><code>try</code>：检测可能出现异常的语句块<br><code>catch</code>：捕获并处理对应的异常的语句（可以有多个）<br><code>finally</code>：无论是否发生异常都会执行的语句</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
try {
    // 可能发生异常的语句
} catch (Exception $e) {
    // 处理异常的语句
} finally {
    // 资源回收语句
}
</script></code></pre>
<p>PHP 异常的继承体系：顶层接口 Throwable，Throwable 有两个子类：Exception 异常、Error 错误。如果需要创建自定义异常类，只能继承 Exception、Error 类，不能直接实现 Throwable 接口。</p>
<h2 id="PHP-表单处理"><a href="#PHP-表单处理" class="headerlink" title="PHP 表单处理"></a>PHP 表单处理</h2><p><strong><code>$_SERVER</code></strong>：由 Web 服务器创建的数组，包含了诸如<strong>头信息</strong>(header)、<strong>路径</strong>(path)、以及<strong>脚本位置</strong>(script locations)等信息。不保证每个项目都可用，因服务器而异。</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>hello, world!</title>
    <style>
      table {
        border-collapse: collapse;
      }
      table, th, td {
        border: 1px solid black;
      }
      th, td {
        padding: 12px;
        text-align: center;
      }
    </style>
  </head>
  <body>
    <table>
      <tr>
        <th>desc</th>
        <th>name</th>
        <th>value</th>
      </tr>
<?php
echo <<<EOF
      <tr>
        <td>当前脚本的名称</td>
        <td>PHP_SELF</td>
        <td>$_SERVER[PHP_SELF]</td>
      </tr>
      <tr>
        <td>当前脚本的名称</td>
        <td>SCRIPT_NAME</td>
        <td>$_SERVER[SCRIPT_NAME]</td>
      </tr>
      <tr>
        <td>当前脚本的绝对路径</td>
        <td>SCRIPT_FILENAME</td>
        <td>$_SERVER[SCRIPT_FILENAME]</td>
      </tr>
      <tr>
        <td>CGI 规范的版本</td>
        <td>GATEWAY_INTERFACE</td>
        <td>$_SERVER[GATEWAY_INTERFACE]</td>
      </tr>
      <tr>
        <td>服务器的软件信息</td>
        <td>SERVER_SOFTWARE</td>
        <td>$_SERVER[SERVER_SOFTWARE]</td>
      </tr>
      <tr>
        <td>通信协议及其版本</td>
        <td>SERVER_PROTOCOL</td>
        <td>$_SERVER[SERVER_PROTOCOL]</td>
      </tr>
      <tr>
        <td>文档根目录</td>
        <td>DOCUMENT_ROOT</td>
        <td>$_SERVER[DOCUMENT_ROOT]</td>
      </tr>
      <tr>
        <td>服务器的虚拟主机名</td>
        <td>SERVER_NAME</td>
        <td>$_SERVER[SERVER_NAME]</td>
      </tr>
      <tr>
        <td>服务器的 IP</td>
        <td>SERVER_ADDR</td>
        <td>$_SERVER[SERVER_ADDR]</td>
      </tr>
      <tr>
        <td>服务器的 Port</td>
        <td>SERVER_PORT</td>
        <td>$_SERVER[SERVER_PORT]</td>
      </tr>
      <tr>
        <td>客户端的 IP</td>
        <td>REMOTE_ADDR</td>
        <td>$_SERVER[REMOTE_ADDR]</td>
      </tr>
      <tr>
        <td>客户端的 Port</td>
        <td>REMOTE_PORT</td>
        <td>$_SERVER[REMOTE_PORT]</td>
      </tr>
      <tr>
        <td>请求的 HTTP 方法</td>
        <td>REQUEST_METHOD</td>
        <td>$_SERVER[REQUEST_METHOD]</td>
      </tr>
      <tr>
        <td>请求的 URI</td>
        <td>REQUEST_URI</td>
        <td>$_SERVER[REQUEST_URI]</td>
      </tr>
      <tr>
        <td>查询字符串</td>
        <td>QUERY_STRING</td>
        <td>$_SERVER[QUERY_STRING]</td>
      </tr>
      <tr>
        <td>请求开始的时间戳(秒)</td>
        <td>REQUEST_TIME</td>
        <td>$_SERVER[REQUEST_TIME]</td>
      </tr>
      <tr>
        <td>请求开始的时间戳(微秒)</td>
        <td>REQUEST_TIME_FLOAT</td>
        <td>$_SERVER[REQUEST_TIME_FLOAT]</td>
      </tr>
      <tr>
        <td>是否使用 HTTPS 连接</td>
        <td>HTTPS</td>
        <td>$_SERVER[HTTPS]</td>
      </tr>
      <tr>
        <td>请求头部字段 - ACCEPT</td>
        <td>HTTP_ACCEPT</td>
        <td>$_SERVER[HTTP_ACCEPT]</td>
      </tr>
      <tr>
        <td>请求头部字段 - USER_AGENT</td>
        <td>HTTP_USER_AGENT</td>
        <td>$_SERVER[HTTP_USER_AGENT]</td>
      </tr>
      <tr>
        <td>请求头部字段 - XXX</td>
        <td>HTTP_XXX</td>
        <td>$_SERVER[HTTP_XXX]</td>
      </tr>
      <tr>
        <td>请求头部字段 - XXX-YYY</td>
        <td>HTTP_XXX_YYY</td>
        <td>$_SERVER[HTTP_XXX_YYY]</td>
      </tr>

EOF;
?>
    </table>
  </body>
</html>
</script></code></pre>
<p><img src="/images/php-server.png" alt="PHP $_SERVER"></p>
<p><strong><code>$_GET</code></strong>：通过 URL 参数传递给当前脚本的变量的数组。其中 name、value 都是未经 url-encoded 编码的字符，但是，如果需要将 value 作为 HTML 内容，还需使用 <code>htmlspecialchars()</code> 方法转义特殊 HTML 字符实体，<code>htmlspecialchars_decode()</code> 则相反，将 HTML 字符实体转换为正常字符。</p>
<p><strong><code>$_POST</code></strong>：当 HTTP POST 请求的 Content-Type 是 <code>application/x-www-form-urlencoded</code>（表单提交，URL查询参数）或 <code>multipart/form-data</code>（文件上传，二进制数据）时，会将变量以关联数组形式传入当前脚本。</p>
<p><strong><code>$_COOKIE</code></strong>：通过 HTTP Cookies 方式传递给当前脚本的变量的数组。使用 <code>setcookie()</code>（必须在任何输出之前调用）方法发送 COOKIE 给浏览器，使用 <code>$_COOKIE</code> 变量读取接收到的 COOKIE 信息。<code>setcookie()</code> 函数的原型：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
bool setcookie(string $name, // 名
               [string $value = ""], // 值
               [int $expire = 0], // 过期时间，Unix时间戳（单位秒），
                                  // time() 获取当前 Unix 时间戳，
                                  // 如果为 0，则会话结束时过期
               [string $path = ""], // 作用的服务器路径，默认为当前目录
                                    // 如设置成 '/' 则对整个域有效
                                    // 如设置成 '/foo/' 则对 /foo/ 目录
                                    // 及其子目录有效
               [string $domain = ""], // 作用的服务器域名，默认当前域名
                                      // 若要对当前域及其所有子域生效，
                                      // 只需设置为二级顶级域名，zfl.com
               [bool $secure = false], // 设置该COOKIE是否仅通过 HTTPS
                                       // 传递给客户端，默认为 false
               [bool $httponly = false], // 设置成 TRUE，Cookie 仅可通
                                         // 过 HTTP 协议访问。 这意思就
                                         // 是 Cookie 无法通过类似 JS
                                         // 这样的脚本语言访问。 要有效
                                         // 减少 XSS 攻击时的身份窃取
                                         // 行为，可建议用此设置（虽然
                                         // 不是所有浏览器都支持），不过
                                         // 这个说法经常有争议。
)
</script></code></pre>
<p><strong><code>$_REQUEST</code></strong>：默认情况下，包含了 <code>$_GET</code>、<code>$_POST</code>、<code>$_COOKIE</code> 的数组。</p>
<h2 id="PHP-文件包含"><a href="#PHP-文件包含" class="headerlink" title="PHP 文件包含"></a>PHP 文件包含</h2><p><code>include</code>：包含其它 PHP 脚本，如果不存在则产生警告信息，脚本会继续执行<br><code>require</code>：包含其它 PHP 脚本，如果不存在则产生致命错误，脚本将终止执行</p>
<p>include 和 require 都不是函数，它们都是语言结构，因此不需要括号，如：<br><code>include &#39;part-1.php&#39;;</code>、<code>require &#39;core.php&#39;;</code>、<code>require &#39;framework.php&#39;;</code></p>
<h2 id="PHP-上传文件"><a href="#PHP-上传文件" class="headerlink" title="PHP 上传文件"></a>PHP 上传文件</h2><p>通过 HTTP 上传文件的主要方式是 POST 请求。因此，需要配置 nginx、php.ini：<br><strong>nginx.conf</strong>：<br><code>client_max_body_size 128m;</code> 请求正文的最大大小（上传大文件时特别注意）<br><strong>php.ini</strong>：<br><code>file_uploads = On</code>：启用文件上传功能，默认启用<br><code>upload_tmp_dir = /tmp</code>：上传文件的临时存储目录，默认为系统临时目录<br><code>upload_max_filesize = 120M</code>：允许上传的最大文件大小，适当小于 <code>post_max_size</code><br><code>post_max_size = 128M</code>：允许发送的最大 POST 请求体的大小，应等于 nginx 配置值<br><code>max_execution_time = 300</code>：单个 PHP 脚本允许的最长执行时间（单位：秒）<br><code>max_input_time = 300</code>：单个 PHP 脚本用于接收输入的最长时间（单位：秒）<br><code>memory_limit = 128M</code>：单个 PHP 脚本允许占用的内存大小，适当大于 <code>post_max_size</code></p>
<p>使用 PHP 接收上传的文件（HTML 表单上传），主要涉及一个变量、两个函数：<br><code>$_FILES</code>：保存已上传文件的信息的多维数组<br><code>is_uploaded_file($filePath)</code>：判断文件是否为 POST 方式上传的<br><code>move_uploaded_file($srcFile, $dstFile)</code>：移动（覆盖）通过 POST 方式上传的文件</p>
<p>单文件，<code>&lt;input type=&quot;file&quot; name=&quot;profile&quot;&gt;</code><br><code>$_FILES[&#39;profile&#39;][&#39;name&#39;]</code>：文件的名称<br><code>$_FILES[&#39;profile&#39;][&#39;type&#39;]</code>：文件的类型（MIME）<br><code>$_FILES[&#39;profile&#39;][&#39;size&#39;]</code>：文件的大小（字节）<br><code>$_FILES[&#39;profile&#39;][&#39;error&#39;]</code>：错误代码（0 表示无错误）<br><code>$_FILES[&#39;profile&#39;][&#39;tmp_name&#39;]</code>：保存的临时文件名（路径）</p>
<p>多文件，<code>&lt;input type=&quot;file&quot; name=&quot;files[]&quot;&gt;</code>（允许多个此标签，HTML4）<br>多文件，<code>&lt;input type=&quot;file&quot; name=&quot;files[]&quot; multiple&gt;</code>（HTML5，CTRL 多选）<br><code>$_FILES[&#39;files&#39;][&#39;name&#39;][index]</code>：第 n 个文件的名称（index 从 0 开始，下同）<br><code>$_FILES[&#39;files&#39;][&#39;type&#39;][index]</code>：第 n 个文件的类型<br><code>$_FILES[&#39;files&#39;][&#39;size&#39;][index]</code>：第 n 个文件的大小<br><code>$_FILES[&#39;files&#39;][&#39;error&#39;][index]</code>：第 n 个文件的错误代码<br><code>$_FILES[&#39;files&#39;][&#39;tmp_name&#39;][index]</code>：第 n 个文件的临时位置</p>
<p>完整的例子：<br><code>upload.html</code></p>
<pre><code class="language-php line-numbers"><script type="text/plain">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>文件上传 - 表单</title>
    <style>
      #single-file-upload {
        float: left;
        border: 1px solid green;
        margin: 30px;
        padding: 20px;
      }
      #multi-file-upload-html4 {
        float: left;
        border: 1px solid blue;
        margin: 30px;
        padding: 20px;
      }
      #multi-file-upload-html5 {
        float: left;
        border: 1px solid gray;
        margin: 30px;
        padding: 20px;
      }
      input[type="submit"] {
        margin-top: 8px;
      }
    </style>
  </head>
  <body>
    <form id="single-file-upload" action="upload.php?type=single" method="post" enctype="multipart/form-data">
      <input type="file" name="file"><br>
      <input type="submit" value="点击上传（单文件）">
    </form>
    <form id="multi-file-upload-html4" action="upload.php?type=multi" method="post" enctype="multipart/form-data">
      <input type="file" name="file[]"><br>
      <input type="file" name="file[]"><br>
      <input type="file" name="file[]"><br>
      <input type="submit" value="点击上传（多文件 HTML4）">
    </form>
    <form id="multi-file-upload-html5" action="upload.php?type=multi" method="post" enctype="multipart/form-data">
      <input type="file" name="file[]" multiple><br>
      <input type="submit" value="点击上传（多文件 HTML5）">
    </form>
  </body>
</html>
</script></code></pre>
<p><code>upload.php</code></p>
<pre><code class="language-php line-numbers"><script type="text/plain">
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>文件上传 - PHP</title>
  </head>
  <body>
<?php
if (strcmp($_GET['type'], 'single') === 0) {
    $tmpPath = $_FILES['file']['tmp_name'];
    $dstPath = '/usr/share/nginx/html/upload/'.$_FILES['file']['name'];
    if (move_uploaded_file($tmpPath, $dstPath))
        echo "<strong style='color: green'>文件上传成功 \"{$_FILES['file']['name']}\"</strong>";
    else
        echo "<strong style='color: red'>文件上传失败 \"{$_FILES['file']['name']}\"</strong>";
    echo "<pre>";
    echo "文件上传的调试信息：\n";
    print_r($_FILES);
    echo "</pre>";
} elseif (strcmp($_GET['type'], 'multi') === 0) {
    for ($i = 0, $len = count($_FILES['file']['name']); $i < $len; $i++) {
        $tmpPath = $_FILES['file']['tmp_name'][$i];
        $dstPath = '/usr/share/nginx/html/upload/'.$_FILES['file']['name'][$i];
        if (move_uploaded_file($tmpPath, $dstPath))
            echo "<strong style='color: green'>文件上传成功 \"{$_FILES['file']['name'][$i]}\"</strong><br>";
        else
            echo "<strong style='color: red'>文件上传失败 \"{$_FILES['file']['name'][$i]}\"</strong><br>";
    }
    echo "<pre>";
    echo "文件上传的调试信息：\n";
    print_r($_FILES);
    echo "</pre>";
} else {
    echo "<strong style='color: red'>请求参数 <code>type</code> 不正确！</strong>";
}
?>
  </body>
</html>
</script></code></pre>
<h2 id="PHP-Session"><a href="#PHP-Session" class="headerlink" title="PHP Session"></a>PHP Session</h2><p><strong>理解会话控制的概念</strong></p>
<p>理解一个概念就需要理解它的背景及产生的原因，这里引入 WEB 环境及 HTTP 协议。会话控制产生的背景：</p>
<p>阅读过 HTTP 协议相关资料的同学都会知道 HTTP 协议是 WEB 服务器与客户端(浏览器)相互通信的协议，它是一种<strong>无状态协议</strong>，所谓无状态，指的是不会维护 http 请求数据，http 请求是独立的，不持久的。也就是说 HTTP 协议没有一个内建的机制来维护两个事务之间的状态或者说是关系吧。当一个用户在请求一个页面后再去请求另外一个页面时，HTTP 将无法告诉我们这两个请求是否来自同一个用户。</p>
<p>由此我们就会觉得很奇怪了，平时我们在论坛逛帖子或电商网站购物时，只要我们在这个站点内，不论我们怎么跳转，从一个页面跑到另一个页面，网站总会记得我是谁，比如告诉你购买了哪些东西。这是怎么做到的呢，估计大家猜到了，这就是运用了 HTTP 会话控制。在网站中跟踪一个变量，通过对变量的跟踪，使多个请求事物之间建立联系，根据授权和用户身份显示不同的内容、不同页面。</p>
<p><strong>PHP Session 会话控制</strong>：</p>
<p>PHP 的 session 会话是通过唯一的会话 ID 来驱动的，会话 ID 是一个加密的随机数字，由 PHP 生成，在会话的生命周期中都会保存在客户端。我们知道客户端（也就是浏览器）保存数据的地方只有 Cookie，所以 PHP 的会话 ID 一般保存在用户机器的 cookie 中。了解 cookie 后我们知道，浏览器是可以禁用 cookie 的，这样会话就会失效。所以 PHP 会话控制还有一种模式，就是在 URL 中传递会话 ID。如果在浏览网站时我们稍加留心的话，有些 URL 中有一串看起来像随机数字的字符串，那么其实很有可能就是 URL 形式的会话控制。</p>
<p>讲到这里，有些人可能会有疑问了，客户端只是保存一个会话 ID，那么会话控制中保存的会话变量比如你购物时买的物品列表等，它们是存放在哪个地方的呢？很显然，会话变量是在服务器端使用的，那么这些会话变量必定存放在服务器端。默认情况下，会话变量保存在服务器的普通文件中（也可以自己配置使用数据库来保存），会话 ID 的作用就像是一把钥匙，在服务器端保存会话的文件中找到该会话 ID 对应的会话变量，比如购买物品的列表。</p>
<p>那么会话控制的整个过程可能就像这个样子，用户登录或者第一次浏览某个站点的页面时，该站点会生成一个 PHP 的会话 ID 并通过 cookie 发送到客户端（浏览器）。当用户点击该站点的另一个页面时，浏览器开始连接这个 URL。在连接之前，浏览器会先搜索本地保存的 cookie，如果在 cookie 中有任何与正在连接的 URL 相关的 cookie，就将它提交到服务器。而刚好在登陆或第一次连接时，已经产生了一个与该网站 URL 相关的 cookie（保存的会话 ID），所以当用户再次连接这个站点时，站点就可以通过这个会话 ID 识别出用户，从服务器的会话文件中取出与这个会话 ID 相关的会话变量，从而保持事务之间的连续。</p>
<p>接下来我们了解下两个重要的概念：cookie 和 session。</p>
<p><strong>关于 cookie 的维护与生命周期</strong></p>
<p>Cookie 是在服务器端被创建并写回到浏览器的，浏览器读取到响应头中的 <code>Set-Cookie</code> 字段后，就会按照要求保存 Cookie 数据，Set-Cookie 头如下：<br><code>Set-Cookie: &lt;name&gt;=&lt;value&gt;; expires=&lt;date&gt;; max-age=&lt;date&gt;; domain=&lt;domain&gt;; path=&lt;path&gt;; httponly; secure</code><br>除<code>&lt;name&gt;=&lt;value&gt;</code>字段外，其它的均为可选的。Set-Cookie 头部可以有多个，含义：</p>
<ul>
<li><code>&lt;name&gt;</code>：除 <strong>控制字符</strong>、<strong>空白符</strong>、<code>(</code> <code>)</code> <code>&lt;</code> <code>&gt;</code> <code>@</code> <code>,</code> <code>;</code> <code>:</code> <code>\</code> <code>&quot;</code> <code>/</code> <code>[</code> <code>]</code> <code>?</code> <code>=</code> <code>{</code> <code>}</code> 外的 ASCII 字符。</li>
<li><code>&lt;value&gt;</code>：除 <strong>控制字符</strong>、<strong>空白符</strong>、<strong>双引号</strong>、<strong>逗号</strong>、<strong>分号</strong> 以及 <strong>反斜线</strong> 外的任意 ASCII 字符。许多应用会对 cookie 值按照 URL 编码规则进行编码，但是按照 RFC 规范，这不是必须的。不过满足规范中对于 <code>&lt;value&gt;</code> 所允许使用的字符的要求是有用的。</li>
<li><code>expires</code>：<strong>到期时间</strong>，如果省略此字段，则表示这是一个 <strong>会话期 Cookie</strong>，客户端关闭时会话期 Cookie 被移除。如果此时间已过去，则表示，服务端希望客户端移除此 Cookie。</li>
<li><code>max-age</code>：<strong>生存时间</strong>（秒数，优先级高），一些老浏览器不支持该字段（IE6、IE7、IE8），对于其他浏览器，如果同时存在 <code>expires</code>、<code>max-age</code> 字段，则 max-age 优先级高。</li>
<li><code>domain</code>：<strong>作用域名</strong>，指定该 Cookie 作用于哪些域名，如果省略，默认为当前域名；如果指定一个具体域名，则表示作用于该域名及其子域名。</li>
<li><code>path</code>：<strong>作用路径</strong>，指定该 Cookie 作用于哪些路径，如果省略，默认为当前路径；如果指定一个具体路径，则表示作用于该路径及其子路径。</li>
<li><code>httponly</code>：只允许通过 HTTP 来访问 Cookie，即 <strong>不允许如 JS 脚本访问该 Cookie，以防跨站脚本攻击</strong>。</li>
<li><code>secure</code>：<strong>该 Cookie 只允许通过 HTTPS 方式发送到服务器</strong>，在 Chrome 52+、Firefox 52+ 后，不允许 http 站点设置此属性。</li>
</ul>
<p>当浏览器请求某个 URL 资源时，会检索本机存储的相关 Cookie 信息，如果有与此 URL 资源相关联的 Cookie，则使用 Cookie 请求头部发送，Cookie 头部如下：<br><code>Cookie: &lt;name1&gt;=&lt;value1&gt;[; &lt;name2&gt;=&lt;value2&gt;[; ...]]</code></p>
<p>在 PHP 中，发送 Cookie 使用函数 <code>setcookie()</code>（自动进行 URL 编码）、<code>setrawcookie()</code>（不进行 URL 编码）；读取 Cookie 使用全局变量 <code>$_COOKIE[name]</code> 来读取。</p>
<p><strong>关于session的维护与生命周期</strong></p>
<p>Session 是由服务器维持的一个服务端的存储空间，用户在连接服务器时，会由服务器创建生成一个唯一的 sessionID，用该 sessionID 为标识符来存取服务器端的 Session 存储空间，在会话期间，分配给客户端的唯一 sessionID，用来标识当前用户，与其他用户进行区分。通过 SessionID 接受每一次访问的请求，从而识别当前用户，跟踪和保持用户的具体资料，以及 session 变量，可在 session 中存储数字或文字资料。比如 session_name，这些信息都保存在服务器端。当然，session 也可以作为会话信息保存到数据库中，进行 session 持久化。这样可以跟踪用户的登陆次数、在线与否、在线时间等从而维护 HTTP 无状态事物之间的关系。session 的内容存储是键值对的列表，键是字符串类型，值可以是任意类型，如一个对象。</p>
<p>在 session 会话期间，session 会分别保存在客户端和服务器端两个文件，客户端可以是 cookie 方式保存 sessionID（默认的保存方式）或通过 url 字符串形式传递。服务器端一般以文本的形式保存在指定的 session 目录中。在服务器端我们可以通过 <code>session.use_cookies</code> 来控制客户端使用哪一种保存方式。如果定义为 cookie 保存方式，我们可以通过 <code>session.cookie_lifetime</code>（默认值 0，关闭浏览器就清除）来控制被保存在 client 上的 cookie 的有效期。而如果客户端用 cookie 方式保存的 sessionID，则使用“临时”的 cookie 保存（cookie 的名称为 PHPSESSID，可通过 php.ini <code>session.name</code> 进行更改)，用户提交页面时，会将这一 SessionID 提交到服务器端，来存取 session 数据。这一过程，是不用开发人员干预的。</p>
<p><strong>cookie、session 的区别</strong><br>Cookie：存储在<strong>客户端</strong>，内容是纯文本，浏览器会自动检索与请求 URL 相关的 Cookie，然后通过 Cookie 请求头部发送到服务器。<br>Session：存储在<strong>服务端</strong>，默认存储方式为文本文件，也可以配置为数据库存储；用于存储特定用户的状态信息，通过 SessionID 可检索到此 Session 文件。</p>
<p>这样看来，Cookie 和 Session 是完全不相干的两样东西。不过，有一个细节不知你有没有注意，Session 信息需要一个 SessionID 来检索，那么浏览器和服务器之间是如何传输和保存这个 SessionID 的呢？最常见以及方便的方式就是通过 Cookie 来传递，服务器上通过 setcookie() 来设置与 SessionID 相关的 Cookie，浏览器接收后，随之存储此 Cookie 信息，当再次访问此站点时，该 Cookie 会自动的被发送给服务器，从而在无状态的 HTTP 协议中保持这个 SessionID。因此，Session 出现的地方一般都会有 Cookie 的身影。</p>
<p>不过，这也不是绝对的，你要知道，浏览器时可以禁用 Cookie 的，那么这种情况下，SessionID 是如何传递的呢？答案是，启用备用方案：<strong>URL 传参</strong>，细心观察会发信息，一些电商网站的地址栏夹杂着一长串无规律的字符，其实这就是 SessionID 了。</p>
<p><strong>开始 Session 会话</strong><br>在 PHP 中，要使用 session 机制保存会话状态，第一步就是启动 session 会话。</p>
<ul>
<li>可以通过调用函数 <code>session_start()</code> 来手动开始一个会话。</li>
<li>如果配置项 <code>session.auto_start=1</code>，则请求开始时，会话会自动开始。</li>
</ul>
<p>注意，如果是手动开始一个会话，那么 <code>session_start()</code> 函数必须在脚本头部被调用，因为 PHP 要根据请求头部信息判断是否要发送 <code>Set-Cookie</code> 字段（如用户第一次访问时）。</p>
<p>配置项 <code>session.auto_start=1</code> 其实就是自动的在每个脚本头部添加 <code>session_start()</code> 函数调用语句。因此，我们主要分析 session_start() 函数的处理步骤：</p>
<ul>
<li>如果请求头部中未包含 SessionID 的 Cookie 信息，那么 PHP 会创建一个新的唯一 SessionID 并分配给当前会话；然后调用 setcookie()，向浏览器发送 SessionID 信息。如：<strong>用户第一次访问该站点</strong>。</li>
<li>如果请求头部中已包含 SessionID 的 Cookie 信息，那么 PHP 会使用该 SessionID 在磁盘中检索与之关联的 Session 文件（如果不存在则新建相关联的 Session 文件），然后读取该 Session 文件，恢复上一次的会话状态。如：<strong>用户第二次访问该站点</strong>。</li>
</ul>
<p><strong>使用 Session 会话</strong><br>会话开始后，我们可以通过 <code>$_SESSION</code> 全局数组来存取 session 会话信息，如下：</p>
<pre><code class="language-php line-numbers"><script type="text/plain">
<?php
session_start();

if (isset($_SESSION['cnt']))
    echo "你已访问本页面 ".++$_SESSION['cnt']." 次";
else {
    $_SESSION['cnt'] = 1;
    echo "你已访问本页面 1 次";
}
?>
</script></code></pre>
<p><strong>结束 Session 会话</strong><br>当 PHP 脚本运行结束后，PHP 会自动的读取 <code>$_SESSION</code> 数组，将其序列化，然后发送给会话保存管理器来进行保存（默认使用文件进行存储，可配置为数据库存储）。</p>
<p>当然，除了在脚本结束时自动保存会话外，还可以在脚本中显式的调用 <code>session_write_close()</code> 来提前结束会话，其实上面的自动保存会话也是隐式调用 <code>session_write_close()</code> 函数（此函数还有一个别名：<code>session_commit()</code>）。</p>
<p><strong>销毁 Session 会话</strong><br>如果需要删除 <code>$_SESSION</code> 数组的某一元素，请使用 <code>unset($_SESSION[name])</code><br>如果需要删除 <code>$_SESSION</code> 数组的全部元素，请使用 <code>session_unset()</code><br>如果需要销毁当前会话的全部数据（文件也被删除），请使用 <code>session_destroy()</code></p>
<p>使用 <code>session_destroy()</code> 销毁会话时，别忘了删除含有 SessionID 的 Cookie 信息：<br><code>setcookie(session_name(), &#39;&#39;, time()-3600)</code>，将过期时间设为过去，就可以删除。</p>
<p><strong>Session 相关函数</strong></p>
<ul>
<li><code>bool session_start([array $options = []])</code>：启动新会话，或重用现有会话</li>
<li><code>bool session_commit()</code>：<code>session_write_close()</code> 的别名，意为提交会话</li>
<li><code>bool session_write_close()</code>：手动结束此次会话，将会话数据写入文件</li>
<li><code>bool session_abort()</code>：丢弃此次的会话数据，恢复上一次的会话数据</li>
<li><code>void session_unset()</code>：删除 <code>$_SESSION</code> 数组的全部元素，相当于清空会话数据</li>
<li><code>bool session_destroy()</code>：销毁当前会话的所有数据，别忘了删除 Cookie</li>
<li><code>string session_name([string $name])</code>：获取/设置当前会话的 SessionName</li>
<li><code>string session_id([string $id])</code>：获取/设置当前会话的 SessionID</li>
<li><code>string session_save_path([string $path])</code>：读取/设置当前会话的保存路径</li>
</ul>
<p><strong>通过 URL 参数形式传递 SessionID</strong><br>如果浏览器禁用了 Cookie，那么我们只能启用备用方案：通过 URL 参数形式来传递 SessionID 了。默认情况下，PHP 只允许通过 Cookie 形式传递 SessionID，如果要启用 URL 传递形式，需配置以下项目：</p>
<ul>
<li><code>session.use_cookies = 1</code>：启用 Cookie 方式（首选）</li>
<li><code>session.use_only_cookies = 0</code>：关闭“仅使用 Cookie 方式”</li>
<li><code>session.use_trans_sid = 1</code>：启用 URL-param 方式（备用）</li>
</ul>
<p>该配置下，PHP 会首先尝试通过 Cookie 传递 SessionID，如果成功，则不考虑 URL-param 方式；如果失败，则使用 URL-param 方式传递 SessionID（无需开发者干涉，PHP 会自动在每个相对 url 中添加 url-param）。</p>
<h2 id="PHP-正则表达式"><a href="#PHP-正则表达式" class="headerlink" title="PHP 正则表达式"></a>PHP 正则表达式</h2><p>PCRE 是 PHP 的核心扩展，因此，在 PHP 脚本中，PCRE 正则总是可用的。<br>PCRE 是 Perl Compatible Regular Expressions（Perl 兼容正则表达式）的缩写。<br>PHP 的正则模式与 Perl、Java 的很相似，只有少数差异（详见 PHP 的官方文档）。</p>
<p>因为正则模式中很多反斜杠转义，因此，建议始终使用 <strong>单引号</strong> 来表示正则表达式。<br>但是单引号中表示反斜杠本身，也是要转义的（单个的不需要，连续的反斜杠需要）。<br>例如表示一个反斜杠：<code>&#39;/\/&#39;</code> 或 <code>&#39;/\\/&#39;</code>，表示两个反斜杠：<code>&#39;/\\\\/&#39;</code>（必须转义）</p>
<p><strong>PHP 正则模式简述</strong></p>
<blockquote>
<p>由于 PHP 正则与 Java、Perl 语法很接近，因此这里只提它们的不同之处。</p>
</blockquote>
<p><strong>分隔符</strong>：正则表达式需要使用分隔符包裹，分隔符可以是除 <strong>字母</strong>、<strong>数字</strong>、<strong>反斜杠</strong>、<strong>空白符</strong> 的任意 ASCII 可打印字符，常见的分割符有：<code>/</code>、<code>@</code>、<code>#</code>、<code>~</code>。如果模式中含有分隔符，则需要进行反斜杠转义。分隔符分为开始分隔符，结束分隔符，我们可以在结束分隔符后添加模式修饰符，如 <code>i</code> 表示忽略大小写。</p>
<p><strong>修饰符</strong>：<br><code>i</code>：忽略大小写<br><code>s</code>：单行模式<br><code>m</code>：多行模式<br><code>u</code>：UTF-8 模式（Unicode 支持）</p>
<p><strong>原始字符序列</strong>：<code>\Q</code> 开头，<code>\E</code> 结尾，它们之间的字符串将无特殊意义。</p>
<p><strong>转义序列</strong><br><code>\ddd</code>：八进制值为 <code>ddd</code>（建议始终带上前面的 0，如果可以的话）的字符<br><code>\xhh</code>：十六进制值为 <code>hh</code> 的字符，其实 <code>\ddd</code>、<code>\xhh</code> 只能表示单字节字符<br><code>\x{...}</code>：UTF-8 模式下可用，大括号中的是 UTF-8 码元（十六进制，一至四字节）</p>
<p><strong>零宽断言</strong>，位置匹配符：<br><code>\b</code>：单词边界<br><code>\B</code>：非单词边界<br><code>^</code>：输入序列的起始位置，多行模式下还匹配行结束符之后的位置<br><code>$</code>：输入序列的结束位置，多行模式下还匹配行结束符之前的位置<br><code>\A</code>：输入序列的起始位置<br><code>\G</code>：前一匹配处的结束位置<br><code>\z</code>：输入序列的结束位置<br><code>\Z</code>：输入序列的结束位置或者行结束符之前的位置</p>
<p><strong>贪婪量词</strong>、<strong>懒惰量词</strong>、<strong>占有量词</strong> 的语法与 Java 一样，其中，量词默认都是贪婪的。</p>
<p><strong>原子组</strong>：<code>(?&gt;pattern)</code><br><strong>非捕获组</strong>：<code>(?:pattern)</code></p>
<p><strong>匿名捕获组</strong>：<code>(pattern)</code><br><strong>命名捕获组</strong>：<code>(?&lt;name&gt;pattern)</code></p>
<p><strong>引用匿名捕获组</strong>：<code>\n</code><br><strong>引用命名捕获组</strong>：<code>\k&lt;name&gt;</code></p>
<p><strong>顺序肯定环视</strong>：<code>(?=pattern)</code><br><strong>顺序否定环视</strong>：<code>(?!pattern)</code><br><strong>逆序肯定环视</strong>：<code>(?&lt;=pattern)</code>（只支持定长模式）<br><strong>逆序否定环视</strong>：<code>(?&lt;!pattern)</code>（只支持定长模式）</p>
<p><strong>PCRE 函数</strong><br><strong><code>preg_match</code></strong>，搜索与给定正则的首次匹配<br><strong><code>int preg_match(string $regex, string $input[, array &amp;$result[, int $flags = 0[, int $offset = 0]]])</code></strong></p>
<ul>
<li><code>regex</code>：正则模式</li>
<li><code>input</code>：输入序列</li>
<li><code>result</code>：匹配结果，分别为 group0、groupN，以及命名捕获组</li>
<li><code>flags</code>：匹配标志，可能的值有：<ul>
<li><code>PREG_OFFSET_CAPTURE</code>，附加匹配结果相对于输入序列的偏移量<br>这将导致原先的 groupN 变为拥有两个元素的数组，后面的为偏移量</li>
</ul>
</li>
<li><code>offset</code>：从指定偏移位置开始匹配模式，默认是从字符串起始处匹配，单位：字节</li>
<li>返回值：模式匹配的次数，匹配成功返回 1，匹配失败返回 0，发生错误返回 false</li>
</ul>
<p><strong><code>preg_match_all</code></strong>，搜索与给定正则的所有匹配<br><strong><code>int preg_match_all(string $regex, string $input[, array &amp;$result[, int $flags = PREG_PATTERN_ORDER[, int $offset = 0]]])</code></strong></p>
<ul>
<li><code>regex</code>：正则模式</li>
<li><code>input</code>：输入序列</li>
<li><code>result</code>：匹配结果，具体的存放结构与 flags 相关</li>
<li><code>flags</code>：匹配标志，可能的值有（按位或 <code>|</code> 组合多个 flag，<br>但 <code>PREG_PATTERN_ORDER</code> 和 <code>PREG_SET_ORDER</code> 不可同时使用）：<ul>
<li><code>PREG_PATTERN_ORDER</code>：模式排序，二维数组，第一维为捕获组，第二维为第几次匹配，此为默认顺序。</li>
<li><code>PREG_SET_ORDER</code>：匹配排序，二维数组，第一维为第几次匹配，第二维为捕获组，个人比较喜欢这种排序。</li>
<li><code>PREG_OFFSET_CAPTURE</code>：是否附加偏移量，变成三维数组（意义同 <code>preg_match()</code>）</li>
</ul>
</li>
<li><code>offset</code>：从给定偏移位置开始匹配（意义同 <code>preg_match()</code>）</li>
<li>返回值：模式匹配的次数，如果发生错误，则返回 false。</li>
</ul>
<p><strong><code>preg_grep</code></strong>，返回与给定模式匹配的数组元素<br><strong><code>array preg_grep(string $regex, array $inputs[, int $flags = 0])</code></strong></p>
<ul>
<li><code>regex</code>：正则模式</li>
<li><code>inputs</code>：输入数据，字符串数组</li>
<li><code>flags</code>：过滤模式，如果 <code>PREG_GREP_INVERT</code>，则表示取反匹配</li>
<li>返回符合过滤条件的元素组成的新数组，索引与原数组一致</li>
</ul>
<p><strong><code>preg_replace</code></strong>，执行正则替换<br><strong><code>mixed preg_replace(mixed $regex, mixed $replace, mixed $input[, int $limit = -1[, int &amp;$count]])</code></strong></p>
<ul>
<li><code>regex</code>：模式字符串、模式字符串数组</li>
<li><code>replace</code>：替换字符串、替换字符串数组，使用 <code>$n</code>（n 为 0~99） 引用捕获组</li>
<li><code>input</code>：输入字符串、输入字符串数组</li>
<li><code>limit</code>：替换次数限制，-1 为无限制</li>
<li><code>count</code>：实际替换次数，注意是引用传参</li>
<li>如果 regex 为数组，replace 为字符串，则所有的 regex 都使用 replace 替换</li>
<li>如果 regex 为数组，replace 为数组，且长度一致，则 regex 与 replace 一一配对</li>
<li>如果 regex 为数组，replace 为数组，但长度更小，则剩余的 regex 使用空串替换</li>
<li>如果 input 为字符串，则将所有的 regex/replace 在 input 上应用一遍</li>
<li>如果 input 为数组，则将所有的 regex/replace 在 input 的每个元素上都应用一遍</li>
<li>可以利用 limit 参数来实现 <strong>替换一次</strong>（limit = 1）、<strong>全局替换</strong>（limit = -1）</li>
<li>如果 input 为数组，则返回一个数组，其它的均返回字符串，发生错误返回 NULL</li>
</ul>
<p><strong><code>preg_replace_callback</code></strong>，执行正则替换，执行回调<br><strong><code>mixed preg_replace_callback(mixed $regex, string function(array $matches), mixed $input[, int $limit = -1[, int &amp;$count]])</code></strong></p>
<ul>
<li><code>string function(array $matches)</code>：回调函数，返回要替换的字符串，返回值中的 <code>$n</code> 无效，其中 matches 为正则模式匹配的数组，分别为 groupN，除此之外，该函数与上一个函数的行为完全一致。</li>
</ul>
<p><strong><code>preg_split</code></strong>，执行正则分割<br><strong><code>array preg_split(string $regex, string $input[, int $limit = -1[, int $flags = 0]])</code></strong></p>
<ul>
<li><code>regex</code>：正则模式</li>
<li><code>input</code>：输入序列</li>
<li><code>limit</code>：次数限制，-1、0、null 均为不限制，最后的元素将包含剩余的子串</li>
<li><code>flags</code>：替换标志，可能的值有（用按位或 <code>|</code> 进行组合）：<ul>
<li><code>PREG_SPLIT_NO_EMPTY</code>：忽略分割结果为空串的部分</li>
<li><code>PREG_SPLIT_DELIM_CAPTURE</code>：返回分割模式中的子捕获组</li>
<li><code>PREG_SPLIT_OFFSET_CAPTURE</code>：返回分割模式中的子捕获组的偏移量</li>
</ul>
</li>
<li>返回由 regex 分割后的 input 子串数组，发生错误时返回 false</li>
</ul>
<p><strong><code>preg_quote</code></strong>，取消模式的特殊意义<br><strong><code>string preg_quote(string $input[, string $delimiter = null])</code></strong></p>
<ul>
<li><code>input</code>：输入字符串（含有特殊的元字符）</li>
<li><code>delimiter</code>：正则分隔符，默认为 null，如果指定，则模式中的分隔符将被转义</li>
<li>返回取消了特殊意义的正则模式</li>
</ul>
    </div>
    <div>
    </div>
    <div>
    </div>
    <div>
    </div>
    <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/php/" rel="tag"># php</a>
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/perl.html" rel="next" title="Perl 笔记">
                <i class="fa fa-chevron-left"></i> Perl 笔记
              </a>
          </div>
          <span class="post-nav-divider"></span>
          <div class="post-nav-prev post-nav-item">
              <a href="/mysql.html" rel="prev" title="MySQL 笔记">
                MySQL 笔记 <i class="fa fa-chevron-right"></i>
              </a>
          </div>
        </div>
    </footer>
  </article>
    <div class="post-spread">
    </div>
  </div>
          </div>
  <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer" target="_blank">comments powered by Disqus.</a>
        </noscript>
      </div>
  </div>
        </div>
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>
  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Otokaze">
          <p class="site-author-name" itemprop="name">Otokaze</p>
              <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">170</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
        </nav>
        <div class="links-of-author motion-element">
              <span class="links-of-author-item">
                <a href="https://github.com/zfl9" target="_blank" title="GitHub rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-github"></i>
                  GitHub
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="mailto:zfl9.com@gmail.com" target="_blank" title="Email rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-envelope"></i>
                  Email
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://gitlab.com/zfl9" target="_blank" title="GitLab rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-gitlab"></i>
                  GitLab
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://t.me/Otokaze" target="_blank" title="Telegram rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-telegram"></i>
                  Telegram
                </a>
              </span>
        </div>
      </section>
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-简介"><span class="nav-number">1.</span> <span class="nav-text">PHP 简介</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-安装"><span class="nav-number">2.</span> <span class="nav-text">PHP 安装</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-语法"><span class="nav-number">3.</span> <span class="nav-text">PHP 语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-输入"><span class="nav-number">4.</span> <span class="nav-text">PHP 输入</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-输出"><span class="nav-number">5.</span> <span class="nav-text">PHP 输出</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-变量"><span class="nav-number">6.</span> <span class="nav-text">PHP 变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-常量"><span class="nav-number">7.</span> <span class="nav-text">PHP 常量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-超全局变量"><span class="nav-number">8.</span> <span class="nav-text">PHP 超全局变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-魔术变量"><span class="nav-number">9.</span> <span class="nav-text">PHP 魔术变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-数据类型"><span class="nav-number">10.</span> <span class="nav-text">PHP 数据类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-运算符"><span class="nav-number">11.</span> <span class="nav-text">PHP 运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-流程控制"><span class="nav-number">12.</span> <span class="nav-text">PHP 流程控制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-函数"><span class="nav-number">13.</span> <span class="nav-text">PHP 函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-面向对象"><span class="nav-number">14.</span> <span class="nav-text">PHP 面向对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-异常处理"><span class="nav-number">15.</span> <span class="nav-text">PHP 异常处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-表单处理"><span class="nav-number">16.</span> <span class="nav-text">PHP 表单处理</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-文件包含"><span class="nav-number">17.</span> <span class="nav-text">PHP 文件包含</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-上传文件"><span class="nav-number">18.</span> <span class="nav-text">PHP 上传文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-Session"><span class="nav-number">19.</span> <span class="nav-text">PHP Session</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#PHP-正则表达式"><span class="nav-number">20.</span> <span class="nav-text">PHP 正则表达式</span></a></li></ol></div>
          </div>
        </section>
      <!--/noindex-->
    </div>
  </aside>
      </div>
    </main>
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Otokaze</span>
</div>
<script src="/js/clipboard.min.js"></script>
<script src="/js/prism/prism.js" async></script>
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
  </div>
<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>
      <script id="dsq-count-scr" src="https://otokaze.disqus.com/count.js" async></script>
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://www.zfl9.com/php.html';
          this.page.identifier = 'php.html';
          this.page.title = 'PHP 笔记';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://otokaze.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("3hhdw6gOg9wavsharVwVjqI3-gzGzoHsz", "O5WfDffqFsgmAVPwNY9of3QU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");
      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });
      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';
          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);
            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);
      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }
    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</body>
</html>
