<!doctype html>
<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">
<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">
<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">
  <meta name="keywords" content="C++ 运算符重载 operator reload overload">
  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1">
<meta name="description" content="C++ 运算符重载，函数重载（Function Overloading）可以让一个函数名有多种功能，在不同情况下进行不同的操作；运算符重载（Operator Overloading）也是一个道理，同一个运算符可以有不同的功能；">
<meta name="keywords" content="cpp">
<meta property="og:type" content="article">
<meta property="og:title" content="C++ 运算符重载">
<meta property="og:url" content="https://www.zfl9.com/cpp-operator-overload.html">
<meta property="og:site_name" content="Otokaze's Blog">
<meta property="og:description" content="C++ 运算符重载，函数重载（Function Overloading）可以让一个函数名有多种功能，在不同情况下进行不同的操作；运算符重载（Operator Overloading）也是一个道理，同一个运算符可以有不同的功能；">
<meta property="og:updated_time" content="2019-02-18T12:42:42.281Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="C++ 运算符重载">
<meta name="twitter:description" content="C++ 运算符重载，函数重载（Function Overloading）可以让一个函数名有多种功能，在不同情况下进行不同的操作；运算符重载（Operator Overloading）也是一个道理，同一个运算符可以有不同的功能；">
<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
  <link rel="canonical" href="https://www.zfl9.com/cpp-operator-overload.html">
<link href="/js/prism/prism.css" rel="stylesheet">
  <title>C++ 运算符重载 | Otokaze's Blog</title>
</head>
<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-97872912-1', 'auto');
  ga('send', 'pageview');
</script>
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3d58f51dbb2496a0e6d17b85065a5ae5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Otokaze's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">拼一年春夏秋冬，搏一生无怨无悔</h1>
  </div>
  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>
<nav class="site-nav">
    <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            首页
          </a>
        </li>
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            分类
          </a>
        </li>
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            标签
          </a>
        </li>
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            归档
          </a>
        </li>
    </ul>
</nav>
 </div>
    </header>
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
  <div id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.zfl9.com/cpp-operator-overload.html">
    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Otokaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>
    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Otokaze's Blog">
    </span>
      <header class="post-header">
          <h2 class="post-title" itemprop="name headline">
                C++ 运算符重载
          </h2>
        <div class="post-meta">
          <span class="post-time">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
                <span class="post-meta-item-text">发表于</span>
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T15:39:00+08:00">
                2017-08-26
              </time>
          </span>
            <span class="post-category">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
                <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/cpp/" itemprop="url" rel="index">
                    <span itemprop="name">cpp</span>
                  </a>
                </span>
            </span>
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/cpp-operator-overload.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="cpp-operator-overload.html" itemprop="commentCount"></span>
                </a>
              </span>
             <span id="/cpp-operator-overload.html" class="leancloud_visitors" data-flag-title="C++ 运算符重载">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
                 <span class="post-meta-item-text">阅读次数 </span>
                 <span class="leancloud-visitors-count"></span>
             </span>
        </div>
      </header>
    <div class="post-body" itemprop="articleBody">
        <p>C++ 运算符重载，<code>函数重载（Function Overloading）</code>可以让一个函数名有多种功能，在不同情况下进行不同的操作；<code>运算符重载（Operator Overloading）</code>也是一个道理，同一个运算符可以有不同的功能；</p>
<a id="more"></a>
<h2 id="运算符重载的概念"><a href="#运算符重载的概念" class="headerlink" title="运算符重载的概念"></a>运算符重载的概念</h2><p>实际上，我们已经在不知不觉中使用了运算符重载；<br>例如，<code>+号</code>可以对不同类型（int、float 等）的数据进行加法操作；<code>&lt;&lt;</code>既是位移运算符，又可以配合 cout 向控制台输出数据；C++ 本身已经对这些运算符进行了重载；</p>
<p>C++ 也允许程序员自己重载运算符，这给我们带来了很大的便利；</p>
<p><strong>以成员函数形式重载运算符</strong><br>下面的代码定义了一个复数类，通过运算符重载，可以用<code>+号</code>实现复数的加法运算：</p>
<pre><code class="language-cpp line-numbers"><script type="text/plain">#include <cstdio>

using namespace std;

class complex {
public:
    complex(double real = 0.0, double imag = 0.0) : m_real(real), m_imag(imag) {}
    void print() const;
    complex operator+(const complex &A) const;
private:
    double m_real;
    double m_imag;
};

void complex::print() const {
    printf("%g + %gi\n", m_real, m_imag);
}

complex complex::operator+(const complex &A) const {
    return complex(m_real + A.m_real, m_imag + A.m_imag);
}

int main() {
    complex A(1.24, 5.7), B(4, 3.14), C;
    C = A + B;
    C.print();
    return 0;
}
</script></code></pre>
<pre><code class="language-cpp line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [15:51:24]
$ g++ a.cpp

# root @ arch in ~/work on git:master x [15:51:36]
$ ./a.out
5.24 + 8.84i
</script></code></pre>
<p>本例中定义了一个复数类 complex，m_real 表示实部，m_imag 表示虚部，第 9 行声明了运算符重载，第 19 行进行了实现（定义）；认真观察这两行代码，可以发现运算符重载的形式与函数非常类似；</p>
<p>运算符重载其实就是定义一个函数，在函数体内实现想要的功能，当用到该运算符时，编译器会自动调用这个函数；也就是说，运算符重载是通过函数实现的，它本质上是函数重载；</p>
<p>对于上面的<code>+</code>运算符重载：<code>complex operator+(const complex &amp;A) const;</code><br>函数名为<code>operator+</code>，返回值类型为<code>complex</code>，参数为<code>const complex &amp;</code>，并且是一个const成员；<br>在 25 行中，<code>C = A + B;</code>会被转换为类似的函数调用形式：<code>C = A.operator+(B);</code>，这实质上就是调用对象的成员函数；</p>
<p><strong>运算符重载函数除了函数名有特定的格式，其它地方和普通函数并没有区别</strong>；</p>
<p><strong>在全局范围内重载运算符</strong><br>运算符重载函数不仅可以作为类的成员函数，还可以作为全局函数；更改上面的代码，在全局范围内重载+，实现复数的加法运算：</p>
<pre><code class="language-cpp line-numbers"><script type="text/plain">#include <cstdio>

using namespace std;

class complex {
public:
    complex(double real = 0.0, double imag = 0.0) : m_real(real), m_imag(imag) {}
    void print() const;
    friend complex operator+(const complex &A, const complex &B);
private:
    double m_real;
    double m_imag;
};

void complex::print() const {
    printf("%g + %gi\n", m_real, m_imag);
}

complex operator+(const complex &A, const complex &B) {
    return complex(A.m_real + B.m_real, A.m_imag + B.m_imag);
}

int main() {
    complex A(1.24, 5.7), B(4, 3.14), C;
    C = A + B;
    C.print();
    return 0;
}
</script></code></pre>
<pre><code class="language-cpp line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [16:02:16]
$ g++ a.cpp

# root @ arch in ~/work on git:master x [16:02:29]
$ ./a.out
5.24 + 8.84i
</script></code></pre>
<p>运算符重载函数不是 complex 类的成员函数，但是却用到了 complex 类的 private 成员变量，所以必须在 complex 类中将该函数声明为<code>友元函数</code>；</p>
<p>当执行<code>C = A + B;</code>语句时，编译器检测到+号两边都是 complex 对象，就会转换为类似这样的函数调用：<code>C = operator+(A, B);</code></p>
<p><strong>小结</strong><br>虽然运算符重载所实现的功能完全可以用函数替代，但运算符重载使得程序的书写更加人性化，易于阅读；<br>运算符被重载后，原有的功能仍然保留，没有丧失或改变；通过运算符重载，扩大了C++已有运算符的功能，使之能用于对象；</p>
<h2 id="运算符重载的规则"><a href="#运算符重载的规则" class="headerlink" title="运算符重载的规则"></a>运算符重载的规则</h2><p>运算符重载是通过函数重载实现的，概念上大家都很容易理解，这节我们来说一下运算符重载的注意事项：</p>
<p>1) 并不是所有的运算符都可以重载，能够重载的运算符包括：<br><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>^</code>、<code>&amp;</code>、<code>|</code>、<code>~</code>、<code>!</code>、<code>=</code>、<code>&lt;</code>、<code>&gt;</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>、<code>^=</code>、<code>&amp;=</code>、<code>|=</code>、<code>&lt;&lt;</code>、<code>&gt;&gt;</code>、<code>&lt;&lt;=</code>、<code>&gt;&gt;=</code>、<code>==</code>、<code>!=</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>&amp;&amp;</code>、<code>||</code>、<code>++</code>、<code>--</code>、<code>,</code>、<code>-&gt;*</code>、<code>-&gt;</code>、<code>()</code>、<code>[]</code>、<code>new</code>、<code>new[]</code>、<code>delete</code>、<code>delete[]</code></p>
<p>上述运算符中，<code>[]</code>是下标运算符，<code>()</code>是函数调用运算符；自增自减运算符的前置和后置形式都可以重载；长度运算符<code>sizeof</code>、条件运算符<code>: ?</code>、成员选择符<code>.</code>和域解析运算符<code>::</code>不能被重载；</p>
<p>2) <strong>重载不能改变运算符的优先级和结合性</strong>；</p>
<p>3) 重载不会改变运算符的用法，原有有几个操作数、操作数在左边还是在右边，这些都不会改变；例如<code>~</code>号右边只有一个操作数，<code>+</code>号总是出现在两个操作数之间，重载后也必须如此；</p>
<p>4) 运算符重载函数不能有默认的参数，否则就改变了运算符操作数的个数，这显然是错误的；</p>
<p>5) 运算符重载函数既可以作为类的成员函数，也可以作为全局函数；</p>
<p>将运算符重载函数作为类的成员函数时，二元运算符的参数只有一个，一元运算符不需要参数；之所以少一个参数，是因为这个参数是隐含的；</p>
<p>将运算符重载函数作为全局函数时，二元操作符就需要两个参数，一元操作符需要一个参数，而且其中必须有一个参数是对象，好让编译器区分这是程序员自定义的运算符，防止程序员修改用于内置类型的运算符的性质；<br>如果有两个参数，这两个参数可以都是对象，也可以一个是对象，一个是C++内置类型的数据；</p>
<p>另外，将运算符重载函数作为全局函数时，一般都需要在类中将该函数声明为友元函数；原因很简单，该函数大部分情况下都需要使用类的 private 成员；</p>
<p>6) 箭头运算符<code>-&gt;</code>、下标运算符<code>[]</code>、函数调用运算符<code>()</code>、赋值运算符<code>=</code>只能以<strong>成员函数</strong>的形式重载；</p>
<h2 id="重载数学运算符"><a href="#重载数学运算符" class="headerlink" title="重载数学运算符"></a>重载数学运算符</h2><p>四则运算符（<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>）和关系运算符（<code>&gt;</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;=</code>、<code>==</code>、<code>!=</code>）都是数学运算符，它们在实际开发中非常常见，被重载的几率也很高，并且有着相似的重载格式；</p>
<p>本节以复数类 Complex 为例对它们进行重载，重在演示运算符重载的语法以及规范：<br>复数能够进行完整的四则运算，但不能进行完整的关系运算：我们只能判断两个复数是否相等，但不能比较它们的大小，所以不能对<code>&gt;</code>、<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;=</code>进行重载；</p>
<pre><code class="language-cpp line-numbers"><script type="text/plain">#include <iostream>
#include <cmath>

using namespace std;

class complex {
public:
    complex(double real = 0.0, double imag = 0.0) : m_real(real), m_imag(imag) {}
    friend ostream & operator<<(ostream &out, complex &A);
    friend complex operator+(const complex &A, const complex &B);
    friend complex operator-(const complex &A, const complex &B);
    friend complex operator*(const complex &A, const complex &B);
    friend complex operator/(const complex &A, const complex &B);
    friend bool operator==(const complex &A, const complex &B);
    friend bool operator!=(const complex &A, const complex &B);
    void operator+=(const complex &A);
    void operator-=(const complex &A);
    void operator*=(const complex &A);
    void operator/=(const complex &A);
private:
    double m_real;
    double m_imag;
};

ostream & operator<<(ostream &out, complex &A) {
    out << A.m_real << " + " << A.m_imag << "i";
    return out;
}

complex operator+(const complex &A, const complex &B) {
    return complex(A.m_real + B.m_real, A.m_imag + B.m_imag);
}

complex operator-(const complex &A, const complex &B) {
    return complex(A.m_real - B.m_real, A.m_imag - B.m_imag);
}

complex operator*(const complex &A, const complex &B) {
    return complex(A.m_real*B.m_real - A.m_imag*B.m_imag, A.m_imag*B.m_real + A.m_real*B.m_imag);
}

complex operator/(const complex &A, const complex &B) {
    return complex((A.m_real*B.m_real + A.m_imag*B.m_imag)/(pow(B.m_real, 2) + pow(B.m_imag, 2)), (A.m_imag*B.m_real - A.m_real*B.m_imag)/(pow(B.m_real, 2) + pow(B.m_imag, 2)));
}

bool operator==(const complex &A, const complex &B) {
    if (A.m_real == B.m_real && A.m_imag == B.m_imag) {
        return true;
    } else {
        return false;
    }
}

bool operator!=(const complex &A, const complex &B) {
    if (A.m_real != B.m_real || A.m_imag != B.m_imag) {
        return true;
    } else {
        return false;
    }
}

void complex::operator+=(const complex &A) {
    m_real += A.m_real;
    m_imag += A.m_imag;
}

void complex::operator-=(const complex &A) {
    m_real -= A.m_real;
    m_imag -= A.m_imag;
}

void complex::operator*=(const complex &A) {
    m_real = m_real * A.m_real - m_imag * A.m_imag;
    m_imag = m_imag * A.m_real + m_real * A.m_imag;
}

void complex::operator/=(const complex &A) {
    m_real = (m_real*A.m_real + m_imag*A.m_imag) / (pow(A.m_real, 2) + pow(A.m_imag, 2));
    m_imag = (m_imag*A.m_real - m_real*A.m_imag) / (pow(A.m_real, 2) + pow(A.m_imag, 2));
}

int main() {
    complex c1(10, 20), c2(3, 5), c3;

    c3 = c1 + c2;
    cout << c3 << endl;

    c3 = c1 - c2;
    cout << c3 << endl;

    c3 = c1 * c2;
    cout << c3 << endl;

    c3 = c1 / c2;
    cout << c3 << endl;

    c3 += c1;
    cout << c3 << endl;

    c3 -= c2;
    cout << c3 << endl;

    c3 *= c1;
    cout << c3 << endl;

    c3 /= c2;
    cout << c3 << endl;

    if (c1 == c2) {
        cout << "c1 == c2" << endl;
    }

    if (c1 != c2) {
        cout << "c1 != c2" << endl;
    }
    return 0;
}
</script></code></pre>
<pre><code class="language-cpp line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [18:09:09]
$ g++ a.cpp

# root @ arch in ~/work on git:master x [18:09:13]
$ ./a.out
13 + 25i
7 + 15i
-70 + 110i
3.82353 + 0.294118i
13.8235 + 20.2941i
10.8235 + 15.2941i
-197.647 + -3800i
-576.263 + -250.55i
c1 != c2
</script></code></pre>
<p>需要注意的是，我们以全局函数的形式重载了<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>==</code>、<code>!=</code>，以成员函数的形式重载了<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>，而且应该坚持这样做，不能一股脑都写作成员函数或者全局函数，具体原因我们将在下节讲解；</p>
<h2 id="以成员函数和全局函数重载运算符的区别"><a href="#以成员函数和全局函数重载运算符的区别" class="headerlink" title="以成员函数和全局函数重载运算符的区别"></a>以成员函数和全局函数重载运算符的区别</h2><p>在上节的例子中，我们以全局函数的形式重载了<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>==</code>、<code>!=</code>，以成员函数的形式重载了<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>，而没有一股脑都写成全局函数或者成员函数，这样做是有原因的，这节我们就来分析一下：</p>
<p><strong>简单地了解转换构造函数</strong></p>
<p>全局函数（友元函数）形式重载 + 号；</p>
<pre><code class="language-cpp line-numbers"><script type="text/plain">#include <iostream>

using namespace std;

class complex {
public:
    complex(double real = 0.0, double imag = 0.0) : m_real(real), m_imag(imag) {}
    friend ostream & operator<<(ostream &out, complex &A);
    friend complex operator+(const complex &A, const complex &B);
private:
    double m_real;
    double m_imag;
};

ostream & operator<<(ostream &out, complex &A) {
    out << A.m_real << " + " << A.m_imag << "i";
    return out;
}

complex operator+(const complex &A, const complex &B) {
    return complex(A.m_real + B.m_real, A.m_imag + B.m_imag);
}

int main() {
    complex a(1, 1), b;
    b = a + a;
    cout << b << endl;
    b = a + 1.1;
    cout << b << endl;
    b = 2.2 + a;
    cout << b << endl;
    return 0;
}
</script></code></pre>
<pre><code class="language-cpp line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [19:11:20]
$ g++ a.cpp

# root @ arch in ~/work on git:master x [19:11:21]
$ ./a.out
2 + 2i
2.1 + 1i
3.2 + 1i
</script></code></pre>
<p>成员函数形式重载 + 号：</p>
<pre><code class="language-cpp line-numbers"><script type="text/plain">#include <iostream>

using namespace std;

class complex {
public:
    complex(double real = 0.0, double imag = 0.0) : m_real(real), m_imag(imag) {}
    friend ostream & operator<<(ostream &out, complex &A);
    complex operator+(const complex &A) const;
private:
    double m_real;
    double m_imag;
};

ostream & operator<<(ostream &out, complex &A) {
    out << A.m_real << " + " << A.m_imag << "i";
    return out;
}

complex complex::operator+(const complex &A) const {
    return complex(m_real + A.m_real, m_imag + A.m_imag);
}

int main() {
    complex a(1, 1), b;
    b = a + a;
    cout << b << endl;
    b = a + 1.1;
    cout << b << endl;
//  b = 2.2 + a;
//  cout << b << endl;
    return 0;
}
</script></code></pre>
<pre><code class="language-cpp line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [19:14:53]
$ g++ a.cpp

# root @ arch in ~/work on git:master x [19:15:03]
$ ./a.out
2 + 2i
2.1 + 1i
</script></code></pre>
<p>给构造函数提供了实部和虚部的默认参数 0.0 后，使该构造函数同时也成为了一个<code>转换构造函数</code>；</p>
<blockquote>
<p>C++ 会对成员函数的参数进行类型转换，而不会对调用成员函数的对象进行类型转换；</p>
</blockquote>
<p>对于全局函数形式的重载 + ：<br>先来看<code>b = a + 1.1;</code>，实际上会被转换为<code>b = operator+(a, 1.1);</code>这样的形式进行调用；因为存在转换构造函数，并且第一个参数为 double，那么编译器就会将 1.1 转换为一个匿名 complex 对象<code>complex(1.1)</code>，进而在运算符重载函数内部将它们两个的实部，虚部相加，然后返回一个匿名 complex 对象并赋值给 b；</p>
<p>而对于<code>b = 2.2 + a;</code>，也是一样的道理，被转换为<code>b = operator+(2.2, a);</code>这样的形式，然后又调用转换构造函数将 2.2 转换为一个匿名 complex 对象<code>complex(2.2)</code>，后面的步骤同上；</p>
<p>对于成员函数形式的重载 + ：<br>对于<code>b = a + 1.1;</code>，被转换为<code>b = a.operator+(1.1);</code>，1.1 也是被转换为<code>complex(1.1)</code>；<br>对于<code>b = 2.2 + a;</code>，被转换为<code>b = (2.2).operator+(a);</code>，这很显然是不正确的，进而编译报错；</p>
<p><strong>为什么以全局函数方式重载运算符 +</strong></p>
<blockquote>
<p>以全局函数的形式重载 +，是为了保证 + 运算符的操作数能够被<strong>对称的处理</strong>；换句话说，<code>小数（double）</code>在 + 左边和右边都是正确的；</p>
</blockquote>
<p><strong>为什么以成员函数方式重载运算符 +=</strong><br>我们首先要明白，运算符重载的初衷是给类添加新的功能，方便类的运算，它作为类的成员函数是理所应当的，是首选的；<br>不过，类的成员函数不能对称地处理数据，程序员必须在（参与运算的）所有类型的内部都重载当前的运算符；</p>
<p>以上面的情况为例，我们必须在 Complex 和 double 内部都重载 + 运算符，这样做不但会增加运算符重载的数目，还要在许多地方修改代码，这显然不是我们所希望的，所以 C++ 进行了折中，允许以全局函数（友元函数）的形式重载运算符；</p>
<p>采用全局函数能使我们定义这样的运算符，它们的参数具有逻辑的对称性；<br>与此相对应的，把运算符定义为成员函数能够保证在调用时对第一个（最左的）运算对象不出现类型转换，也就是上面提到的「C++ 不会对调用成员函数的对象进行类型转换」；</p>
<p>总结起来说，有一部分运算符重载既可以是成员函数也可以是全局函数，虽然没有一个必然的、不可抗拒的理由选择成员函数，但我们应该优先考虑成员函数，这样更符合运算符重载的初衷；<br>另外有一部分运算符重载必须是全局函数，这样能保证参数的对称性；</p>
<p>除了 C++ 规定的几个特定的运算符外，暂时还没有发现必须以成员函数的形式重载的运算符；</p>
<blockquote>
<p>C++ 规定，<code>箭头运算符-&gt;</code>、<code>下标运算符[]</code>、<code>函数调用运算符()</code>、<code>赋值运算符=</code>只能以<strong>成员函数</strong>的形式重载；</p>
</blockquote>
<h2 id="重载-gt-gt-和-lt-lt-（输入输出运算符）"><a href="#重载-gt-gt-和-lt-lt-（输入输出运算符）" class="headerlink" title="重载&gt;&gt;和&lt;&lt;（输入输出运算符）"></a>重载&gt;&gt;和&lt;&lt;（输入输出运算符）</h2><p>在C++中，标准库本身已经对<code>左移运算符&lt;&lt;</code>和<code>右移运算符&gt;&gt;</code>分别进行了重载，使其能够用于不同数据的输入输出，但是输入输出的对象只能是 C++ 内置的数据类型（例如 bool、int、double 等）和标准库所包含的类类型（例如 string、complex、ofstream、ifstream 等）；</p>
<p>如果我们自己定义了一种新的数据类型，需要用输入输出运算符去处理，那么就必须对它们进行重载；<br>本节以前面的 complex 类为例来演示输入输出运算符的重载；</p>
<p>其实 C++ 标准库已经提供了 complex 类，能够很好地支持复数运算；<br>我们自己又定义了一个 complex 类的目的仅仅是为了做演示，并没有别的意图；</p>
<p>本节要达到的效果就是让复数的输入输出和 int、float 等基本类型一样简单；</p>
<p>假设 num1、num2 是复数，那么输出形式就是：<code>cout &lt;&lt; num1 &lt;&lt; num2 &lt;&lt; endl;</code>，输入形式就是：<code>cin &gt;&gt; num1 &gt;&gt; num2;</code>；</p>
<p>cout 是 istream 类的对象，cin 是 ostream 类的对象，要想达到这个目标，就必须以全局函数（友元函数）的形式重载<code>&lt;&lt;</code>和<code>&gt;&gt;</code>，否则就要修改标准库中的类，这显然不是我们所期望的；</p>
<pre><code class="language-cpp line-numbers"><script type="text/plain">#include <iostream>

using namespace std;

class complex {
public:
    complex(double real = 0.0, double imag = 0.0) : m_real(real), m_imag(imag) {}
    friend istream & operator>>(istream &in, complex &A);
    friend ostream & operator<<(ostream &out, complex &A);
private:
    double m_real;
    double m_imag;
};

istream & operator>>(istream &in, complex &A) {
    in >> A.m_real >> A.m_imag;
    return in;
}

ostream & operator<<(ostream &out, complex &A) {
    out << A.m_real << " + " << A.m_imag << "i";
    return out;
}

int main() {
    complex a, b;
    cin >> a >> b;
    cout << a << "\t" << b << endl;
    return 0;
}
</script></code></pre>
<pre><code class="language-cpp line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [19:59:28]
$ g++ a.cpp

# root @ arch in ~/work on git:master x [20:00:10]
$ ./a.out
1 2 3 4
1 + 2i    3 + 4i
</script></code></pre>
<h2 id="重载-（下标运算符）"><a href="#重载-（下标运算符）" class="headerlink" title="重载[]（下标运算符）"></a>重载[]（下标运算符）</h2><p>C++ 规定，<code>下标运算符[]</code>必须以<strong>成员函数</strong>的形式进行重载；</p>
<p>该重载函数在类中的声明格式：<code>返回值类型 &amp; operator[](参数);</code>，或者<code>const 返回值类型 &amp; operator[](参数) const;</code></p>
<p>使用第一种声明方式，<code>[]</code>不仅可以访问元素，还可以修改元素；<br>使用第二种声明方式，<code>[]</code>只能访问而不能修改元素；</p>
<p>在实际开发中，我们应该同时提供以上两种形式，这样做是为了适应 const 对象，因为通过 const 对象只能调用 const 成员函数，如果不提供第二种形式，那么将无法访问 const 对象的任何元素；</p>
<p>下面我们通过一个具体的例子来演示如何重载<code>[]</code>；</p>
<pre><code class="language-cpp line-numbers"><script type="text/plain">#include <cstdio>

using namespace std;

class Array {
public:
    Array(int len = 0);
    ~Array();
public:
    int length() const;
    void print() const;
public:
    int & operator[](int i);
    const int & operator[](int i) const;
private:
    int m_len;
    int *m_ptr;
};

Array::Array(int len) : m_len(len) {
    if (len == 0) {
        m_ptr = nullptr;
    } else {
        m_ptr = new int[len];
    }
}

Array::~Array() {
    delete[] m_ptr;
}

int Array::length() const {
    return m_len;
}

void Array::print() const {
    printf("Array[%d] = { ", m_len);
    for (int i=0; i<m_len; i++) {
        printf("%d, ", m_ptr[i]);
    }
    printf("\b\b }\n");
}

int & Array::operator[](int i) {
    return m_ptr[i];
}

const int & Array::operator[](int i) const {
    return m_ptr[i];
}

int main() {
    int len;
    printf("array_len: ");
    scanf("%d", &len);

    Array arr1(len);
    for (int i=0; i<arr1.length(); i++) {
        arr1[i] = i*5;
    }
    arr1.print();

    const Array arr2(len);
    printf("arr2[0] = %d\n", arr2[0]);
    return 0;
}
</script></code></pre>
<pre><code class="language-cpp line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [20:21:40] C:130
$ g++ a.cpp

# root @ arch in ~/work on git:master x [20:21:42]
$ ./a.out
array_len: 4
Array[4] = { 0, 5, 10, 15 }
arr2[0] = 0
</script></code></pre>
<h2 id="重载-和-（自增自减运算符）"><a href="#重载-和-（自增自减运算符）" class="headerlink" title="重载++和--（自增自减运算符）"></a>重载<code>++</code>和<code>--</code>（自增自减运算符）</h2><p><code>自增++</code>和<code>自减--</code>都是一元运算符，它的前置形式和后置形式都可以被重载：</p>
<pre><code class="language-cpp line-numbers"><script type="text/plain">#include <iostream>
#include <cstdio>

using namespace std;

class stopwatch {
public:
    stopwatch() : m_min(0), m_sec(0) {}
public:
    void setzero() { m_min = m_sec = 0; }
    stopwatch run();
    stopwatch operator++(); // ++i 前置形式
    stopwatch operator++(int); // i++ 后置形式
    friend ostream & operator<<(ostream &out, const stopwatch &s);
private:
    int m_min;
    int m_sec;
};

stopwatch stopwatch::run() {
    m_sec++;
    if (m_sec == 60) {
        m_min++;
        m_sec = 0;
    }
    return *this;
}

stopwatch stopwatch::operator++() {
    return run();
}

stopwatch stopwatch::operator++(int) {
    stopwatch s = *this;
    run();
    return s;
}

ostream & operator<<(ostream &out, const stopwatch &s) {
    out << s.m_min << ":" << s.m_sec << endl;
    return out;
}

int main() {
    stopwatch s1, s2;

    s1 = s2++;
    cout << s1 << s2;

    s1.setzero(); s2.setzero();
    s1 = ++s2;
    cout << s1 << s2;

    return 0;
}
</script></code></pre>
<pre><code class="language-cpp line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [20:36:29] C:127
$ g++ a.cpp

# root @ arch in ~/work on git:master x [20:36:31]
$ ./a.out
0:0
0:1
0:1
0:1
</script></code></pre>
<p>自减运算符的重载与上面类似，这里不再赘述；</p>
<h2 id="重载new和delete运算符"><a href="#重载new和delete运算符" class="headerlink" title="重载new和delete运算符"></a>重载new和delete运算符</h2><p>内存管理运算符：<code>new</code>、<code>new[]</code>、<code>delete</code>和<code>delete[]</code>也可以进行重载，其重载形式既可以是类的成员函数，也可以是全局函数；</p>
<p>一般情况下，内建的内存管理运算符就够用了，只有在需要自己管理内存时才会重载；</p>
<p><strong>重载 new 运算符</strong>：<code>void * operator new(size_t size);</code><br><strong>重载 new[] 运算符</strong>：<code>void * operator new[](size_t size);</code></p>
<p>返回值是<code>void *</code>类型，并且都有一个参数，为<code>size_t</code>类型；<br>重载<code>new</code>或<code>new[]</code>时，无论是作为成员函数还是作为全局函数，它的第一个参数必须是<code>size_t</code>类型；<br><code>size_t</code>表示的是要分配空间的大小，对于<code>new[]</code>的重载函数而言，<code>size_t</code>则表示所需要分配的所有空间的总和；</p>
<p>当然，重载函数也可以有其他参数，但都必须有默认值，并且第一个参数的类型必须是<code>size_t</code>；</p>
<p><strong>重载 delete 运算符</strong>：<code>void operator delete(void *ptr);</code><br><strong>重载 delete[] 运算符</strong>：<code>void operator delete[](void *ptr);</code></p>
<p>两种重载形式的返回值都是<code>void</code>类型，并且都必须有一个<code>void *</code>类型的指针作为参数，该指针指向需要释放的内存空间；</p>
    </div>
    <div>
    </div>
    <div>
    </div>
    <div>
    </div>
    <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/cpp/" rel="tag"># cpp</a>
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/cpp-template.html" rel="next" title="C++ 模板">
                <i class="fa fa-chevron-left"></i> C++ 模板
              </a>
          </div>
          <span class="post-nav-divider"></span>
          <div class="post-nav-prev post-nav-item">
              <a href="/cpp-polymorphism.html" rel="prev" title="C++ 多态与虚函数">
                C++ 多态与虚函数 <i class="fa fa-chevron-right"></i>
              </a>
          </div>
        </div>
    </footer>
  </article>
    <div class="post-spread">
    </div>
  </div>
          </div>
  <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer" target="_blank">comments powered by Disqus.</a>
        </noscript>
      </div>
  </div>
        </div>
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>
  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Otokaze">
          <p class="site-author-name" itemprop="name">Otokaze</p>
              <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">170</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
        </nav>
        <div class="links-of-author motion-element">
              <span class="links-of-author-item">
                <a href="https://github.com/zfl9" target="_blank" title="GitHub rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-github"></i>
                  GitHub
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="mailto:zfl9.com@gmail.com" target="_blank" title="Email rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-envelope"></i>
                  Email
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://gitlab.com/zfl9" target="_blank" title="GitLab rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-gitlab"></i>
                  GitLab
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://t.me/Otokaze" target="_blank" title="Telegram rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-telegram"></i>
                  Telegram
                </a>
              </span>
        </div>
      </section>
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符重载的概念"><span class="nav-number">1.</span> <span class="nav-text">运算符重载的概念</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#运算符重载的规则"><span class="nav-number">2.</span> <span class="nav-text">运算符重载的规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载数学运算符"><span class="nav-number">3.</span> <span class="nav-text">重载数学运算符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#以成员函数和全局函数重载运算符的区别"><span class="nav-number">4.</span> <span class="nav-text">以成员函数和全局函数重载运算符的区别</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载-gt-gt-和-lt-lt-（输入输出运算符）"><span class="nav-number">5.</span> <span class="nav-text">重载>>和<<（输入输出运算符）< span=""></（输入输出运算符）<></span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载-（下标运算符）"><span class="nav-number">6.</span> <span class="nav-text">重载[]（下标运算符）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载-和-（自增自减运算符）"><span class="nav-number">7.</span> <span class="nav-text">重载++和--（自增自减运算符）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#重载new和delete运算符"><span class="nav-number">8.</span> <span class="nav-text">重载new和delete运算符</span></a></li></ol></div>
          </div>
        </section>
      <!--/noindex-->
    </div>
  </aside>
      </div>
    </main>
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Otokaze</span>
</div>
<script src="/js/clipboard.min.js"></script>
<script src="/js/prism/prism.js" async></script>
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
  </div>
<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>
      <script id="dsq-count-scr" src="https://otokaze.disqus.com/count.js" async></script>
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://www.zfl9.com/cpp-operator-overload.html';
          this.page.identifier = 'cpp-operator-overload.html';
          this.page.title = 'C++ 运算符重载';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://otokaze.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("3hhdw6gOg9wavsharVwVjqI3-gzGzoHsz", "O5WfDffqFsgmAVPwNY9of3QU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");
      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });
      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';
          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);
            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);
      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }
    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</body>
</html>
