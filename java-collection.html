<!doctype html>
<html class="theme-next pisces" lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">
<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">
<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css">
  <meta name="keywords" content="Java Collection框架">
  <link rel="shortcut icon" type="image/x-icon" href="/images/favicon.ico?v=5.1.1">
<meta name="description" content="Java Collection框架，List 列表、Queue 队列、Deque 双端队列、Set 集合、Map 映射">
<meta name="keywords" content="java">
<meta property="og:type" content="article">
<meta property="og:title" content="Java Collection框架">
<meta property="og:url" content="https://www.zfl9.com/java-collection.html">
<meta property="og:site_name" content="Otokaze's Blog">
<meta property="og:description" content="Java Collection框架，List 列表、Queue 队列、Deque 双端队列、Set 集合、Map 映射">
<meta property="og:image" content="https://www.zfl9.com/images/java-collection.png">
<meta property="og:image" content="https://www.zfl9.com/images/java-collection-hashmap.png">
<meta property="og:image" content="https://www.zfl9.com/images/java-collection-weakref.png">
<meta property="og:updated_time" content="2019-02-18T12:44:16.326Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Java Collection框架">
<meta name="twitter:description" content="Java Collection框架，List 列表、Queue 队列、Deque 双端队列、Set 集合、Map 映射">
<meta name="twitter:image" content="https://www.zfl9.com/images/java-collection.png">
<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>
  <link rel="canonical" href="https://www.zfl9.com/java-collection.html">
<link href="/js/prism/prism.css" rel="stylesheet">
  <title>Java Collection框架 | Otokaze's Blog</title>
</head>
<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
  ga('create', 'UA-97872912-1', 'auto');
  ga('send', 'pageview');
</script>
  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?3d58f51dbb2496a0e6d17b85065a5ae5";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>
  <div class="container sidebar-position-left page-post-detail ">
    <div class="headband"></div>
    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Otokaze's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <h1 class="site-subtitle" itemprop="description">拼一年春夏秋冬，搏一生无怨无悔</h1>
  </div>
  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>
<nav class="site-nav">
    <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            首页
          </a>
        </li>
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br>
            分类
          </a>
        </li>
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            标签
          </a>
        </li>
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            归档
          </a>
        </li>
    </ul>
</nav>
 </div>
    </header>
    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
  <div id="posts" class="posts-expand">
  <article class="post post-type-normal " itemscope="" itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="https://www.zfl9.com/java-collection.html">
    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Otokaze">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>
    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Otokaze's Blog">
    </span>
      <header class="post-header">
          <h2 class="post-title" itemprop="name headline">
                Java Collection框架
          </h2>
        <div class="post-meta">
          <span class="post-time">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
                <span class="post-meta-item-text">发表于</span>
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-30T12:43:00+08:00">
                2017-09-30
              </time>
          </span>
            <span class="post-category">
              <span class="post-meta-divider">|</span>
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
                <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope="" itemtype="http://schema.org/Thing">
                  <a href="/categories/java/" itemprop="url" rel="index">
                    <span itemprop="name">java</span>
                  </a>
                </span>
            </span>
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/java-collection.html#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="java-collection.html" itemprop="commentCount"></span>
                </a>
              </span>
             <span id="/java-collection.html" class="leancloud_visitors" data-flag-title="Java Collection框架">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
                 <span class="post-meta-item-text">阅读次数 </span>
                 <span class="leancloud-visitors-count"></span>
             </span>
        </div>
      </header>
    <div class="post-body" itemprop="articleBody">
        <p>Java Collection框架，List 列表、Queue 队列、Deque 双端队列、Set 集合、Map 映射</p>
<a id="more"></a>
<h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><p>Java 集合框架中主要封装的是典型的<strong>数据结构</strong>和<strong>算法</strong>，如动态数组、双向链表、队列、栈、Set、Map 等；<br>Java 的 Collection 框架和 C++ 的标准模板库（STL）是相似的东西，集合框架极大的方便了 Java 程序的编写。</p>
<p>Collection 框架主要位于 java.util 包，类继承结构：<br><img src="/images/java-collection.png" alt="Java8 Collection 框架，类结构图"></p>
<p>主要分为以下几个部分：<br>1) <strong>数据结构</strong><br><code>List</code>列表、<code>Queue</code>队列、<code>Deque</code>双端队列、<code>Set</code>集合、<code>Map</code>映射<br>2) <strong>算法</strong><br><code>Collections</code>常用算法类、<code>Arrays</code>静态数组的排序、查找算法<br>3) <strong>迭代器</strong><br><code>Iterator</code>通用迭代器、<code>ListIterator</code>针对 List 特化的迭代器<br>4) <strong>比较器</strong><br><code>Comparator</code>比较器</p>
<p><strong>简要分析</strong><br>1) List 主要实现类：ArrayList、LinkedList<br><strong>ArrayList</strong>：”动态数组”，支持随机存取，尾部插入删除方便，内部插入删除效率低（因为要移动数组元素）；如果内部数组容量不足则自动扩容，因此当数组很大时，效率较低；<br><strong>LinkedList</strong>：”双向链表”，在任意位置插入删除都很方便，但是不支持随机存取，每次都只能从一端开始遍历，不过，它不像 ArrayList 那样需要进行内存拷贝，因此相对来说效率较高，但是因为存在额外的前驱和后继节点指针，因此占用的内存比 ArrayList 多一些。</p>
<p>2) Queue 主要实现类：ArrayDeque、LinkedList、PriorityQueue<br><strong>ArrayDeque</strong>：基于数组实现的双端队列，“循环数组”，可作为 Stack 栈使用；<br><strong>LinkedList</strong>：基于双向链表实现的双端队列，可以作为 Stack 栈使用；<br><strong>PriorityQueue</strong>：“最小堆”，“完全二叉树”，优先级队列，使用数组保存了完全二叉树。</p>
<p>3) Deque 主要实现类：ArrayDeque、LinkedList<br><strong>ArrayDeque</strong>：基于数组实现的双端队列，“循环数组”，可作为 Stack 栈使用；<br><strong>LinkedList</strong>：基于双向链表实现的双端队列，可以作为 Stack 栈使用。</p>
<p>4) Set 主要实现类：HashSet、LinkedHashSet、TreeSet、EnumSet（RegularEnumSet、JumboEnumSet）<br><strong>HashSet</strong>：基于 HashMap 实现，元素不可重复，特性同 HashMap；<br><strong>LinkedHashSet</strong>：基于 LinkedHashMap 实现，元素不可重复，特性同 LinkedHashMap；<br><strong>TreeSet</strong>：基于 TreeMap 实现，元素不可重复，特性同 TreeMap；<br><strong>RegularEnumSet</strong>：枚举专用的 Set 集合，由 EnumSet 调用，因为该类的权限为 [default]，元素必须为枚举类型，与其他 Set 实现不同，其内部使用位向量实现，拥有极高的时间和空间性能；<br><strong>JumboEnumSet</strong>：枚举专用的 Set 集合，由 EnumSet 调用，因为该类的权限为 [default]，元素必须为枚举类型，与其他 Set 实现不同，其内部使用位向量实现，拥有极高的时间和空间性能。</p>
<p>5) Map 主要实现类：HashMap、LinkedHashMap、TreeMap、IdentityHashMap、WeakHashMap、EnumMap<br><strong>HashMap</strong>：key 不可重复，使用 equals 判断，根据 key 的 hashCode 存储数据，具有很快的访问速度，记录的遍历顺序与记录的输入顺序基本不一致；最多只允许一条记录的 key 为 null；<br><strong>LinkedHashMap</strong>：key 不可重复，使用 equals 判断，HashMap 的子类，内部使用双向链表保存了记录的插入顺序，使得输入的记录顺序和输出的记录顺序是相同的；<br><strong>TreeMap</strong>：key 不可重复，使用 equals 判断，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用 Iterator 遍历时，得到的记录是排过序的；如需使用排序的映射，建议使用 TreeMap；<br><strong>IdentityHashMap</strong>：key 不可重复，使用 == 判断，比较内存地址，可以说是某种意义上的可重复 key 的映射；<br><strong>WeakHashMap</strong>：弱引用 Map，特别适合用于需要缓存的场景，WeakHashMap 中的 Entry 可能随时被 GC 回收；<br><strong>EnumMap</strong>：枚举专用的 Map 映射，其 key 必须为某种枚举类型的枚举常量，内部通过数组实现，因此效率比一般的 Map 高。</p>
<h2 id="主要接口"><a href="#主要接口" class="headerlink" title="主要接口"></a>主要接口</h2><h3 id="Iterable-接口"><a href="#Iterable-接口" class="headerlink" title="Iterable 接口"></a>Iterable 接口</h3><p>Iterable，”可迭代的”，如果一个集合类实现了该接口，那么表示这个集合类可进行迭代操作，比如 JDK1.5 提供的 foreach 循环。</p>
<p>Collection 框架主要有两大接口：Collection、Map，其中 Collection 接口继承了 Iterable 接口，因此所有实现了 Collection 接口的类都是可迭代的，可用于类似 foreach 操作；Map 虽然没有直接实现 Iterable 接口，但是它提供了对应的 Collection 视图，因此也能进行类似的迭代操作。</p>
<p>Iterable 接口位于 java.lang 包，其主要方法为 iterator()，用来获取当前集合对象的一个迭代器 Iterator。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">Iterator<T> iterator(); // 获取当前集合的迭代器
default void forEach(Consumer<? super T> action); // forEach，与 Lambda 结合使用
default Spliterator<T> spliterator(); // 获取 Spliterator 可分割迭代器（可并行迭代）
</script></code></pre>
<h3 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h3><p>前面说了 Iterable 可迭代对象，它的主要方法就是 iterator()，获取可迭代对象的迭代器；而迭代器就是 Iterator，这个接口位于 java.util 包，一般来说每个集合类都有自己的特定迭代器实现，一般是一个内部类。</p>
<p>Iterator 接口有两个主要方法：hasNext()、next()，通常这两个方法需要配合使用：<br>hasNext() 方法，判断当前集合对象是否还有下一个可操作元素，如果有则返回 true，通常用于 for、while 条件；<br>next() 方法，获取当前集合对象的下一个可操作元素，与此同时，迭代器将向后推进一个元素单位，指向下一个位置。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">boolean hasNext(); // 判断是否还有元素
E next(); // 获取下一个元素
default void remove(); // 删除当前元素
default void forEachRemaining(Consumer<? super E> action); // 一次性遍历剩余的全部元素
</script></code></pre>
<h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><p>java.util.Collection 接口是 Java Collection 框架的两大主要接口之一，有三个主要子接口 List、Queue、Set；<br>因为 Collection 接口是 java.lang.Iterable 的子接口，因此 List、Queue、Deque、Set 都可以用于 foreach 循环。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 集合大小 */
int size(); // 元素数量
boolean isEmpty(); // 集合是否为空
void clear(); // 移除所有元素

/* 迭代器 */
Iterator<E> iterator(); // 获取迭代器
default Spliterator<E> spliterator(); // 获取可分割迭代器
default Stream<E> stream(); // 返回当前集合的串行流
default Stream<E> parallelStream(); // 返回当前集合的并行流

/* 元素数组 */
// 包含所有元素的数组，注意是 Object 类型，返回的数组可以被自由修改
Object[] toArray();
// 包含所有元素的数组
// 如果给定数组的容量不足，则分配一个新数组并返回
// 如果容量有余，则结束位置后一个元素被设置为 null
<T> T[] toArray(T[] a);

/* 添加/移除/测试 */
boolean add(E e); // 添加给定元素，仅当集合改变时返回 true
boolean addAll(Collection<? extends E> c); // 添加给定集合中的所有元素，仅当集合改变时返回 true
boolean remove(Object o); // 移除给定元素，仅当集合改变时返回 true (若存在多个元素，只会移除一个)
boolean removeAll(Collection<?> c); // 移除当前集合中包含在给定集合的元素，仅当集合改变时返回 true
boolean contains(Object o); // 是否包含指定元素
boolean containsAll(Collection<?> c); // 是否包含指定集合中的所有元素

/* 条件删除 */
boolean retainAll(Collection<?> c); // 仅保留在给定集合中存在的元素，仅当集合改变时返回 true
default boolean removeIf(Predicate<? super E> filter); // 删除满足条件的所有元素，仅当集合改变时返回 true

/* Object */
int hashCode();
boolean equals(Object o);
</script></code></pre>
<h3 id="Comparable-接口"><a href="#Comparable-接口" class="headerlink" title="Comparable 接口"></a>Comparable 接口</h3><p>java.lang.Comparable，<strong>可比较的</strong>，对象的属性；<br>java.util.Comparator，<strong>比较器</strong>，比较对象的工具。</p>
<p>它们的区别就如同 Iterable、Iterator 之间的区别：</p>
<ul>
<li>如果一个类实现了 Comparable 接口，表示这个类的对象之间支持比较操作，可直接用于自然排序（一般为升序）；</li>
<li>如果一个类没有实现 Comparable 接口，但是它有专门的 Comparator 比较器，那么也可用于排序，定制性更高一些。</li>
</ul>
<p>Comparable 接口，如果一个类实现了此接口，则说明它的对象支持<strong>自然排序</strong>：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">public interface Comparable<T> {
    /**
     * @return 小于0: this < o
     *         等于0: this = o
     *         大于0: this > o
     */
    public int compareTo(T o);
}
</script></code></pre>
<h3 id="Comparator-接口"><a href="#Comparator-接口" class="headerlink" title="Comparator 接口"></a>Comparator 接口</h3><p>java.util.Comparator 函数式接口，主要方法为<code>int compare(T o1, T o2)</code>：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 比较两个对象，返回比较结果.
 * @param o1    对象 1
 * @param o2    对象 2
 * @return int  小于0: o1 < o2
 *              等于0: o1 = o2
 *              大于0: o1 > o2
 */
int compare(T o1, T o2);

/* Object */
boolean equals(Object obj);

/* 反向比较器 */
default Comparator<T> reversed(); // 将当前比较器改为与之相反顺序的比较器，并返回

/* 提取比较器 */
static <T extends Comparable<? super T>>
    Comparator<T> naturalOrder(); // 获取可比较对象 T 的自然排序比较器
static <T extends Comparable<? super T>>
    Comparator<T> reverseOrder(); // 获取可比较对象 T 的逆向排序比较器

/* null值处理 */
static <T>
    Comparator<T> nullsFirst(Comparator<? super T> comparator); // 返回的新比较器认为 null 值是最小的
static <T>
    Comparator<T> nullsLast(Comparator<? super T> comparator); // 返回的新比较器认为 null 值是最大的

/* 指定比较键 */
static <T, U>
    Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor,
                            Comparator<? super U> keyComparator);

static <T, U extends Comparable<? super U>> // 使用 U 键的自然排序
    Comparator<T> comparing(Function<? super T,? extends U> keyExtractor);

static <T>
    Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor); // int 特化版本
static <T>
    Comparator<T> comparingLong(ToLongFunction<? super T> keyExtractor); // long 特化版本
static <T>
    Comparator<T> comparingDouble(ToDoubleFunction<? super T> keyExtractor); // double 特化版本

/* 候选比较器 */
// 即当前比较器比较两个相同对象时，使用传入的比较器再进行比较
default Comparator<T> thenComparing(Comparator<? super T> other);

default <U>
    Comparator<T> thenComparing(Function<? super T, ? extends U> keyExtractor, // 先转换 T -> U
                                Comparator<? super U> keyComparator); // 比较 U 来决定它们的排序

default <U extends Comparable<? super U>> // 使用 U 的自然排序
    Comparator<T> thenComparing(Function<? super T, ? extends U> keyExtractor);

default Comparator<T> thenComparingInt(ToIntFunction<? super T> keyExtractor); // int 特化版本
default Comparator<T> thenComparingLong(ToLongFunction<? super T> keyExtractor); // long 特化版本
default Comparator<T> thenComparingDouble(ToDoubleFunction<? super T> keyExtractor); // double 特化版本
</script></code></pre>
<p>候选比较器例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">import java.util.Arrays;
import java.util.Comparator;

public class Main {
    public static void main(String[] args) {
        Test[] arr = new Test[] {
            new Test(1, 2, 3),
            new Test(1, 2, 2),
            new Test(1, 1, 1)
        };
        Arrays.stream(arr).forEach(System.out::println);

        Arrays.sort(arr, Test.COMP);
        System.out.println();
        Arrays.stream(arr).forEach(System.out::println);

        Arrays.sort(arr, Test.COMP.thenComparingInt(obj -> obj.getB())
                                  .thenComparingInt(obj -> obj.getC()));
        System.out.println();
        Arrays.stream(arr).forEach(System.out::println);
    }

    private static class Test {
        public static final
            Comparator<Test> COMP = (x, y) -> x.a - y.a;

        private int a;
        private int b;
        private int c;

        public Test(int a, int b, int c) {
            this.a = a;
            this.b = b;
            this.c = c;
        }

        public int getA() { return a; }
        public int getB() { return b; }
        public int getC() { return c; }

        @Override
        public String toString() {
            return String.format("[%d, %d, %d]", a, b, c);
        }
    }
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/java8-learn/com/zfl9/collection on git:master x [21:50:06]
$ javac *.java

# root @ arch in ~/java8-learn/com/zfl9/collection on git:master x [21:50:23]
$ java Main
[1, 2, 3]
[1, 2, 2]
[1, 1, 1]

[1, 2, 3]
[1, 2, 2]
[1, 1, 1]

[1, 1, 1]
[1, 2, 2]
[1, 2, 3]
</script></code></pre>
<h3 id="Cloneable-接口"><a href="#Cloneable-接口" class="headerlink" title="Cloneable 接口"></a>Cloneable 接口</h3><p>java.lang.Cloneable 接口和 java.io.Serializable 接口都是”标记接口”，没有任何方法签名。<br>稍微研究一下 Collection 框架的源码就可以发现，它们几乎都实现了 Cloneable、Serializable 接口。</p>
<p>Cloneable 接口：如果一个类实现了该接口，表示这个类的对象支持 clone() 操作，即对象是可克隆的；<br>Serializable 接口：如果一个类实现了该接口，表示这个类支持 readObject()/writeObject() 序列化操作。</p>
<p>在 Object 类中，有一个 protected 的 clone() 方法，并且是一个 native 方法：<br><code>protected native Object clone() throws CloneNotSupportedException;</code><br>默认情况下，我们不能直接调用一个对象的 clone() 方法，因为它被 protected 所修饰。</p>
<p>那么我们先把它给重写，并且把其访问性改为 public 试试：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        A a1 = new A();
        A a2 = a1.clone();
    }
}

class A {
    @Override
    public A clone() throws CloneNotSupportedException {
        return (A) super.clone();
    }
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [21:06:21]
$ javac Main.java

# root @ arch in ~/work on git:master x [21:06:35]
$ java Main
Exception in thread "main" java.lang.CloneNotSupportedException: A
    at java.lang.Object.clone(Native Method)
    at A.clone(Main.java:11)
    at Main.main(Main.java:4)
</script></code></pre>
<p>编译没有问题，但运行时抛出异常 CloneNotSupportedException，不支持 clone 操作；<br>这是因为我们没有实现 Cloneable 接口，就和 Serializable 序列化一样，会进行类型检查。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        A a1 = new A();
        A a2 = a1.clone();

        System.out.println(a1);
        System.out.println(a2);
    }
}

class A implements Cloneable {
    @Override
    public A clone() throws CloneNotSupportedException {
        return (A) super.clone();
    }
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [21:09:10]
$ javac Main.java

# root @ arch in ~/work on git:master x [21:09:21]
$ java Main
A@15db9742
A@6d06d69c
</script></code></pre>
<p>可以了，先提前说一下，这种直接调用 Object.clone() 方法的克隆方式称为”浅拷贝”；我们来看一下它的局限性：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">import java.util.Arrays;

public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        A a1 = new A();
        System.out.printf("a1 -> i: %d, f: %.2f, obj: %s, arr: %s %s\n", a1.i, a1.f, a1.obj, a1.arr, Arrays.toString(a1.arr));

        A a2 = a1.clone();
        System.out.printf("a2 -> i: %d, f: %.2f, obj: %s, arr: %s %s\n", a2.i, a2.f, a2.obj, a2.arr, Arrays.toString(a2.arr));

        a1.i = 20;
        a2.i = 40;
        System.out.printf("a1 -> i: %d, f: %.2f, obj: %s, arr: %s %s\n", a1.i, a1.f, a1.obj, a1.arr, Arrays.toString(a1.arr));
        System.out.printf("a2 -> i: %d, f: %.2f, obj: %s, arr: %s %s\n", a2.i, a2.f, a2.obj, a2.arr, Arrays.toString(a2.arr));

        a1.arr[0] = 8;
        System.out.printf("a1 -> i: %d, f: %.2f, obj: %s, arr: %s %s\n", a1.i, a1.f, a1.obj, a1.arr, Arrays.toString(a1.arr));
        System.out.printf("a2 -> i: %d, f: %.2f, obj: %s, arr: %s %s\n", a2.i, a2.f, a2.obj, a2.arr, Arrays.toString(a2.arr));

        a2.arr[0] = 9;
        System.out.printf("a1 -> i: %d, f: %.2f, obj: %s, arr: %s %s\n", a1.i, a1.f, a1.obj, a1.arr, Arrays.toString(a1.arr));
        System.out.printf("a2 -> i: %d, f: %.2f, obj: %s, arr: %s %s\n", a2.i, a2.f, a2.obj, a2.arr, Arrays.toString(a2.arr));
    }
}

class A implements Cloneable {
    public int i = 10;
    public float f = 3.14f;
    public Object obj = new Object();
    public int[] arr = {1, 2, 3, 4, 5};

    @Override
    public A clone() throws CloneNotSupportedException {
        return (A) super.clone();
    }
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [21:27:26]
$ javac Main.java

# root @ arch in ~/work on git:master x [21:27:37]
$ java Main
a1 -> i: 10, f: 3.14, obj: java.lang.Object@15db9742, arr: [I@6d06d69c [1, 2, 3, 4, 5]
a2 -> i: 10, f: 3.14, obj: java.lang.Object@15db9742, arr: [I@6d06d69c [1, 2, 3, 4, 5]
a1 -> i: 20, f: 3.14, obj: java.lang.Object@15db9742, arr: [I@6d06d69c [1, 2, 3, 4, 5]
a2 -> i: 40, f: 3.14, obj: java.lang.Object@15db9742, arr: [I@6d06d69c [1, 2, 3, 4, 5]
a1 -> i: 20, f: 3.14, obj: java.lang.Object@15db9742, arr: [I@6d06d69c [8, 2, 3, 4, 5]
a2 -> i: 40, f: 3.14, obj: java.lang.Object@15db9742, arr: [I@6d06d69c [8, 2, 3, 4, 5]
a1 -> i: 20, f: 3.14, obj: java.lang.Object@15db9742, arr: [I@6d06d69c [9, 2, 3, 4, 5]
a2 -> i: 40, f: 3.14, obj: java.lang.Object@15db9742, arr: [I@6d06d69c [9, 2, 3, 4, 5]
</script></code></pre>
<p>对于值类型 int、float，没有所谓的深拷贝浅拷贝之分，因为它就是一个简简单单的数值；<br>对于引用类型（数组也是引用类型），默认的浅拷贝只会拷贝它的引用，也就是内存地址。</p>
<p>这样的话两个对象之间修改就会互相影响，很显然不是我们想要的理想结果；<br>我们既然通过 clone 创建新对象，目的就是为了它们之间的修改不会对对方产生影响。</p>
<p>那么如何做到”深拷贝”呢，其实也很简单，只要把每个引用对象都拷贝就行了，如下：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">import java.util.Arrays;

public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        A a1 = new A();
        A a2 = a1.clone();
        System.out.println(a1 + ", " + a1.arr + ", " + Arrays.toString(a1.arr));
        System.out.println(a2 + ", " + a2.arr + ", " + Arrays.toString(a2.arr));

        a1.arr[0] = 8;
        a2.arr[0] = 9;
        System.out.println(a1 + ", " + a1.arr + ", " + Arrays.toString(a1.arr));
        System.out.println(a2 + ", " + a2.arr + ", " + Arrays.toString(a2.arr));
    }
}

class A implements Cloneable {
    public int[] arr = {1, 2, 3, 4, 5};

    @Override
    public A clone() throws CloneNotSupportedException {
        A result = (A) super.clone();
        result.arr = this.arr.clone();
        return result;
    }
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [21:42:01]
$ javac Main.java

# root @ arch in ~/work on git:master x [21:42:11]
$ java Main
A@15db9742, [I@6d06d69c, [1, 2, 3, 4, 5]
A@7852e922, [I@4e25154f, [1, 2, 3, 4, 5]
A@15db9742, [I@6d06d69c, [8, 2, 3, 4, 5]
A@7852e922, [I@4e25154f, [9, 2, 3, 4, 5]
</script></code></pre>
<p>目前看来好像达到了我们的”深拷贝”目的，但是，有个问题，如果有的数据成员没有实现 Cloneable 接口怎么办；<br>如果是我们自己的类还好说，进行简单的修改就好了，但是如果是其它的呢，比如 Java API，我们是不可能去修改的。</p>
<p>其实还有一种办法，可以做到完美的”深拷贝”，那就是 java.io.Serializable 接口，对的，通过序列化来进行深拷贝。如果你还不了解<strong>对象序列化</strong>，请猛戳 <a href="https://www.zfl9.com/java-io.html#Object-引用类型">Serializable - 对象序列化与反序列化</a>。</p>
<p>特别的，如果序列化对象的成员变量为引用类型，并且它不属于 String、Array、Enum，Serializable 类型，那么在执行序列化的过程中，将会抛出运行时异常 NotSerializableException。因此对于这些引用类型的成员变量，有三种选择：<br>1) 使用 transient 关键字声明该成员，在序列化时跳过该成员变量，在反序列化之后自动赋值 null；<br>2) 如果该引用类型是你自己创建的类，那么可以直接让其实现 java.io.Serializable 接口；<br>3) 创建一个派生类，这个派生类没有任何声明的方法和属性，仅仅用于序列化和反序列化。</p>
<p>其中第一、二种方式并不是我们想要的，我们来实现第三种方式：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Serializable;
import java.io.IOException;

public class Main {
    public static void main(String[] args) throws IOException, ClassNotFoundException {
        A.Serial a1 = new A.Serial();
        A a2 = serial(a1); // 发生向上转型

        System.out.println(a1 + ", " + a1.obj);
        System.out.println(a2 + ", " + a2.obj);
    }

    @SuppressWarnings("unchecked")
    private static <T extends Serializable> T serial(T t) throws IOException, ClassNotFoundException {
        ByteArrayOutputStream out = new ByteArrayOutputStream();
        ObjectOutputStream objOut = new ObjectOutputStream(out);
        objOut.writeObject(t);
        ObjectInputStream objIn = new ObjectInputStream(new ByteArrayInputStream(out.toByteArray()));
        return (T) objIn.readObject();
    }
}

class A { // 注意 A 不能实现 Serializable 接口！
    public Object obj = new Object();

    // 专用于序列化的静态内部类 A.Serial
    public static class Serial extends A implements Serializable {
        private static final long serialVersionUID = 1L;
    }
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [9:02:48]
$ javac Main.java

# root @ arch in ~/work on git:master x [9:03:00]
$ java Main
A$Serial@55f96302, java.lang.Object@119d7047
A$Serial@776ec8df, java.lang.Object@4eec7777
</script></code></pre>
<p>通过这种方式虽然可以完美解决 Object.clone()”深拷贝”问题，但是相对来说效率还是比较低下的，毕竟存在多次内存拷贝。</p>
<h2 id="List-列表"><a href="#List-列表" class="headerlink" title="List 列表"></a>List 列表</h2><h3 id="List-接口"><a href="#List-接口" class="headerlink" title="List 接口"></a>List 接口</h3><pre><code class="language-java line-numbers"><script type="text/plain">/* 集合大小 */
int size(); // 元素数量
boolean isEmpty(); // 是否为空
void clear(); // 清空列表的所有元素

/* 迭代器 */
Iterator<E> iterator(); // 获取迭代器
ListIterator<E> listIterator(); // 获取列表迭代器
ListIterator<E> listIterator(int index); // 获取列表迭代器，从给定位置开始
default Spliterator<E> spliterator(); // 获取可分割迭代器，可并行迭代，JDK1.8

/* 元素数组 */
Object[] toArray(); // 获取包含所有元素的数组
<T> T[] toArray(T[] a); // 获取包含所有元素的数组

/* 添加/移除/测试 */
boolean add(E e); // 添加元素
boolean addAll(Collection<? extends E> c); // 添加指定集合中的所有元素
boolean addAll(int index, Collection<? extends E> c); // 添加指定集合中的所有元素至给定位置
boolean remove(Object o); // 移除元素
boolean removeAll(Collection<?> c); // 移除当前集合中包含在给定集合的元素
boolean contains(Object o); // 是否包含指定元素
boolean containsAll(Collection<?> c); // 是否包含指定集合中的所有元素

/* 条件删除 */
boolean retainAll(Collection<?> c); // 仅保留在给定集合中存在的元素
boolean removeIf(Predicate<? super E> filter); // [继承] 删除满足条件的所有元素

/* 排序/替换 */
default void sort(Comparator<? super E> c); // 排序当前列表
default void replaceAll(UnaryOperator<E> operator); // 替换全部元素

/* 随机访问 */
E get(int index); // 获取给定位置的元素
E set(int index, E element); // 替换给定位置的元素

void add(int index, E element); // 在给定位置插入元素
E remove(int index); // 移除给定位置的元素

int indexOf(Object o); // 查找给定元素第一次出现的位置
int lastIndexOf(Object o); // 查找给定元素最后一次出现的位置

List<E> subList(int fromIndex, int toIndex); // 获取给定范围的子列表"视图"

/* Object */
int hashCode();
boolean equals(Object o);
</script></code></pre>
<h3 id="ListIterator-接口"><a href="#ListIterator-接口" class="headerlink" title="ListIterator 接口"></a>ListIterator 接口</h3><p>java.util.ListIterator 是 Iterator 的一个子接口，是专门用于 List 列表的迭代器。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">boolean hasNext(); // [正向] 是否还有元素
E next(); // [正向] 获取下一个元素

boolean hasPrevious(); // [反向] 是否还有元素
E previous(); // [反向] 获取下一个元素

int nextIndex(); // [正向] 获取下一个元素的索引
int previousIndex(); // [反向] 获取下一个元素的索引，若当前迭代器位于列表头部则返回 -1

void remove(); // 删除当前元素
void set(E e); // 替换当前元素
void add(E e); // 在当前元素后面追加元素
</script></code></pre>
<p>逆向迭代的例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">import java.util.Iterator;
import java.util.ListIterator;
import java.util.ArrayList;

public class Main {
    public static void main(String[] args) {
        ArrayList<Integer> list = new ArrayList<>(10);

        // 填充元素
        for (int i = 0; i < 10; i++) {
            list.add(i);
        }

        // Iterable.forEach() 使用 Lambda
        list.forEach((e) -> System.out.print(e + ", "));
        System.out.println();

        // Iterable.iterator() 获取迭代器
        for (Iterator<Integer> iter = list.iterator(); iter.hasNext();) {
            System.out.print(iter.next() + ", ");
        }
        System.out.println();

        // JDK1.5 foreach循环 [语法糖]
        for (int e : list) {
            System.out.print(e + ", ");
        }
        System.out.println();

        // ListIterator 逆向迭代
        for (ListIterator<Integer> iter = list.listIterator(list.size()); iter.hasPrevious();) {
            System.out.print(iter.previous() + ", ");
        }
        System.out.println();
    }
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [11:15:23]
$ javac Main.java

# root @ arch in ~/work on git:master x [11:18:40]
$ java Main
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
9, 8, 7, 6, 5, 4, 3, 2, 1, 0,
</script></code></pre>
<h3 id="ArrayList-类"><a href="#ArrayList-类" class="headerlink" title="ArrayList 类"></a>ArrayList 类</h3><p>java.util.ArrayList 实现了 List 接口，内部使用 Object[] 数组存储元素，允许 null 元素，数组容量不足时自动增长。它与大多数集合类一样，是非线程安全的，如果需要进行额外的同步，可以考虑 Collections 的<code>&lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code>静态方法进行包装；如果是读多写少，请考虑使用 java.util.concurrent.CopyOnWriteArrayList。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 构造函数 */
public ArrayList(int initialCapacity); // 指定内部数组的初始容量
public ArrayList(); // 空数组
public ArrayList(Collection<? extends E> c); // 使用给定集合构造列表

/* 容量 */
public void trimToSize(); // 回收多余的数组容量
public void ensureCapacity(int minCapacity); // 手动扩容，仅当 minCapacity > 当前容量时有效

/* 大小 */
public int size(); // 元素数量
public void clear(); // 清空列表
public boolean isEmpty(); // 是否为空

/* 迭代器 */
public Iterator<E> iterator();
public ListIterator<E> listIterator(int index);
public ListIterator<E> listIterator();
public Spliterator<E> spliterator();
public void forEach(Consumer<? super E> action); // java.lang.Iterable

/* 元素数组 */
public Object[] toArray();
public <T> T[] toArray(T[] a);

/* 添加/移除 */
public boolean add(E e);
public boolean addAll(Collection<? extends E> c);
public boolean addAll(int index, Collection<? extends E> c);
public boolean remove(Object o);
public boolean removeAll(Collection<?> c);
public boolean contains(Object o);
public boolean containsAll(Collection<?> c);

/* 条件删除 */
public boolean retainAll(Collection<?> c);
public boolean removeIf(Predicate<? super E> filter); // java.util.Collection

/* 排序/替换 */
public void sort(Comparator<? super E> c); // java.util.List
public void replaceAll(UnaryOperator<E> operator); // java.util.List

/* 随机访问 */
public E get(int index);
public E set(int index, E element)

public void add(int index, E element);
public E remove(int index);

public int indexOf(Object o); // 查询给定元素第一次出现的位置
public int lastIndexOf(Object o); // 查询给定元素最后一次出现的位置

public List<E> subList(int fromIndex, int toIndex);

/* 对象克隆 */
public Object clone();
</script></code></pre>
<h3 id="LinkedList-类"><a href="#LinkedList-类" class="headerlink" title="LinkedList 类"></a>LinkedList 类</h3><p>java.util.LinkedList 实现了 List 和 Deque 接口，内部使用<strong>双向链表</strong>实现，允许 null 元素，在遍历链表时，可能从头结点或尾结点开始，以近的为准。它与大多数集合类一样，是非线程安全的，如果需要额外的同步，可以考虑 Collections 的<code>&lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list)</code>静态方法进行包装，如果是读多写少的应用场景，可以考虑使用写时复制容器 java.util.concurrent.CopyOnWriteArrayList。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 构造函数 */
public LinkedList(); // 空列表
public LinkedList(Collection<? extends E> c); // 给定集合

/* 集合大小 */
public int size();
public void clear();
public boolean isEmpty();

/* 迭代器 */
public Iterator<E> iterator();
public ListIterator<E> listIterator();
public ListIterator<E> listIterator(int index);
public Iterator<E> descendingIterator(); // java.util.Deque，从尾结点开始遍历
public Spliterator<E> spliterator();

/* Object */
public Object[] toArray();
public <T> T[] toArray(T[] a);

/* 添加/移除 */
public boolean add(E e);
public boolean addAll(Collection<? extends E> c);
public boolean addAll(int index, Collection<? extends E> c);
public boolean remove(Object o);
public boolean removeAll(Collection<?> c);
public boolean contains(Object o);
public boolean containsAll(Collection<?> c);

/* 条件删除 */
public boolean retainAll(Collection<?> c);
default boolean removeIf(Predicate<? super E> filter);

/* 随机访问 */
public E get(int index);
public E set(int index, E element);
public void add(int index, E element);
public E remove(int index);
public int indexOf(Object o);
public int lastIndexOf(Object o);
public List<E> subList(int fromIndex, int toIndex);

/* Object */
public Object clone();

/* [Queue] 抛异常系列 */
public boolean add(E e);
public E remove();
public E element();

/* [Queue] 特定值系列 */
public boolean offer(E e);
public E poll();
public E peek();

/* [Deque] 抛异常系列 */
public void addFirst(E e); // 在头部添加元素
public void addLast(E e); // 在尾部添加元素
public E removeFirst(); // 在头部弹出元素
public E removeLast(); // 在尾部弹出元素
public E getFirst(); // 在头部窥探元素
public E getLast(); // 在尾部窥探元素

/* [Deque] 特定值系列 */
public boolean offerFirst(E e); // 在头部添加元素
public boolean offerLast(E e); // 在尾部添加元素
public E pollFirst(); // 在头部弹出元素
public E pollLast(); // 在尾部弹出元素
public E peekFirst(); // 在头部窥探元素
public E peekLast(); // 在尾部窥探元素

/* [Deque] 当作栈使用 */
public void push(E e); // addFirst() 入栈
public E pop(); // removeFirst() 出栈

/* [Deque] 其它方法 */
public boolean removeFirstOccurrence(Object o); // 移除第一个命中的元素
public boolean removeLastOccurrence(Object o); // 移除最后一个命中的元素
</script></code></pre>
<h2 id="Queue-队列"><a href="#Queue-队列" class="headerlink" title="Queue 队列"></a>Queue 队列</h2><h3 id="Queue-接口"><a href="#Queue-接口" class="headerlink" title="Queue 接口"></a>Queue 接口</h3><p>java.util.Queue 队列，遵循 FIFO 先进先出原则，在队尾插入元素叫做入队，在队头弹出元素叫做出队。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 抛异常系列 */
boolean add(E e); // 在队尾插入元素
E remove(); // 在队头弹出元素
E element(); // 在队头窥探元素

/* 特定值系列 */
boolean offer(E e); // 在队尾插入元素
E poll(); // 在队头弹出元素
E peek(); // 在队头窥探元素
</script></code></pre>
<h3 id="Deque-接口"><a href="#Deque-接口" class="headerlink" title="Deque 接口"></a>Deque 接口</h3><p>java.util.Deque 双端队列，是具有<strong>队列</strong>、<strong>栈</strong>性质的一种数据结构。Deque 是 Queue 的子接口，主要有两个实现类：ArrayDeque、LinkedList。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 抛异常系列 */
void addFirst(E e);
void addLast(E e);
E removeFirst();
E removeLast();
E getFirst();
E getLast();

/* 特定值系列 */
boolean offerFirst(E e);
boolean offerLast(E e);
E pollFirst();
E pollLast();
E peekFirst();
E peekLast();

/* 移除元素 */
boolean removeFirstOccurrence(Object o);
boolean removeLastOccurrence(Object o);

/* 栈操作 */
void push(E e); // addFirst()
E pop(); // removeFirst()

/* 迭代器 */
Iterator<E> descendingIterator(); // 从尾结点开始遍历

/* [Queue] 抛异常系列 */
boolean add(E e);
E remove();
E element();

/* [Queue] 特定值系列 */
boolean offer(E e);
E poll();
E peek();
</script></code></pre>
<h3 id="ArrayDeque-类"><a href="#ArrayDeque-类" class="headerlink" title="ArrayDeque 类"></a>ArrayDeque 类</h3><p>java.util.ArrayDeque 是 java.util.Deque 的一个实现类，内部使用数组（循环数组）存储元素，容量不足会自动增长，ArrayDeque <strong>不允许 null 元素</strong>。它与大多数集合类一样，是非线程安全的，如果需要支持并发的 FIFO 队列，请使用 java.util.concurrent.ConcurrentLinkedDeque。ArrayDeque 在作为 stack 栈使用时，它可能比 Stack 更快；ArrayDeque 在作为 queue 队列使用时，它可能比 LinkedList 更快。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 构造函数 */
public ArrayDeque(); // 可容纳 16 个元素
public ArrayDeque(int numElements); // 可容纳 numElements 个元素
public ArrayDeque(Collection<? extends E> c); // addAll(c)

/* [Deque] 抛异常系列 */
public void addFirst(E e);
public void addLast(E e);
public E removeFirst();
public E removeLast();
public E getFirst();
public E getLast();

/* [Deque] 特定值系列 */
public boolean offerFirst(E e)
public boolean offerLast(E e);
public E pollFirst();
public E pollLast();
public E peekFirst();
public E peekLast();

/* [Deque] 移除元素 */
public boolean removeFirstOccurrence(Object o);
public boolean removeLastOccurrence(Object o);

/* [Deque] 栈操作 */
public void push(E e); // addFirst()
public E pop(); // removeFirst()

/* [Queue] 抛异常系列 */
public boolean add(E e);
public E remove();
public E element();

/* [Queue] 特定值系列 */
public boolean offer(E e);
public E poll();
public E peek();

/* 集合大小 */
public int size();
public void clear();
public boolean isEmpty();

/* 迭代器 */
public Iterator<E> iterator();
public Iterator<E> descendingIterator();
public Spliterator<E> spliterator();

/* 元素数组 */
public Object[] toArray();
public <T> T[] toArray(T[] a);

/* 克隆集合 */
public ArrayDeque<E> clone();
</script></code></pre>
<h3 id="PriorityQueue-类"><a href="#PriorityQueue-类" class="headerlink" title="PriorityQueue 类"></a>PriorityQueue 类</h3><p>java.util.PriorityQueue 优先队列，优先队列的元素根据其自然顺序（Comparable）或者使用提供的比较器（Comparator）来排序，无论是哪种方式，PriorityQueue 都<strong>不允许 null 元素</strong>。而依据自然排序的优先级队列也不允许插入不可比较对象，这将导致 ClassNotFoundException。优先级队列的对头元素是<strong>权值最小</strong>的元素（即由比较器决定的最小的元素），而内部存储元素的数组也会在容量不足时自动增长。它与大多数集合类一样，是非线程安全的，如果需要额外的同步，请考虑使用优先级阻塞队列 java.util.concurrent.PriorityBlockingQueue。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 构造函数 */
public PriorityQueue(); // 初始容量 11
public PriorityQueue(int initialCapacity);
public PriorityQueue(Comparator<? super E> comparator); // 指定比较器
public PriorityQueue(int initialCapacity, Comparator<? super E> comparator);
public PriorityQueue(Collection<? extends E> c);
public PriorityQueue(PriorityQueue<? extends E> c);
public PriorityQueue(SortedSet<? extends E> c);

/* 实例方法 */
public Comparator<? super E> comparator(); // 获取比较器，如果为自然排序则返回 null

public boolean add(E e);
public E remove();
public E element();

public boolean offer(E e);
public E poll();
public E peek();
</script></code></pre>
<p>例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">import java.util.Random;
import java.util.PriorityQueue;

public class Main {
    public static void main(String[] args) {
        PriorityQueue<Integer> queue1 = new PriorityQueue<>(10);

        Random rand = new Random();
        for (int i = 0; i < 10; i++) {
            queue1.offer(rand.nextInt(90) + 10); // 随机两位数
        }

        for (int i = 0; i < 10; i++) { // 默认是自然排序 [升序]
            System.out.print(queue1.poll() + ", ");
        }
        System.out.println();

        /*
         * (int n1, int n2) -> { return n1 - n2; } 升序
         * (int n1, int n2) -> { return n2 - n1; } 降序
         */
        PriorityQueue<Integer> queue2 = new PriorityQueue<>(10, (n1, n2) -> n2 - n1);

        for (int i = 0; i < 10; i++) {
            queue2.offer(rand.nextInt(90) + 10); // 随机两位数
        }

        for (int i = 0; i < 10; i++) {
            System.out.print(queue2.poll() + ", ");
        }
        System.out.println();
    }
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [14:13:51]
$ javac Main.java

# root @ arch in ~/work on git:master x [14:14:01]
$ java Main
10, 10, 15, 24, 36, 39, 69, 70, 85, 90,
96, 91, 87, 73, 71, 61, 60, 49, 24, 11,

# root @ arch in ~/work on git:master x [14:14:03]
$ java Main
12, 36, 45, 50, 64, 73, 80, 88, 90, 91,
87, 82, 68, 53, 49, 38, 36, 36, 32, 30,

# root @ arch in ~/work on git:master x [14:14:04]
$ java Main
15, 28, 42, 69, 82, 83, 90, 92, 96, 99,
93, 87, 64, 59, 59, 56, 51, 31, 23, 17,
</script></code></pre>
<h2 id="Map-映射"><a href="#Map-映射" class="headerlink" title="Map 映射"></a>Map 映射</h2><h3 id="Map-接口"><a href="#Map-接口" class="headerlink" title="Map 接口"></a>Map 接口</h3><pre><code class="language-java line-numbers"><script type="text/plain">/* Map.Entry 内部接口 */
interface Map.Entry<K, V> {
    K getKey(); // 获取 key
    V getValue(); // 获取 value
    V setValue(V value); // 更新 value

    int hashCode();
    boolean equals(Object o);

    // 自然排序 - key
    static <K extends Comparable<? super K>, V>
        Comparator<Map.Entry<K, V>> comparingByKey();
    // 自然排序 - value
    static <K, V extends Comparable<? super V>>
        Comparator<Map.Entry<K, V>> comparingByValue();
    // 自定义排序 - key
    static <K, V>
        Comparator<Map.Entry<K, V>> comparingByKey(Comparator<? super K> cmp);
    // 自定义排序 - value
    static <K, V>
        Comparator<Map.Entry<K, V>> comparingByValue(Comparator<? super V> cmp);
}

int size(); // entry 数量
void clear(); // 清空 entry
boolean isEmpty(); // 是否为空

boolean containsKey(Object key); // 是否包含给定键
boolean containsValue(Object value); // 是否包含给定值

V get(Object key); // 获取给定键的对应值，如果不存在则返回 null
V put(K key, V value); // 更新给定键的对应值，返回给定键的旧值，如果给定键先前不存在则返回 null
V remove(Object key); // 删除给定键以及对应值，返回给定键的旧值，如果给定键先前不存在则返回 null
void putAll(Map<? extends K, ? extends V> m); // 添加给定 map 中的所有 entry

Set<K> keySet(); // [key 视图] 视图中支持删除操作，但不支持添加操作
Collection<V> values(); // [value 视图] 视图中支持删除操作，但不支持添加操作
Set<Map.Entry<K, V>> entrySet(); // [entry 视图] 视图中支持删除操作，但不支持添加操作

int hashCode();
boolean equals(Object o);

default void forEach(BiConsumer<? super K, ? super V> action); // forEach 循环，entry 视图

default V getOrDefault(Object key, V defaultValue); // 如果不存在则返回默认 value
default V putIfAbsent(K key, V value); // 如果给定键不存在则 put，并返回 null 值，否则返回当前值
default boolean remove(Object key, Object value); // 如果存在给定 entry 则删除并返回 true，否则返回 false

default boolean replace(K key, V oldValue, V newValue); // 如果存在给定 entry 则更新给定 value，并返回 true
default V replace(K key, V value); // 如果存在给定 key，则更新给定 value，并返回之前的旧值，否则直接返回 null
default void replaceAll(BiFunction<? super K, ? super V, ? extends V> function); // 更新 value 值，接收三个参数

// 请查阅 https://docs.oracle.com/javase/8/docs/api/java/util/Map.html
default V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction);
default V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction);
default V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction);

// 请查阅 https://docs.oracle.com/javase/8/docs/api/java/util/Map.html
default V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction);
</script></code></pre>
<h3 id="SortedMap-接口"><a href="#SortedMap-接口" class="headerlink" title="SortedMap 接口"></a>SortedMap 接口</h3><p>java.util.SortedMap 是 Map 的子接口，它定义了一个有序的映射。插入的元素要么实现了 java.lang.Comparable 接口，而支持自然排序，要么在构造时提供一个 java.util.Comparator 比较器，而支持自定义排序；如果都不符合，则抛出 ClassCastException 异常。同时，keySet()、values()、entrySet() 方法返回的视图也是一个有序的 Map。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">Comparator<? super K> comparator(); // 获取当前比较器，如果为自然排序则返回 null

SortedMap<K, V> subMap(K fromKey, K toKey); // [子 map 视图] 该视图支持所有可选操作
SortedMap<K, V> headMap(K toKey); // [子 map 视图] 该视图支持所有可选操作
SortedMap<K, V> tailMap(K fromKey); // [子 map 视图] 该视图支持所有可选操作

K firstKey(); // 返回第一个 key（最小的）
K lastKey(); // 返回最后一个 key（最大的）

Set<K> keySet(); // [key 视图] 该视图支持删除操作，但不支持添加操作
Collection<V> values(); // [value 视图] 该视图支持删除操作，但不支持添加操作
Set<Map.Entry<K, V>> entrySet(); // [entry 视图] 该视图支持删除操作，但不支持添加操作
</script></code></pre>
<h3 id="NavigableMap-接口"><a href="#NavigableMap-接口" class="headerlink" title="NavigableMap 接口"></a>NavigableMap 接口</h3><p>java.util.NavigableMap 是 SortedMap 的子接口，它定义了一个可导航的映射。所谓的导航方法就是定位方法，比如查找小于、小于等于、大于等于、大于给定 key 的一个 key。但是请注意，这些导航方法都是为了定位而设计的，而不是为了遍历 Entry。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">Map.Entry<K, V> lowerEntry(K key); // 返回小于给定 key 的 entry，如果没有则返回 null
Map.Entry<K, V> floorEntry(K key); // 返回小于等于给定 key 的 entry，如果没有则返回 null
Map.Entry<K, V> ceilingEntry(K key); // 返回大于等于给定 key 的 entry，如果没有则返回 null
Map.Entry<K, V> higherEntry(K key); // 返回大于给定 key 的 entry，如果没有则返回 null

K lowerKey(K key); // 返回小于给定 key 的 key，如果没有则返回 null
K floorKey(K key); // 返回小于等于给定 key 的 key，如果没有则返回 null
K ceilingKey(K key); // 返回大于等于给定 key 的 key，如果没有则返回 null
K higherKey(K key); // 返回大于给定 key 的 key，如果没有则返回 null

Map.Entry<K, V> firstEntry(); // 返回最小 key 所在的 entry，如果没有则返回 null
Map.Entry<K, V> lastEntry(); // 返回最大 key 所在的 entry，如果没有则返回 null

Map.Entry<K, V> pollFirstEntry(); // 移除最小 key 所在的 entry，如果没有则返回 null
Map.Entry<K, V> pollLastEntry(); // 移除最大 key 所在的 entry，如果没有则返回 null

NavigableMap<K, V> descendingMap(); // [逆向视图] 返回当前 map 的逆向视图
NavigableMap<K, V> subMap(K fromKey, // [子 map 视图] 支持可选的所有操作
                          boolean fromInclusive,
                          K toKey,
                          boolean toInclusive);
NavigableMap<K, V> headMap(K toKey, boolean inclusive); // [子 map 视图] 支持可选的所有操作
NavigableMap<K, V> tailMap(K fromKey, boolean inclusive); // [子 map 视图] 支持可选的所有操作

NavigableSet<K> navigableKeySet(); // [key 视图(升序)] 该视图支持删除操作，但不支持添加操作
NavigableSet<K> descendingKeySet(); // [key 视图(降序)] 该视图支持删除操作，但不支持添加操作

SortedMap<K, V> subMap(K fromKey, K toKey); // [子 map 视图] 支持可选的所有操作
SortedMap<K, V> headMap(K toKey); // [子 map 视图] 支持可选的所有操作
SortedMap<K, V> tailMap(K fromKey); // [子 map 视图] 支持可选的所有操作
</script></code></pre>
<h3 id="HashMap-类"><a href="#HashMap-类" class="headerlink" title="HashMap 类"></a>HashMap 类</h3><p>HashMap <strong>允许 null 键、null 值</strong>，<strong>不保证遍历的顺序与插入的顺序是一样的</strong>，也不保证遍历的顺序可以永恒不变（自动扩容的原因）。HashMap 是<strong>数组</strong>和<strong>链表</strong>的结合体，HashMap 底层是一个<code>Entry[]</code>数组，该数组可以自动扩容；Entry[] 数组的每个元素都是一个链表，Entry 有一个 next 指针指向下一个 Node 节点。因为 HashMap 使用 hash() 哈希函数计算 key-value 键值对的索引值，因此它<strong>同时具有数组和链表的优点</strong>：查找，插入/删除都具有很高的性能。它与大多数集合类一样，是非线程安全的，如果需要额外的同步，请考虑使用并发 HashMap：java.util.concurrent.ConcurrentHashMap。HashMap 的数据结构如下图所示：<br><img src="/images/java-collection-hashmap.png" alt="HashMap 数据结构"></p>
<pre><code class="language-java line-numbers"><script type="text/plain">/**
 * 主要构造函数，有两个影响 HashMap 性能的参数.
 * @param initialCapacity   初始容量，即 Entry[] 数组的初始长度，默认为 16
 * @param loadFactor        负载因子，默认为 0.75f。如果当前元素数量（即 Entry 键值对的数量）
 *                          超过 Entry[].length * loadFactor 时，HashMap 内部将对 Entry[] 数组
 *                          进行扩容，新容量为当前容量的 2 倍。在扩容时需要重新计算 hash，并且
 *                          需要拷贝元素，开销非常大。因此，如果可以预见元素的数量，请务必指明
 *                          initialCapacity 的大小
 */
public HashMap(int initialCapacity, float loadFactor);
public HashMap(int initialCapacity); // 0.75F
public HashMap(); // initialCapacity = 16、loadFactor = 0.75F
public HashMap(Map<? extends K, ? extends V> m); // loadFactor = 0.75F

public int size(); // entry 数量
public void clear(); // 清空 entry
public boolean isEmpty(); // 是否为空

public boolean containsKey(Object key); // 是否包含给定键
public boolean containsValue(Object value); // 是否包含给定值

public V get(Object key); // 获取给定键的对应值，如果不存在则返回 null
public V put(K key, V value); // 更新给定键的对应值，返回给定键的旧值，如果给定键先前不存在则返回 null
public V remove(Object key); // 删除给定键以及对应值，返回给定键的旧值，如果给定键先前不存在则返回 null
public void putAll(Map<? extends K, ? extends V> m); // 添加给定 map 中的所有 entry

public Set<K> keySet(); // [key 视图] 视图中支持删除操作，但不支持添加操作
public Collection<V> values(); // [value 视图] 视图中支持删除操作，但不支持添加操作
public Set<Map.Entry<K,V>> entrySet(); // [entry 视图] 视图中支持删除操作，但不支持添加操作

public void forEach(BiConsumer<? super K, ? super V> action); // forEach 循环，entry 视图

public V getOrDefault(Object key, V defaultValue); // 如果不存在则返回默认 value
public V putIfAbsent(K key, V value); // 如果给定键不存在则 put，并返回 null 值，否则返回当前值
public boolean remove(Object key, Object value); // 如果存在给定 entry 则删除并返回 true，否则返回 false

public boolean replace(K key, V oldValue, V newValue); // 如果存在给定 entry 则更新给定 value，并返回 true
public V replace(K key, V value); // 如果存在给定 key，则更新给定 value，并返回之前的旧值，否则直接返回 null
public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function); // 更新 value 值，接收三个参数

public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction);
public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction);
public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction);

public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction);

/* Object */
public Object clone();
public int hashCode();
public boolean equals(Object o);
</script></code></pre>
<h3 id="LinkedHashMap-类"><a href="#LinkedHashMap-类" class="headerlink" title="LinkedHashMap 类"></a>LinkedHashMap 类</h3><p>LinkedHashMap 是 HashMap 的子类，底层还是使用的 HashMap，没有变化；不同的是，LinkedHashMap 可以按照<strong>插入顺序</strong>进行遍历，也可以根据<strong>访问顺序</strong>进行遍历。<br>可以保存顺序的原理就是它除了使用哈希表保存键值对之外，还在内部维护了一个<strong>运行时双向链表</strong>；当按照<strong>访问顺序</strong>进行排序时，LinkedHashMap 会将最近访问的键值对移动到链表的<strong>尾部</strong>。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 构造函数 */
public LinkedHashMap(int initialCapacity, // 初始容量
                     float loadFactor, // 负载因子
                     boolean accessOrder); // true 则为访问顺序，否则为插入顺序
public LinkedHashMap(int initialCapacity, float loadFactor); // accessOrder = false
public LinkedHashMap(int initialCapacity); // loadFactor = 0.75F、accessOrder = false
public LinkedHashMap(); // initialCapacity = 16、loadFactor = 0.75F、accessOrder = false
public LinkedHashMap(Map<? extends K,? extends V> m); // loadFactor = 0.75F、accessOrder = false

public int size(); // entry 数量
public void clear(); // 清空 entry
public boolean isEmpty(); // 是否为空

public boolean containsKey(Object key); // 是否包含给定键
public boolean containsValue(Object value); // 是否包含给定值

public V get(Object key); // 获取给定键的对应值，如果不存在则返回 null
public V put(K key, V value); // 更新给定键的对应值，返回给定键的旧值，如果给定键先前不存在则返回 null
public V remove(Object key); // 删除给定键以及对应值，返回给定键的旧值，如果给定键先前不存在则返回 null
public void putAll(Map<? extends K, ? extends V> m); // 添加给定 map 中的所有 entry

public Set<K> keySet(); // [key 视图] 视图中支持删除操作，但不支持添加操作
public Collection<V> values(); // [value 视图] 视图中支持删除操作，但不支持添加操作
public Set<Map.Entry<K,V>> entrySet(); // [entry 视图] 视图中支持删除操作，但不支持添加操作

public void forEach(BiConsumer<? super K, ? super V> action); // forEach 循环，entry 视图

public V getOrDefault(Object key, V defaultValue); // 如果不存在则返回默认 value
public V putIfAbsent(K key, V value); // 如果给定键不存在则 put，并返回 null 值，否则返回当前值
public boolean remove(Object key, Object value); // 如果存在给定 entry 则删除并返回 true，否则返回 false

public boolean replace(K key, V oldValue, V newValue); // 如果存在给定 entry 则更新给定 value，并返回 true
public V replace(K key, V value); // 如果存在给定 key，则更新给定 value，并返回之前的旧值，否则直接返回 null
public void replaceAll(BiFunction<? super K, ? super V, ? extends V> function); // 更新 value 值，接收三个参数

public V computeIfAbsent(K key, Function<? super K, ? extends V> mappingFunction);
public V computeIfPresent(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction);
public V compute(K key, BiFunction<? super K, ? super V, ? extends V> remappingFunction);

public V merge(K key, V value, BiFunction<? super V, ? super V, ? extends V> remappingFunction);

/* Object */
public Object clone();
public int hashCode();
public boolean equals(Object o);
</script></code></pre>
<p>LinkedHashMap 例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">import java.util.Map;
import java.util.LinkedHashMap;

public class Main {
    public static void main(String[] args) {
        LinkedHashMap<String, String> map = new LinkedHashMap<>(16, 0.75f, true);
        for (int i = 0; i < 10; i++) {
            map.put("K" + i, "V" + i);
        }

        for (Map.Entry<?, ?> entry : map.entrySet()) {
            System.out.println("key: " + entry.getKey() + ", value: " + entry.getValue());
        }

        map.get("K1");
        map.get("K2");
        map.get("K3");

        System.out.println();
        for (Map.Entry<?, ?> entry : map.entrySet()) {
            System.out.println("key: " + entry.getKey() + ", value: " + entry.getValue());
        }
    }
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [20:59:45]
$ javac Main.java

# root @ arch in ~/work on git:master x [21:00:00]
$ java Main
key: K0, value: V0
key: K1, value: V1
key: K2, value: V2
key: K3, value: V3
key: K4, value: V4
key: K5, value: V5
key: K6, value: V6
key: K7, value: V7
key: K8, value: V8
key: K9, value: V9

key: K0, value: V0
key: K4, value: V4
key: K5, value: V5
key: K6, value: V6
key: K7, value: V7
key: K8, value: V8
key: K9, value: V9
key: K1, value: V1
key: K2, value: V2
key: K3, value: V3
</script></code></pre>
<h3 id="TreeMap-类"><a href="#TreeMap-类" class="headerlink" title="TreeMap 类"></a>TreeMap 类</h3><p>java.util.TreeMap 实现了 NavigableMap 接口，因此它支持一系列的导航方法。TreeMap 内部使用<strong>红黑树（Red-Black tree）</strong>实现，它为 containsKey()、get()、put() 和 remove() 操作提供了 log(n) 的时间复杂度。TreeMap 的 key 根据其自然顺序（Comparable）或者使用提供的比较器（Comparator）来排序，这取决于它的构造函数。但是依据自然排序的 TreeMap 不允许插入不可比较对象，这将导致 ClassNotFoundException 异常。TreeMap <strong>允许 null 值</strong>，如果是使用自然排序，则不允许 null 键，如果是使用自定义排序，是否允许 null 键将取决于传入的比较器，如果该比较器允许 null 参数，则该 Map 也支持，否则将导致 NullPointerException 异常。它与大多数集合类一样，是非线程安全的，如果需要额外的同步，可以考虑使用 Collections 的<code>&lt;K, V&gt; NavigableMap&lt;K, V&gt; synchronizedNavigableMap(NavigableMap&lt;K, V&gt; m)</code>静态包装方法，或者使用并发的 TreeMap：java.util.concurrent.ConcurrentSkipListMap。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 构造函数 */
public TreeMap(); // 自然排序，key 必须实现 Comparable 接口
public TreeMap(Comparator<? super K> comparator); // 自定义排序，key 无需实现 Comparable 接口
public TreeMap(Map<? extends K, ? extends V> m); // 自然排序，给定 map 中的 key 必须实现 Comparable 接口
public TreeMap(SortedMap<K, ? extends V> m); // 使用给定 map 的比较器进行排序

/* SortedMap 接口 */
public Comparator<? super K> comparator(); // 获取当前比较器，如果为自然排序则返回 null

public SortedMap<K, V> subMap(K fromKey, K toKey); // [子 map 视图] 该视图支持所有可选操作
public SortedMap<K, V> headMap(K toKey); // [子 map 视图] 该视图支持所有可选操作
public SortedMap<K, V> tailMap(K fromKey); // [子 map 视图] 该视图支持所有可选操作

public K firstKey(); // 返回第一个 key（最小的）
public K lastKey(); // 返回最后一个 key（最大的）

public Set<K> keySet(); // [key 视图] 该视图支持删除操作，但不支持添加操作
public Collection<V> values(); // [value 视图] 该视图支持删除操作，但不支持添加操作
public Set<Map.Entry<K, V>> entrySet(); // [entry 视图] 该视图支持删除操作，但不支持添加操作

/* NavigableMap 接口 */
public Map.Entry<K, V> lowerEntry(K key); // 返回小于给定 key 的 entry，如果没有则返回 null
public Map.Entry<K, V> floorEntry(K key); // 返回小于等于给定 key 的 entry，如果没有则返回 null
public Map.Entry<K, V> ceilingEntry(K key); // 返回大于等于给定 key 的 entry，如果没有则返回 null
public Map.Entry<K, V> higherEntry(K key); // 返回大于给定 key 的 entry，如果没有则返回 null

public K lowerKey(K key); // 返回小于给定 key 的 key，如果没有则返回 null
public K floorKey(K key); // 返回小于等于给定 key 的 key，如果没有则返回 null
public K ceilingKey(K key); // 返回大于等于给定 key 的 key，如果没有则返回 null
public K higherKey(K key); // 返回大于给定 key 的 key，如果没有则返回 null

public Map.Entry<K, V> firstEntry(); // 返回最小 key 所在的 entry，如果没有则返回 null
public Map.Entry<K, V> lastEntry(); // 返回最大 key 所在的 entry，如果没有则返回 null

public Map.Entry<K, V> pollFirstEntry(); // 移除最小 key 所在的 entry，如果没有则返回 null
public Map.Entry<K, V> pollLastEntry(); // 移除最大 key 所在的 entry，如果没有则返回 null

public NavigableMap<K, V> descendingMap(); // [逆向视图] 返回当前 map 的逆向视图
public NavigableMap<K, V> subMap(K fromKey, // [子 map 视图] 支持可选的所有操作
                                 boolean fromInclusive,
                                 K toKey,
                                 boolean toInclusive);
public NavigableMap<K, V> headMap(K toKey, boolean inclusive); // [子 map 视图] 支持可选的所有操作
public NavigableMap<K, V> tailMap(K fromKey, boolean inclusive); // [子 map 视图] 支持可选的所有操作

public NavigableSet<K> navigableKeySet(); // [key 视图(升序)] 该视图支持删除操作，但不支持添加操作
public NavigableSet<K> descendingKeySet(); // [key 视图(降序)] 该视图支持删除操作，但不支持添加操作

public SortedMap<K, V> subMap(K fromKey, K toKey); // [子 map 视图] 支持可选的所有操作
public SortedMap<K, V> headMap(K toKey); // [子 map 视图] 支持可选的所有操作
public SortedMap<K, V> tailMap(K fromKey); // [子 map 视图] 支持可选的所有操作
</script></code></pre>
<p>例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">import java.util.TreeMap;

public class Main {
    public static void main(String[] args) {
        TreeMap<Integer, Integer> map = new TreeMap<>(); // 默认升序
        for (int i = 0; i < 10; i++) {
            map.put(9 - i, 9 - i);
        }
        System.out.println(map);

        TreeMap<Integer, Integer> map2 = new TreeMap<>((n1, n2) -> n2 - n1); // 降序
        for (int i = 0; i < 10; i++) {
            map2.put(i, i);
        }
        System.out.println(map2);

        System.out.println(map.get(map.lowerKey(5))); // 4
        System.out.println(map.get(map.floorKey(5))); // 5
        System.out.println(map.get(map.higherKey(5))); // 6
        System.out.println(map.get(map.ceilingKey(5))); // 5
        System.out.println();
        System.out.println(map2.get(map2.lowerKey(5))); // 6
        System.out.println(map2.get(map2.floorKey(5))); // 5
        System.out.println(map2.get(map2.higherKey(5))); // 4
        System.out.println(map2.get(map2.ceilingKey(5))); // 5
    }
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [17:40:22] C:127
$ javac Main.java

# root @ arch in ~/work on git:master x [17:40:24]
$ java Main
{0=0, 1=1, 2=2, 3=3, 4=4, 5=5, 6=6, 7=7, 8=8, 9=9}
{9=9, 8=8, 7=7, 6=6, 5=5, 4=4, 3=3, 2=2, 1=1, 0=0}
4
5
6
5

6
5
4
5
</script></code></pre>
<h3 id="IdentityHashMap-类"><a href="#IdentityHashMap-类" class="headerlink" title="IdentityHashMap 类"></a>IdentityHashMap 类</h3><p>java.util.IdentityHashMap 与 HashMap 在数据结构上没有太大的差别。不同的是，HashMap 使用<code>k1 == null ? k2 == null : k1.equals(k2)</code>判断两个 key 是否”相等”，而 IdentityHashMap 则使用<code>k1 == k2</code>判断两个 key 是否”相等”。并且，HashMap 使用 key.hashCode() 来查找存储桶，而 IdentityHashMap 则使用 System.identityHashCode(key) 来查找存储桶。还有，HashMap 使用<strong>拉链法</strong>解决哈希冲突，而 IdentityHashMap 则使用<strong>线性探测法</strong>解决哈希冲突。此类的典型用途：<strong>序列化</strong>、<strong>深度拷贝</strong>、<strong>维护代理对象</strong>。IdentityHashMap 和 HashMap 一样，<strong>允许 null 键、null 值</strong>，并且不保证 entry 的遍历顺序与输入顺序一致，更不保证该顺序会一直不变（自动扩容的原因）。它与大多数集合类一样，是非线程安全的，如果需要额外的同步，请考虑使用 Collections 的<code>&lt;K, V&gt; Map&lt;K, V&gt; synchronizedMap(Map&lt;K, V&gt; m)</code>静态包装方法。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 构造函数 */
public IdentityHashMap(); // 期望大小 21
public IdentityHashMap(int expectedMaxSize); // 指定期望大小
public IdentityHashMap(Map<? extends K, ? extends V> m); // putAll()

/* 元素数量 */
public int size();
public void clear();
public boolean isEmpty();

/* 包含键/值 */
public boolean containsKey(Object key);
public boolean containsValue(Object value);

/* get/put/remove */
public V get(Object key);
public V put(K key, V value);
public void putAll(Map<? extends K, ? extends V> m);
public V remove(Object key);

/* key/value/entry 视图 */
public Set<K> keySet(); // 支持移除操作，不支持添加操作
public Collection<V> values(); // 支持移除操作，不支持添加操作
public Set<Map.Entry<K, V>> entrySet(); // 支持移除操作，不支持添加操作

/* Object 方法 */
public Object clone();
public int hashCode();
public boolean equals(Object o);
</script></code></pre>
<p>例子：</p>
<pre><code class="language-java line-numbers"><script type="text/plain">import java.util.IdentityHashMap;

public class Main {
    public static void main(String[] args) {
        IdentityHashMap<Integer, Integer> map = new IdentityHashMap<>();
        Integer[] array = {1, 2, 3, 100, 200, 300};
        for (Integer i : array) {
            map.put(i, i);
        }
        System.out.println(map);

        map.put(1, 11);
        map.put(2, 22);
        map.put(3, 33);
        System.out.println(map);

        map.put(100, 111);
        map.put(200, 222);
        map.put(300, 333);
        System.out.println(map);
    }
}
</script></code></pre>
<pre><code class="language-bash line-numbers"><script type="text/plain"># root @ arch in ~/work on git:master x [19:20:13]
$ javac Main.java

# root @ arch in ~/work on git:master x [19:20:34]
$ java Main
{1=1, 3=3, 300=300, 200=200, 100=100, 2=2}
{1=11, 3=33, 300=300, 200=200, 100=100, 2=22}
{1=11, 3=33, 300=333, 300=300, 200=200, 100=111, 200=222, 2=22}
</script></code></pre>
<p>Integer 自动装箱并非每次都是 new 一个新的 Integer 对象，自动装箱调用 Integer.valueOf() 方法；valueOf() 首先检查 int 是否在区间 [-128, 127]，如果是则返回已存在的 Integer 对象（如果有的话），否则 new 一个新的对象。</p>
<h3 id="WeakHashMap-类"><a href="#WeakHashMap-类" class="headerlink" title="WeakHashMap 类"></a>WeakHashMap 类</h3><p>java.util.WeakHashMap 与 HashMap 具有类似的性能特征，并且具有相同的初始容量和负载因子的效率参数，并且 WeakHashMap 也<strong>允许 null 键、null 值</strong>。它们之间最大的不同是，WeakHashMap 的 key 是<strong>弱键</strong>，即<strong>弱引用对象</strong>，如果 GC 线程发现一个对象只存在弱引用，则该对象随时都会被回收。</p>
<p>为了明白 WeakHashMap 的特性，必须先了解 Java 的四种引用类型：<br>1) <strong>强引用（StrongReference）</strong><br>一般情况下我们使用的都是强引用，如<code>Test t = new Test()</code>的 t 就是一个强引用</p>
<blockquote>
<p>当内存不足，JVM 宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会回收强引用对象来释放内存</p>
</blockquote>
<p>2) <strong>软引用（SoftReference）</strong></p>
<blockquote>
<p>如果一个对象只有软引用，则内存空间足够，GC 就不会回收它；如果内存空间不足了，就会回收这些对象的内存</p>
</blockquote>
<p>3) <strong>弱引用（WeakReference）</strong></p>
<blockquote>
<p>只具有弱引用的对象拥有更短暂的生命周期；在 GC 线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存</p>
</blockquote>
<p>4) <strong>虚引用（PhantomReference）</strong></p>
<blockquote>
<p>虚引用主要用来跟踪对象被垃圾回收器回收的活动，虚引用必须和<code>引用队列（ReferenceQueue）</code>联合使用</p>
</blockquote>
<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期；如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。</p>
<blockquote>
<p>除了强引用之外，其他三种引用都在 java.lang.ref 包中。</p>
</blockquote>
<p>这里解释一下<strong>引用队列（ReferenceQueue）</strong>：</p>
<p>如果我们在创建一个引用对象时，指定了 ReferenceQueue，那么当引用对象指向的对象达到合适的状态（根据引用类型不同而不同）时，GC 会把引用对象本身添加到这个队列中，方便我们处理它；因为引用对象指向的对象 GC 会自动清理，但是引用对象本身也是对象（是对象就占用一定资源），所以需要我们自己清理。</p>
<p>举个例子：<code>SoftReference&lt;String&gt; ss = new SoftReference&lt;String&gt;(&quot;abc&quot;, queue)</code><br>其中，ss 是一个引用对象（一个普通的对象，本身是强引用），指向<code>&quot;abc&quot;</code>对象（该对象只有一个软引用 ss 指向它）；<code>&quot;abc&quot;</code>对象会在一定时机被 GC 自动清理，但是 ss 对象本身的清理工作依赖于 queue，当 ss 出现在 queue 中时，说明其指向的对象已经无效，可以放心清理 ss 了。</p>
<p><strong>引用对象的四种状态</strong><br>每一时刻，Reference 对象都处于下面四种状态中：<br>1) <code>Active</code>：”活动状态”，新创建的引用对象都是这个状态，GC 会根据引用对象是否在创建时指定 ReferenceQueue 参数进行状态转移，如果指定了，那么转移到 Pending 状态，如果没指定，转移到 Inactive 状态；<br>2) <code>Pending</code>：”待定状态”，该状态的引用对象等着被内部线程 ReferenceHandler 处理（会调用 ReferenceQueue.enqueue 方法）<br>3) <code>Enqueued</code>：”入队状态”，调用 ReferenceQueue.enqueued 方法后的引用对象处于这个状态中；<br>4) <code>Inactive</code>：”死亡状态”，处于该状态的引用对象将被 GC 自动清理。<br><img src="/images/java-collection-weakref.png" alt="java.lang.ref 引用对象的四种状态"></p>
<p>总之，我们目前只需要知道以下两点就可以了：</p>
<blockquote>
<p>如果构造函数中指定了 ReferenceQueue，那么引用对象需手动进行清理；<br>如果构造函数中没有指定 ReferenceQueue，那么 GC 会自动清理引用对象。</p>
</blockquote>
<p><strong>软引用、弱引用的应用场景</strong><br>软引用/弱引用都可用来实现内存敏感的高速缓存；通常和引用队列联合使用，如果引用对象所引用的对象被 GC 回收，Java 虚拟机就会把这个引用对象加入到与之关联的引用队列中，方便我们进行后需清理工作。</p>
<p>它们的区别是：软引用的生命周期比弱引用的生命周期更长一些，因为软引用只有在内存不足时才会进行垃圾回收，而弱引用随时都可能被 GC 回收。</p>
<p>WeakHashMap 和 HashMap 最主要的区别就在于 Entry 类，WeakHashMap 的 Entry 是 java.lang.ref.WeakReference 的子类，内部将 key 作为弱引用对象。</p>
<p><strong>主要方法</strong></p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 构造方法 */
public WeakHashMap(int initialCapacity, float loadFactor);
public WeakHashMap(int initialCapacity); // loadFactor = 0.75F
public WeakHashMap(); // initialCapacity = 16、loadFactor = 0.75F
public WeakHashMap(Map<? extends K, ? extends V> m); // loadFactor = 0.75F

/* 成员方法 */
public int size();
public void clear();
public boolean isEmpty();

public boolean containsKey(Object key);
public boolean containsValue(Object value);

public V get(Object key);
public V put(K key, V value);
public void putAll(Map<? extends K, ? extends V> m);
public V remove(Object key);

public Set<K> keySet();
public Collection<V> values();
public Set<Map.Entry<K, V>> entrySet();
</script></code></pre>
<h3 id="EnumMap-类"><a href="#EnumMap-类" class="headerlink" title="EnumMap 类"></a>EnumMap 类</h3><p>java.util.EnumMap 是枚举类型 key 专用的 Map，EnumMap 中的 key 必须来自同一个 Enum 枚举类，<strong>不允许 null 键，允许 null 值</strong>，但测试是否存在 null 键或者移除 null 键会正常工作。因为枚举常量的 ordinal() 值是不变的，所以 EnumMap 直接使用了 Object[] 数组来存储 values，而 key 根本不需要存储，key 可以根据传入的枚举类的 Class 对象获取。因为在内部是使用数组实现的，因此 EnumMap 的效率比普通的 Map 高。它与大多数集合类一样，是非线程安全的，如果需要额外的同步，请使用 Collections 的<code>&lt;K, V&gt; Map&lt;K, V&gt; synchronizedMap(Map&lt;K, V&gt; m)</code>静态包装方法。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">public EnumMap(Class<K> keyType); // 需要传入 key 的 Class 对象
public EnumMap(EnumMap<K, ? extends V> m); // 拷贝构造
public EnumMap(Map<K, ? extends V> m); // 从其他 map 获取 entry

public int size(); // 元素个数
public void clear(); // 清空
public boolean isEmpty(); // 判空

public boolean containsKey(Object key); // 是否包含指定 key
public boolean containsValue(Object value); // 是否包含指定 value

public V get(Object key); // get 指定 value
public V put(K key, V value); // put 指定 key-value
public void putAll(Map<? extends K, ? extends V> m); // put all
public V remove(Object key); // remove 指定 key-value

public Set<K> keySet(); // key 视图
public Collection<V> values(); // value 视图
public Set<Map.Entry<K,V>> entrySet(); // entry 视图

public EnumMap<K, V> clone();

public int hashCode();
public boolean equals(Object o);
</script></code></pre>
<h2 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h2><p>HashSet、LinkedHashSet、TreeSet 都是其对应 Map 的一个包装类；它们底层都是使用对应的 Map 存储元素，因此相关特性也和底层容器一样。在 Set 中的”元素”其实就是 Map 中的 key，而 value 部分则使用一个<code>static final Object PRESENT = new Object()</code>占位。</p>
<h3 id="Set-接口"><a href="#Set-接口" class="headerlink" title="Set 接口"></a>Set 接口</h3><pre><code class="language-java line-numbers"><script type="text/plain">/* 集合大小 */
int size(); // 元素数量
void clear(); // 清空集合
boolean isEmpty(); // 是否为空

/* 元素数组 */
Object[] toArray(); // 由所有元素组成的数组
<T> T[] toArray(T[] a); // 由所有元素组成的数组

/* 迭代器 */
Iterator<E> iterator(); // 迭代器
default Spliterator<E> spliterator(); // 可分割迭代器

/* 添加/移除/测试 */
boolean add(E e); // 添加元素
boolean remove(Object o); // 移除元素
boolean contains(Object o); // 是否包含给定元素

/* 子集/并集/交集/补集 */
boolean containsAll(Collection<?> c); // [子集] 当前集合是否包含给定集合的所有元素
boolean addAll(Collection<? extends E> c); // [并集] 将给定集合的所有元素添加到此集合
boolean retainAll(Collection<?> c); // [交集] 仅保留此集合中包含在给定集合中的元素
boolean removeAll(Collection<?> c); // [补集] 仅保留此集合中未包含在给定集合中的元素

/* Object */
int hashCode();
boolean equals(Object o);
</script></code></pre>
<h3 id="SortedSet-接口"><a href="#SortedSet-接口" class="headerlink" title="SortedSet 接口"></a>SortedSet 接口</h3><pre><code class="language-java line-numbers"><script type="text/plain">Comparator<? super E> comparator(); // 获取使用的比较器，如果为自然排序则为 null

SortedSet<E> subSet(E fromElement, E toElement); // [子 set 视图] 支持所有可选操作
SortedSet<E> headSet(E toElement); // [子 set 视图] 支持所有可选操作
SortedSet<E> tailSet(E fromElement); // [子 set 视图] 支持所有可选操作

E first(); // 第一个元素
E last(); // 最后一个元素
</script></code></pre>
<h3 id="NavigableSet-接口"><a href="#NavigableSet-接口" class="headerlink" title="NavigableSet 接口"></a>NavigableSet 接口</h3><pre><code class="language-java line-numbers"><script type="text/plain">E lower(E e); // 小于
E floor(E e); // 小于等于
E ceiling(E e); // 大于等于
E higher(E e); // 大于

E pollFirst(); // 删除第一个元素
E pollLast(); // 删除最后一个元素

NavigableSet<E> descendingSet(); // [反向 set 视图]
Iterator<E> descendingIterator(); // 反向 set 迭代器

NavigableSet<E> subSet(E fromElement, // [子 set 视图] 支持所有可选操作
                       boolean fromInclusive,
                       E toElement,
                       boolean toInclusive);
NavigableSet<E> headSet(E toElement, // [子 set 视图] 支持所有可选操作
                        boolean inclusive);
NavigableSet<E> tailSet(E fromElement, // [子 set 视图] 支持所有可选操作
                        boolean inclusive);

SortedSet<E> subSet(E fromElement, // [子 set 视图] 支持所有可选操作
                    E toElement);
SortedSet<E> headSet(E toElement); // [子 set 视图] 支持所有可选操作
SortedSet<E> tailSet(E fromElement); // [子 set 视图] 支持所有可选操作
</script></code></pre>
<h3 id="HashSet-类"><a href="#HashSet-类" class="headerlink" title="HashSet 类"></a>HashSet 类</h3><p>java.util.HashSet 实现了 Set 接口，内部使用 HashMap 作为存储容器，因此，HashSet 也允许 null 元素。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 构造函数 */
public HashSet(int initialCapacity, float loadFactor);
public HashSet(int initialCapacity); // loadFactor = 0.75F
public HashSet(); // initialCapacity = 16、loadFactor = 0.75F
public HashSet(Collection<? extends E> c); // loadFactor = 0.75F

/* 集合大小 */
public int size(); // 元素数量
public void clear(); // 清空集合
public boolean isEmpty(); // 是否为空

/* 元素数组 */
public Object[] toArray(); // 由所有元素组成的数组
public <T> T[] toArray(T[] a); // 由所有元素组成的数组

/* 迭代器 */
public Iterator<E> iterator(); // 迭代器
public Spliterator<E> spliterator(); // 可分割迭代器

/* 添加/移除/测试 */
public boolean add(E e); // 添加元素
public boolean remove(Object o); // 移除元素
public boolean contains(Object o); // 是否包含给定元素

/* 子集/并集/交集/补集 */
public boolean containsAll(Collection<?> c); // [子集] 当前集合是否包含给定集合的所有元素
public boolean addAll(Collection<? extends E> c); // [并集] 将给定集合的所有元素添加到此集合
public boolean retainAll(Collection<?> c); // [交集] 仅保留此集合中包含在给定集合中的元素
public boolean removeAll(Collection<?> c); // [补集] 仅保留此集合中未包含在给定集合中的元素

/* Object */
public Object clone();
public int hashCode();
public boolean equals(Object o);
</script></code></pre>
<h3 id="LinkedHashSet-类"><a href="#LinkedHashSet-类" class="headerlink" title="LinkedHashSet 类"></a>LinkedHashSet 类</h3><p>java.util.LinkedHashSet 实现了 Set 接口，是 HashSet 的子类，它依旧使用 LinkedHashMap 作为存储容器。LinkedHashSet 与 HashSet 的区别是，LinkedHashSet 会记录元素的插入顺序，其原理是额外的维护了一个<strong>双向链表</strong>，因此相比 HashSet 有一定的性能损失。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">public LinkedHashSet(int initialCapacity, float loadFactor);
public LinkedHashSet(int initialCapacity); // 0.75F
public LinkedHashSet(); // 16、0.75F
public LinkedHashSet(Collection<? extends E> c); // 0.75F

/* 集合大小 */
public int size(); // 元素数量
public void clear(); // 清空集合
public boolean isEmpty(); // 是否为空

/* 元素数组 */
public Object[] toArray(); // 由所有元素组成的数组
public <T> T[] toArray(T[] a); // 由所有元素组成的数组

/* 迭代器 */
public Iterator<E> iterator(); // 迭代器
public Spliterator<E> spliterator(); // 可分割迭代器

/* 添加/移除/测试 */
public boolean add(E e); // 添加元素
public boolean remove(Object o); // 移除元素
public boolean contains(Object o); // 是否包含给定元素

/* 子集/并集/交集/补集 */
public boolean containsAll(Collection<?> c); // [子集] 当前集合是否包含给定集合的所有元素
public boolean addAll(Collection<? extends E> c); // [并集] 将给定集合的所有元素添加到此集合
public boolean retainAll(Collection<?> c); // [交集] 仅保留此集合中包含在给定集合中的元素
public boolean removeAll(Collection<?> c); // [补集] 仅保留此集合中未包含在给定集合中的元素

/* Object */
public Object clone();
public int hashCode();
public boolean equals(Object o);
</script></code></pre>
<h3 id="TreeSet-类"><a href="#TreeSet-类" class="headerlink" title="TreeSet 类"></a>TreeSet 类</h3><p>java.util.TreeSet 实现了 NavigableSet 接口，这意味着它支持一系列的导航方法，在内部，它也是使用 TreeMap 作为存储容器的。如果此 TreeSet 是自然排序的，则不允许 null 元素，如果此 TreeSet 是自定义排序的，并且传入的比较器允许 null 参数，则此 TreeSet 支持 null 元素，否则将抛出 NullPointerException 异常。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 构造函数 */
public TreeSet(); // 自然排序，元素必须实现 Comparable 接口
public TreeSet(Comparator<? super E> comparator); // 自定义排序，元素无需实现 Comparable 接口
public TreeSet(Collection<? extends E> c); // 自然排序，元素必须实现 Comparable 接口
public TreeSet(SortedSet<E> s); // 使用与给定 Set 相同的排序

/* java.util.Set 接口 */
/* 集合大小 */
public int size(); // 元素数量
public void clear(); // 清空集合
public boolean isEmpty(); // 是否为空

/* 元素数组 */
public Object[] toArray(); // 由所有元素组成的数组
public <T> T[] toArray(T[] a); // 由所有元素组成的数组

/* 迭代器 */
public Iterator<E> iterator(); // 迭代器
public Spliterator<E> spliterator(); // 可分割迭代器

/* 添加/移除/测试 */
public boolean add(E e); // 添加元素
public boolean remove(Object o); // 移除元素
public boolean contains(Object o); // 是否包含给定元素

/* 子集/并集/交集/补集 */
public boolean containsAll(Collection<?> c); // [子集] 当前集合是否包含给定集合的所有元素
public boolean addAll(Collection<? extends E> c); // [并集] 将给定集合的所有元素添加到此集合
public boolean retainAll(Collection<?> c); // [交集] 仅保留此集合中包含在给定集合中的元素
public boolean removeAll(Collection<?> c); // [补集] 仅保留此集合中未包含在给定集合中的元素

/* java.util.SortedSet 接口 */
public Comparator<? super E> comparator(); // 获取使用的比较器，如果为自然排序则为 null

public SortedSet<E> subSet(E fromElement, E toElement); // [子 set 视图] 支持所有可选操作
public SortedSet<E> headSet(E toElement); // [子 set 视图] 支持所有可选操作
public SortedSet<E> tailSet(E fromElement); // [子 set 视图] 支持所有可选操作

public E first(); // 第一个元素
public E last(); // 最后一个元素

/* java.util.NavigableSet 接口 */
public E lower(E e); // 小于
public E floor(E e); // 小于等于
public E ceiling(E e); // 大于等于
public E higher(E e); // 大于

public E pollFirst(); // 删除第一个元素
public E pollLast(); // 删除最后一个元素

public NavigableSet<E> descendingSet(); // [反向 set 视图]
public Iterator<E> descendingIterator(); // 反向 set 迭代器

public NavigableSet<E> subSet(E fromElement, // [子 set 视图] 支持所有可选操作
                              boolean fromInclusive,
                              E toElement,
                              boolean toInclusive);
public NavigableSet<E> headSet(E toElement, // [子 set 视图] 支持所有可选操作
                               boolean inclusive);
public NavigableSet<E> tailSet(E fromElement, // [子 set 视图] 支持所有可选操作
                               boolean inclusive);

/* Object */
public Object clone();
public int hashCode();
public boolean equals(Object o);
</script></code></pre>
<h3 id="EnumSet-抽象类"><a href="#EnumSet-抽象类" class="headerlink" title="EnumSet 抽象类"></a>EnumSet 抽象类</h3><p>java.util.EnumSet 是枚举类型的专用集合，该集合中的元素必须都来自同一个枚举类，EnumSet <strong>不允许 null 元素</strong>，但测试是否存在 null 元素或移除 null 元素会正常工作。EnumSet 并不是使用 EnumMap 存储元素的，而是使用了更加高效的实现 - <strong>位向量</strong>，它是一种极为高效的位运算操作，由于直接存储和操作都是 bit，因此 EnumSet 空间和时间性能都十分可观，足以媲美传统上基于 int 的“位标志”的运算。EnumSet 返回的迭代器是有序的，它根据枚举常量的 ordinal() 进行自然排序。EnumSet 是抽象类，它有两个实现类（实现类的访问权限是包权限，因此无法在外部直接访问）：RegularEnumSet、JumboEnumSet。EnumSet 抽象类提供了几个静态方法，用于创建这两个实现类的对象，具体使用谁由 EnumSet 内部决定。</p>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 静态方法 */
// 创建一个空 set 集合
public static <E extends Enum<E>> EnumSet<E> noneOf(Class<E> elementType);
// 创建一个包含所有枚举常量的 set 集合
public static <E extends Enum<E>> EnumSet<E> allOf(Class<E> elementType);
// 创建给定集合 s 的补集
public static <E extends Enum<E>> EnumSet<E> complementOf(EnumSet<E> s);

// 拷贝构造
public static <E extends Enum<E>> EnumSet<E> copyOf(EnumSet<E> s);
public static <E extends Enum<E>> EnumSet<E> copyOf(Collection<E> c);

// 创建一个包含指定元素的 set 集合
public static <E extends Enum<E>> EnumSet<E> of(E e);
public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2);
public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3);
public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3, E e4);
public static <E extends Enum<E>> EnumSet<E> of(E e1, E e2, E e3, E e4, E e5);
public static <E extends Enum<E>> EnumSet<E> of(E first, E... rest); // 可变参数(本质为数组)

// 指定范围，由枚举常量的 ordinal() 决定
public static <E extends Enum<E>> EnumSet<E> range(E from, E to);

/* java.util.Set 接口 */
/* 集合大小 */
public int size(); // 元素数量
public void clear(); // 清空集合
public boolean isEmpty(); // 是否为空

/* 元素数组 */
public Object[] toArray(); // 由所有元素组成的数组
public <T> T[] toArray(T[] a); // 由所有元素组成的数组

/* 迭代器 */
public Iterator<E> iterator(); // 迭代器
public Spliterator<E> spliterator(); // 可分割迭代器

/* 添加/移除/测试 */
public boolean add(E e); // 添加元素
public boolean remove(Object o); // 移除元素
public boolean contains(Object o); // 是否包含给定元素

/* 子集/并集/交集/补集 */
public boolean containsAll(Collection<?> c); // [子集] 当前集合是否包含给定集合的所有元素
public boolean addAll(Collection<? extends E> c); // [并集] 将给定集合的所有元素添加到此集合
public boolean retainAll(Collection<?> c); // [交集] 仅保留此集合中包含在给定集合中的元素
public boolean removeAll(Collection<?> c); // [补集] 仅保留此集合中未包含在给定集合中的元素

/* Object */
public Object clone();
public int hashCode();
public boolean equals(Object o);
</script></code></pre>
<h2 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h2><p>java.util.Collections 类是 Java 集合框架的一员，它提供了很多 static 方法服务于各集合对象；<br>比如：对集合元素的排序、取极值、批量拷贝、集合结构转换、循环移位以及匹配性检查等功能。</p>
<blockquote>
<p>因为 Collections 类的构造方法被声明为 private，因此无法进行对象的实例化。</p>
</blockquote>
<pre><code class="language-java line-numbers"><script type="text/plain">/* 静态字段 - 空 list/set/map */
public static final List EMPTY_LIST; // 不可变对象
public static final Set EMPTY_SET; // 不可变对象
public static final Map EMPTY_MAP; // 不可变对象

/* list 排序 */
// [自然排序] "稳定的"，即两个相同的元素的位置不会被改变
public static <T extends Comparable<? super T>> void sort(List<T> list);
// [自定义排序] "稳定的"，即两个相同的元素的位置不会被改变
public static <T> void sort(List<T> list, Comparator<? super T> c);

/* list 查找 */
// 传入的 list 必须是已排序的，如果 list 有多个相同的元素，则不能保证找到哪一个元素
// 如果该 list 实现了 RandomAccess 接口，如 ArrayList、Arrays.asList()，则时间复杂度为 log(n)
// 如果没有实现 RandomAccess 接口，则使用该 list 的迭代器进行，因此时间复杂度可能不等于 log(n)
public static <T> int binarySearch(List<? extends Comparable<? super T>> list, T key);
// 传入的 list 必须是已排序的（根据给定的比较器进行排序），否则查找的结果是不一定的
public static <T> int binarySearch(List<? extends T> list, T key, Comparator<? super T> c);

/* list 翻转 */
public static void reverse(List<?> list); // 颠倒给定 list 中的元素的顺序

/* list 随机排列 */
public static void shuffle(List<?> list);
public static void shuffle(List<?> list, Random rnd); // random 源

/* list 交换元素 */
public static void swap(List<?> list, int i, int j);

/* list 元素填充 */
public static <T> void fill(List<? super T> list, T obj); // 使用给定元素替换给定列表中的所有元素

/* list 拷贝 */
public static <T> void copy(List<? super T> dest, List<? extends T> src);

/* list 旋转 */
// 索引 i 处（i 的区间为 [0, list.size)）的元素被移动至 (i - distance) mod list.size() 位置
public static void rotate(List<?> list, int distance);

/* list 替换 */
public static <T> boolean replaceAll(List<T> list, T oldVal, T newVal);

/* list 查找子列表 */
public static int indexOfSubList(List<?> source, List<?> target); // 返回子列表首次出现的索引，或返回 -1
public static int lastIndexOfSubList(List<?> source, List<?> target); // 返回子列表最后一次出现的索引，或返回 -1

/* min、max 值 */
public static <T extends Object & Comparable<? super T>> T min(Collection<? extends T> coll);
public static <T> T min(Collection<? extends T> coll, Comparator<? super T> comp);

public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll);
public static <T> T max(Collection<? extends T> coll, Comparator<? super T> comp);

/* "不可修改"视图 */
public static <T> Collection<T> unmodifiableCollection(Collection<? extends T> c);
public static <T> List<T> unmodifiableList(List<? extends T> list);
public static <T> Set<T> unmodifiableSet(Set<? extends T> s);
public static <T> SortedSet<T> unmodifiableSortedSet(SortedSet<T> s);
public static <T> NavigableSet<T> unmodifiableNavigableSet(NavigableSet<T> s);
public static <K,V> Map<K,V> unmodifiableMap(Map<? extends K,? extends V> m);
public static <K,V> SortedMap<K,V> unmodifiableSortedMap(SortedMap<K,? extends V> m);
public static <K,V> NavigableMap<K,V> unmodifiableNavigableMap(NavigableMap<K,? extends V> m);

/* "线程安全"的集合对象，但"迭代器"操作仍需手动同步 */
public static <T> Collection<T> synchronizedCollection(Collection<T> c);
public static <T> List<T> synchronizedList(List<T> list);
public static <T> Set<T> synchronizedSet(Set<T> s);
public static <T> SortedSet<T> synchronizedSortedSet(SortedSet<T> s);
public static <T> NavigableSet<T> synchronizedNavigableSet(NavigableSet<T> s);
public static <K,V> Map<K,V> synchronizedMap(Map<K,V> m);
public static <K,V> SortedMap<K,V> synchronizedSortedMap(SortedMap<K,V> m);
public static <K,V> NavigableMap<K,V> synchronizedNavigableMap(NavigableMap<K,V> m);

/* "类型安全"视图，通常用于调试 */
public static <E> Collection<E> checkedCollection(Collection<E> c, Class<E> type);
public static <E> List<E> checkedList(List<E> list, Class<E> type);
public static <E> Queue<E> checkedQueue(Queue<E> queue, Class<E> type);
public static <E> Set<E> checkedSet(Set<E> s, Class<E> type);
public static <E> SortedSet<E> checkedSortedSet(SortedSet<E> s, Class<E> type);
public static <E> NavigableSet<E> checkedNavigableSet(NavigableSet<E> s, Class<E> type);
public static <K,V> Map<K,V> checkedMap(Map<K,V> m, Class<K> keyType, Class<V> valueType);
public static <K,V> SortedMap<K,V> checkedSortedMap(SortedMap<K,V> m, Class<K> keyType, Class<V> valueType);
public static <K,V> NavigableMap<K,V> checkedNavigableMap(NavigableMap<K,V> m, Class<K> keyType, Class<V> valueType);

/* 空迭代器 */
public static <T> Iterator<T> emptyIterator();
public static <T> ListIterator<T> emptyListIterator();
public static <T> Enumeration<T> emptyEnumeration();

/* 空集合(只读) */
public static final <T> List<T> emptyList();
public static final <T> Set<T> emptySet();
public static <E> SortedSet<E> emptySortedSet();
public static <E> NavigableSet<E> emptyNavigableSet();
public static final <K,V> Map<K,V> emptyMap();
public static final <K,V> SortedMap<K,V> emptySortedMap();
public static final <K,V> NavigableMap<K,V> emptyNavigableMap();

/* 单元素集合(只读) */
public static <T> List<T> singletonList(T o);
public static <T> Set<T> singleton(T o);
public static <K,V> Map<K,V> singletonMap(K key, V value);

/* N 个副本元素组成的 list (只读) */
public static <T> List<T> nCopies(int n, T o);

/* 反向顺序的比较器 */
public static <T> Comparator<T> reverseOrder(); // 自然顺序的反向顺序
public static <T> Comparator<T> reverseOrder(Comparator<T> cmp); // 给定顺序的反向顺序

/* 旧 API 兼容操作 */
public static <T> Enumeration<T> enumeration(Collection<T> c); // Collection -> Enumeration
public static <T> ArrayList<T> list(Enumeration<T> e); // Enumeration -> ArrayList

/* 统计集合中给定元素出现的次数 */
public static int frequency(Collection<?> c, Object o);

/* 如果两个集合没有共同元素则返回 true */
public static boolean disjoint(Collection<?> c1, Collection<?> c2);

/* addAll() 便利方法 */
public static <T> boolean addAll(Collection<? super T> c, T... elements);

/* 从给定 map 中创建 set 集合 */
public static <E> Set<E> newSetFromMap(Map<E, Boolean> map); // value 起到标记作用（boolean）

/* 返回 deque 的 stack 视图(LIFO) */
public static <T> Queue<T> asLifoQueue(Deque<T> deque);
</script></code></pre>
<h2 id="Collection-总结"><a href="#Collection-总结" class="headerlink" title="Collection 总结"></a>Collection 总结</h2><p>对于集合框架，仅仅学习怎么用是不够的，我们更应该学习它们的原理，毕竟<strong>数据结构与算法</strong>是逃避不了的。先抛开树（红黑树、AVL 树等）不说，线性表（顺序表、单链表、双链表）、队列、栈、数组查找、数组排序，这些最基本的是必须要会的！</p>
<blockquote>
<p>本节内容的所有源码（GitHub 仓库）：<a href="https://github.com/zfl9/java-collection" rel="external nofollow noopener noreferrer" target="_blank">Java Collection 框架的简单实现</a></p>
</blockquote>
<h3 id="List-接口-1"><a href="#List-接口-1" class="headerlink" title="List 接口"></a>List 接口</h3><p>“列表”，三个实现类：ArrayList（数组）、SLinkedList（单向链表）、DLinkedList（双向链表）</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.util.Iterator;
import java.util.function.Consumer;

public interface List<E> extends Iterable<E> {
    int size();
    boolean isEmpty();
    List<E> clear();

    E get(int index);
    E set(int index, E newElem);

    List<E> append(E elem);
    E pop();

    List<E> insert(int index, E elem);
    E delete(int index);

    boolean deleteFirst(E elem);
    boolean deleteLast(E elem);
    boolean deleteAll(E elem);

    int firstIndexOf(E elem);
    int lastIndexOf(E elem);
    boolean hasElem(E elem);

    E[] toArray();

    Iterator<E> iterator();
    void forEach(Consumer<? super E> action);
}
</script></code></pre>
<h3 id="ArrayList-类-1"><a href="#ArrayList-类-1" class="headerlink" title="ArrayList 类"></a>ArrayList 类</h3><p>“动态数组”，随机访问性能好，尾部插入删除方便，其它位置插入删除要移动元素，效率不高</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.lang.reflect.Array;
import java.util.Iterator;
import java.util.RandomAccess;
import java.util.function.Consumer;

public class ArrayList<E> implements List<E>, RandomAccess {
    private Object[] array = null;
    private int size = 0;

    private static final int DEFAULT_INIT_CAPACITY = 16;

    public ArrayList() {
        array = new Object[DEFAULT_INIT_CAPACITY];
    }
    public ArrayList(int initCapacity) {
        array = new Object[initCapacity];
    }
    private ArrayList(Object[] array) {
        this.array = array;
        size = array.length;
    }
    @SuppressWarnings("unchecked")
    public static <T> ArrayList<T> of(T... elems) {
        return new ArrayList<>(elems.clone());
    }

    public int size() {
        return size;
    }
    public int capacity() {
        return array.length;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    public ArrayList<E> clear() {
        for (int i = 0; i < size; i++)
            array[i] = null;
        size = 0;
        return this;
    }

    private void manualExpansion(int minCapacity) {
        if (minCapacity < size)
            return;
        Object[] newArr = new Object[minCapacity];
        for (int i = 0; i < size; i++)
            newArr[i] = array[i];
        array = newArr;
    }
    private void autoExpansion(int numOfAddElem) {
        if (size + numOfAddElem > array.length)
            manualExpansion(array.length * 2);
    }

    public ArrayList<E> ensureCapacity(int minCapacity) {
        if (minCapacity > array.length)
            manualExpansion(minCapacity);
        return this;
    }
    public ArrayList<E> trimToSize() {
        manualExpansion(size);
        return this;
    }

    @SuppressWarnings("unchecked")
    public E get(int index) {
        return (E) array[index];
    }
    public E set(int index, E newElem) {
        @SuppressWarnings("unchecked")
        E oldElem = (E) array[index];
        array[index] = newElem;
        return oldElem;
    }

    public ArrayList<E> append(E elem) {
        autoExpansion(1);
        array[size++] = elem;
        return this;
    }
    public E pop() {
        @SuppressWarnings("unchecked")
        E elem = (E) array[--size];
        array[size] = null;
        return elem;
    }

    public ArrayList<E> insert(int index, E elem) {
        autoExpansion(1);
        for (int i = size; i > index; i--)
            array[i] = array[i - 1];
        array[index] = elem;
        size++;
        return this;
    }
    public E delete(int index) {
        @SuppressWarnings("unchecked")
        E elem = (E) array[index];
        for (int i = index; i < size - 1; i++)
            array[i] = array[i + 1];
        array[--size] = null;
        return elem;
    }

    public boolean deleteFirst(E elem) {
        if (elem == null) {
            for (int i = 0; i < size; i++) {
                if (array[i] == null) {
                    delete(i);
                    return true;
                }
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (elem.equals(array[i])) {
                    delete(i);
                    return true;
                }
            }
        }
        return false;
    }
    public boolean deleteLast(E elem) {
        if (elem == null) {
            for (int i = size - 1; i >= 0; i--) {
                if (array[i] == null) {
                    delete(i);
                    return true;
                }
            }
        } else {
            for (int i = size - 1; i >= 0; i--) {
                if (elem.equals(array[i])) {
                    delete(i);
                    return true;
                }
            }
        }
        return false;
    }
    public boolean deleteAll(E elem) {
        boolean deleted = false;
        while (deleteFirst(elem)) deleted = true;
        return deleted;
    }

    public int firstIndexOf(E elem) {
        if (elem == null) {
            for (int i = 0; i < size; i++) {
                if (elem == array[i])
                    return i;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (elem.equals(array[i]))
                    return i;
            }
        }
        return -1;
    }
    public int lastIndexOf(E elem) {
        if (elem == null) {
            for (int i = size - 1; i >= 0; i--) {
                if (elem == array[i])
                    return i;
            }
        } else {
            for (int i = size - 1; i >= 0; i--) {
                if (elem.equals(array[i]))
                    return i;
            }
        }
        return -1;
    }
    public boolean hasElem(E elem) {
        return firstIndexOf(elem) != -1;
    }

    @SuppressWarnings("unchecked")
    public E[] toArray() {
        if (size == 0)
            return null;
        E[] elems = (E[]) Array.newInstance(array[0].getClass(), size);
        for (int i = 0; i < size; i++)
            elems[i] = (E) array[i];
        return elems;
    }

    @Override
    public String toString() {
        if (size == 0)
            return "[]";
        StringBuilder result = new StringBuilder("[");
        for (int i = 0; i < size; i++) {
            result.append(array[i]);
            if (i != size - 1)
                result.append(", ");
        }
        result.append("]");
        return result.toString();
    }
    public String toStringReverse() {
        if (size == 0)
            return "[]";
        StringBuilder result = new StringBuilder("[");
        for (int i = size - 1; i >= 0; i--) {
            result.append(array[i]);
            if (i != 0)
                result.append(", ");
        }
        result.append("]");
        return result.toString();
    }

    @Override
    public Iterator<E> iterator() {
        return new IteratorImpl();
    }
    @Override
    @SuppressWarnings("unchecked")
    public void forEach(Consumer<? super E> action) {
        for (int i = 0; i < size; i++)
            action.accept((E) array[i]);
    }
    private class IteratorImpl implements Iterator<E> {
        int cursor = 0;

        @Override
        public boolean hasNext() {
            return cursor < size;
        }

        @Override
        @SuppressWarnings("unchecked")
        public E next() {
            return (E) array[cursor++];
        }

        @Override
        public void remove() {
            delete(--cursor);
        }
    }
}
</script></code></pre>
<h3 id="SLinkedList-类"><a href="#SLinkedList-类" class="headerlink" title="SLinkedList 类"></a>SLinkedList 类</h3><p>“单向链表”，插入删除性能好，随机访问性能差，因为存在额外的指针域，因此占有的内存多一些</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.lang.reflect.Array;
import java.util.Iterator;
import java.util.function.Consumer;

public class SLinkedList<E> implements List<E> {
    static class Node<E> {
        E data = null;
        Node<E> next = null;

        Node() {}
        Node(E data) { this.data = data; }
        Node(E data, Node<E> next) { this.data = data; this.next = next; }
    }

    final Node<E> HEAD = new Node<>();
    Node<E> tail = HEAD;
    int size = 0;

    public SLinkedList() {}

    @SuppressWarnings("unchecked")
    public static <T> SLinkedList<T> of(T... elems) {
        SLinkedList<T> list = new SLinkedList<>();
        final Node<T> HEAD = list.HEAD;
        Node<T> tail = HEAD;
        for (int i = 0; i < elems.length; i++)
            tail = tail.next = new Node<T>(elems[i]);
        list.size = elems.length;
        list.tail = tail;
        return list;
    }

    public int size() {
        return size;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    public SLinkedList<E> clear() {
        HEAD.next = null;
        size = 0;
        return this;
    }

    public E get(int index) {
        if (index >= size || index < 0)
            throw new IndexOutOfBoundsException(String.valueOf(index));
        Node<E> node = HEAD;
        for (int i = 0; i <= index; i++, node = node.next);
        return node.data;
    }
    public E set(int index, E newElem) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(String.valueOf(index));
        Node<E> node = HEAD;
        for (int i = 0; i <= index; i++, node = node.next);
        E oldElem = node.data;
        node.data = newElem;
        return oldElem;
    }

    public SLinkedList<E> append(E elem) {
        tail = tail.next = new Node<E>(elem);
        size++;
        return this;
    }
    public E pop() {
        if (size == 0)
            throw new IndexOutOfBoundsException("list is empty");
        Node<E> node = HEAD;
        for (; node.next.next != null; node = node.next);
        E elem = node.next.data;
        node.next = null;
        size--;
        return elem;
    }

    public SLinkedList<E> insert(int index, E elem) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(String.valueOf(index));
        Node<E> node = HEAD;
        for (int i = 0; i < index; i++, node = node.next);
        node.next = new Node<E>(elem, node.next);
        size++;
        return this;
    }
    public E delete(int index) {
        if (index >= size || index < 0)
            throw new IndexOutOfBoundsException(String.valueOf(index));
        Node<E> node = HEAD;
        for (int i = 0; i < index; i++, node = node.next);
        E elem = node.next.data;
        node.next = node.next.next;
        size--;
        return elem;
    }

    public boolean deleteFirst(E elem) {
        if (size == 0)
            return false;
        if (elem == null) {
            for (Node<E> node = HEAD; node.next != null; node = node.next) {
                if (elem == node.next.data) {
                    node.next = node.next.next;
                    size--;
                    return true;
                }
            }
        } else {
            for (Node<E> node = HEAD; node.next != null; node = node.next) {
                if (elem.equals(node.next.data)) {
                    node.next = node.next.next;
                    size--;
                    return true;
                }
            }
        }
        return false;
    }
    public boolean deleteLast(E elem) {
        int lastIndex = -1;
        Node<E> node = HEAD.next;

        if (elem == null) {
            for (int i = 0; i < size; i++, node = node.next) {
                if (elem == node.data)
                    lastIndex = i;
            }
        } else {
            for (int i = 0; i < size; i++, node = node.next) {
                if (elem.equals(node.data))
                    lastIndex = i;
            }
        }

        if (lastIndex == -1)
            return false;

        node = HEAD;
        for (int i = 0; i < lastIndex; i++, node = node.next);
        node.next = node.next.next;
        size--;
        return true;
    }
    public boolean deleteAll(E elem) {
        boolean deleted = false;
        while (deleteFirst(elem)) deleted = true;
        return deleted;
    }

    public int firstIndexOf(E elem) {
        Node<E> node = HEAD;
        if (elem == null) {
            for (int i = 0; i < size; i++, node = node.next)
                if (elem == node.next.data) return i;
        } else {
            for (int i = 0; i < size; i++, node = node.next)
                if (elem.equals(node.next.data)) return i;
        }
        return -1;
    }
    public int lastIndexOf(E elem) {
        int lastIndex = -1;
        Node<E> node = HEAD;
        if (elem == null) {
            for (int i = 0; i < size; i++, node = node.next)
                if (elem == node.next.data) lastIndex = i;
        } else {
            for (int i = 0; i < size; i++, node = node.next)
                if (elem.equals(node.next.data)) lastIndex = i;
        }
        return lastIndex;
    }
    public boolean hasElem(E elem) {
        return firstIndexOf(elem) != -1;
    }

    public E[] toArray() {
        if (size == 0)
            return null;
        @SuppressWarnings("unchecked")
        E[] array = (E[]) Array.newInstance(HEAD.next.data.getClass(), size);
        int i = 0;
        for (Node<E> node = HEAD; node.next != null; node = node.next)
            array[i++] = node.next.data;
        return array;
    }

    @Override
    public String toString() {
        if (size == 0)
            return "[]";
        StringBuilder result = new StringBuilder("[");
        for (Node<E> node = HEAD; node.next != null; node = node.next) {
            result.append(node.next.data);
            if (node.next.next != null)
                result.append(", ");
        }
        return result.append("]").toString();
    }

    @Override
    public Iterator<E> iterator() {
        return new IteratorImpl();
    }
    @Override
    public void forEach(Consumer<? super E> action) {
        for (Node<E> node = HEAD; node.next != null; node = node.next)
            action.accept(node.next.data);
    }
    private class IteratorImpl implements Iterator<E> {
        Node<E> node = HEAD;

        @Override
        public boolean hasNext() {
            return node.next != null;
        }

        @Override
        public E next() {
            return (node = node.next).data;
        }
    }
}
</script></code></pre>
<h3 id="DLinkedList-类"><a href="#DLinkedList-类" class="headerlink" title="DLinkedList 类"></a>DLinkedList 类</h3><p>“双向链表”，插入删除性能好，随机访问性能差，因为存在额外的指针域，因此占有的内存多一些</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.lang.reflect.Array;
import java.util.Iterator;
import java.util.function.Consumer;

public class DLinkedList<E> implements List<E> {
    static class Node<E> {
        E data = null;
        Node<E> prev = null;
        Node<E> next = null;

        Node() {}
        Node(E data) { this.data = data; }
        Node(E data, Node<E> prev, Node<E> next) {
            this.data = data;
            this.prev = prev;
            this.next = next;
        }
    }

    final Node<E> HEAD = new Node<>();
    final Node<E> TAIL = new Node<>();
    int size = 0;

    {
        HEAD.next = TAIL;
        TAIL.prev = HEAD;
    }

    public DLinkedList() {}

    @SuppressWarnings("unchecked")
    public static <T> DLinkedList<T> of(T... elems) {
        DLinkedList<T> list = new DLinkedList<>();
        final Node<T> TAIL = list.TAIL;
        for (int i = 0; i < elems.length; i++) {
            TAIL.prev = new Node<T>(elems[i], TAIL.prev, TAIL);
            TAIL.prev.prev.next = TAIL.prev;
        }
        list.size = elems.length;
        return list;
    }

    public int size() {
        return size;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    public DLinkedList<E> clear() {
        HEAD.next = TAIL;
        TAIL.prev = HEAD;
        size = 0;
        return this;
    }

    public E get(int index) {
        if (index >= size || index < 0)
            throw new IndexOutOfBoundsException(String.valueOf(index));
        if (index <= size >> 1) {
            Node<E> node = HEAD.next;
            for (int i = 0; i < index; i++, node = node.next);
            return node.data;
        } else {
            Node<E> node = TAIL.prev;
            for (int i = size - 1; i > index; i--, node = node.prev);
            return node.data;
        }
    }
    public E set(int index, E newElem) {
        if (index >= size || index < 0)
            throw new IndexOutOfBoundsException(String.valueOf(index));
        if (index <= size >> 1) {
            Node<E> node = HEAD.next;
            for (int i = 0; i < index; i++, node = node.next);
            E oldElem = node.data;
            node.data = newElem;
            return oldElem;
        } else {
            Node<E> node = TAIL.prev;
            for (int i = size - 1; i > index; i--, node = node.prev);
            E oldElem = node.data;
            node.data = newElem;
            return oldElem;
        }
    }

    public DLinkedList<E> append(E elem) {
        TAIL.prev = new Node<E>(elem, TAIL.prev, TAIL);
        TAIL.prev.prev.next = TAIL.prev;
        size++;
        return this;
    }
    public E pop() {
        E elem = TAIL.prev.data;
        TAIL.prev = TAIL.prev.prev;
        TAIL.prev.next = TAIL;
        size--;
        return elem;
    }

    public DLinkedList<E> insert(int index, E elem) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(String.valueOf(index));
        if (index <= size >> 1) {
            Node<E> node = HEAD;
            for (int i = 0; i < index; i++, node = node.next);
            node.next = new Node<E>(elem, node, node.next);
            node.next.next.prev = node.next;
            size++;
            return this;
        } else {
            Node<E> node = TAIL;
            for (int i = size; i > index; i--, node = node.prev);
            node.prev = new Node<E>(elem, node.prev, node);
            node.prev.prev.next = node.prev;
            size++;
            return this;
        }
    }
    public E delete(int index) {
        if (index > size || index < 0)
            throw new IndexOutOfBoundsException(String.valueOf(index));
        if (index <= size >> 1) {
            Node<E> node = HEAD;
            for (int i = 0; i < index; i++, node = node.next);
            E elem = node.next.data;
            node.next = node.next.next;
            node.next.prev = node;
            size--;
            return elem;
        } else {
            Node<E> node = TAIL;
            for (int i = size - 1; i > index; i--, node = node.prev);
            E elem = node.prev.data;
            node.prev = node.prev.prev;
            node.prev.next = node;
            size--;
            return elem;
        }
    }

    public boolean deleteFirst(E elem) {
        if (elem == null) {
            for (Node<E> node = HEAD; node.next != TAIL; node = node.next) {
                if (elem == node.next.data) {
                    node.next = node.next.next;
                    node.next.prev = node;
                    size--;
                    return true;
                }
            }
        } else {
            for (Node<E> node = HEAD; node.next != TAIL; node = node.next) {
                if (elem.equals(node.next.data)) {
                    node.next = node.next.next;
                    node.next.prev = node;
                    size--;
                    return true;
                }
            }
        }
        return false;
    }
    public boolean deleteLast(E elem) {
        if (elem == null) {
            for (Node<E> node = TAIL; node.prev != HEAD; node = node.prev) {
                if (elem == node.prev.data) {
                    node.prev = node.prev.prev;
                    node.prev.next = node;
                    size--;
                    return true;
                }
            }
        } else {
            for (Node<E> node = TAIL; node.prev != HEAD; node = node.prev) {
                if (elem.equals(node.prev.data)) {
                    node.prev = node.prev.prev;
                    node.prev.next = node;
                    size--;
                    return true;
                }
            }
        }
        return false;
    }
    public boolean deleteAll(E elem) {
        boolean deleted = false;
        while (deleteFirst(elem)) deleted = true;
        return deleted;
    }

    public int firstIndexOf(E elem) {
        if (elem == null) {
            Node<E> node = HEAD.next;
            for (int i = 0; i < size; i++, node = node.next)
                if (elem == node.data) return i;
        } else {
            Node<E> node = HEAD.next;
            for (int i = 0; i < size; i++, node = node.next)
                if (elem.equals(node.data)) return i;
        }
        return -1;
    }
    public int lastIndexOf(E elem) {
        if (elem == null) {
            Node<E> node = TAIL.prev;
            for (int i = size - 1; i >= 0; i--, node = node.prev)
                if (elem == node.data) return i;
        } else {
            Node<E> node = TAIL.prev;
            for (int i = size - 1; i >= 0; i--, node = node.prev)
                if (elem.equals(node.data)) return i;
        }
        return -1;
    }
    public boolean hasElem(E elem) {
        return firstIndexOf(elem) != -1;
    }

    public E[] toArray() {
        if (size == 0)
            return null;
        @SuppressWarnings("unchecked")
        E[] array = (E[]) Array.newInstance(HEAD.next.data.getClass(), size);
        Node<E> node = HEAD.next;
        for (int i = 0; i < size; i++, node = node.next)
            array[i] = node.data;
        return array;
    }

    @Override
    public String toString() {
        if (size == 0)
            return "[]";
        StringBuilder result = new StringBuilder("[");
        for (Node<E> node = HEAD.next; node != TAIL; node = node.next) {
            result.append(node.data);
            if (node.next != TAIL)
                result.append(", ");
        }
        return result.append("]").toString();
    }
    public String toStringReverse() {
        if (size == 0)
            return "[]";
        StringBuilder result = new StringBuilder("[");
        for (Node<E> node = TAIL.prev; node != HEAD; node = node.prev) {
            result.append(node.data);
            if (node.prev != HEAD)
                result.append(", ");
        }
        return result.append("]").toString();
    }

    @Override
    public Iterator<E> iterator() {
        return new IteratorImpl();
    }
    @Override
    public void forEach(Consumer<? super E> action) {
        for (Node<E> node = HEAD.next; node != TAIL; node = node.next)
            action.accept(node.data);
    }
    private class IteratorImpl implements Iterator<E> {
        Node<E> node = HEAD.next;

        @Override
        public boolean hasNext() {
            return node != TAIL;
        }

        @Override
        public E next() {
            return (node = node.next).prev.data;
        }

        @Override
        public void remove() {
            node.prev = node.prev.prev;
            node.prev.next = node;
            size--;
        }
    }
}
</script></code></pre>
<h3 id="Queue-接口-1"><a href="#Queue-接口-1" class="headerlink" title="Queue 接口"></a>Queue 接口</h3><p>“队列”，FIFO（先进先出），实现类：ArrayQueue、SLinkedQueue、DLinkedQueue</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.util.Iterator;
import java.util.function.Consumer;

public interface Queue<E> extends Iterable<E> {
    int size();
    boolean isEmpty();
    Queue<E> clear();

    Queue<E> enqueue(E elem);
    E dequeue();
    E peek();

    boolean hasElem(E elem);
    E[] toArray();

    Iterator<E> iterator();
    void forEach(Consumer<? super E> action);
}
</script></code></pre>
<h3 id="ArrayQueue-类"><a href="#ArrayQueue-类" class="headerlink" title="ArrayQueue 类"></a>ArrayQueue 类</h3><p>“动态数组”</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.lang.reflect.Array;
import java.util.Iterator;
import java.util.function.Consumer;

public class ArrayQueue<E> implements Queue<E> {
    Object[] array = null;
    int size = 0;
    int head = -1;
    int tail = -1;
    static final int DEFAULT_INIT_CAPACITY = 16;

    public ArrayQueue() {
        array = new Object[DEFAULT_INIT_CAPACITY];
    }
    public ArrayQueue(int initCapacity) {
        array = new Object[initCapacity];
    }
    private ArrayQueue(Object[] array) {
        this.array = array;
        size = array.length;
        tail = size - 1;
    }
    @SuppressWarnings("unchecked")
    public static <T> ArrayQueue<T> of(T... elems) {
        return new ArrayQueue<>(elems.clone());
    }

    public int size() {
        return size;
    }
    public int capacity() {
        return array.length;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    public ArrayQueue<E> clear() {
        for (int i = 0; i < size; i++)
            array[(head + i + 1) % array.length] = null;
        size = 0;
        head = tail = -1;
        return this;
    }

    private void manualExpansion(int minCapacity) {
        if (minCapacity < size)
            return;
        Object[] newArray = new Object[minCapacity];
        for (int i = 0; i < size; i++)
            newArray[i] = array[(head + i + 1) % array.length];
        head = -1;
        tail = size - 1;
        array = newArray;
    }
    private void autoExpansion(int numOfAddElem) {
        if (size + numOfAddElem > array.length)
            manualExpansion(array.length * 2);
    }

    public ArrayQueue<E> ensureCapacity(int minCapacity) {
        if (minCapacity > array.length)
            manualExpansion(minCapacity);
        return this;
    }
    public ArrayQueue<E> trimToSize() {
        manualExpansion(size);
        return this;
    }

    public ArrayQueue<E> enqueue(E elem) {
        autoExpansion(1);
        tail = (tail + 1) % array.length;
        array[tail] = elem;
        size++;
        return this;
    }
    public E dequeue() {
        if (size == 0)
            throw new IllegalStateException("queue is empty");
        head = (head + 1) % array.length;
        @SuppressWarnings("unchecked")
        E elem = (E) array[head];
        array[head] = null;
        size--;
        return elem;
    }
    @SuppressWarnings("unchecked")
    public E peek() {
        if (size == 0)
            throw new IllegalStateException("queue is empty");
        return (E) array[(head + 1) % array.length];
    }

    public boolean hasElem(E elem) {
        if (elem == null) {
            for (int i = 0; i < size; i++) {
                if (elem == array[(head + i + 1) % array.length])
                    return true;
            }
        } else {
            for (int i = 0; i < size; i++) {
                if (elem.equals(array[(head + i + 1) % array.length]))
                    return true;
            }
        }
        return false;
    }

    @SuppressWarnings("unchecked")
    public E[] toArray() {
        if (size == 0)
            return null;
        E[] elems = (E[]) Array.newInstance(array[(head + 1) % array.length].getClass(), size);
        for (int i = 0; i < size; i++)
            elems[i] = (E) array[(head + i + 1) % array.length];
        return elems;
    }

    @Override
    public String toString() {
        if (size == 0)
            return "[]";
        StringBuilder result = new StringBuilder("[");
        for (int i = 0; i < size; i++) {
            result.append(array[(head + i + 1) % array.length]);
            if (i != size - 1)
                result.append(", ");
        }
        return result.append("]").toString();
    }

    @Override
    public Iterator<E> iterator() {
        return new IteratorImpl();
    }
    @Override
    @SuppressWarnings("unchecked")
    public void forEach(Consumer<? super E> action) {
        for (int i = 0; i < size; i++)
            action.accept((E) array[(head + i + 1) % array.length]);
    }
    private class IteratorImpl implements Iterator<E> {
        int cursor = 0;

        @Override
        public boolean hasNext() {
            return cursor < size;
        }

        @Override
        @SuppressWarnings("unchecked")
        public E next() {
            return (E) array[(head + ++cursor) % array.length];
        }
    }
}
</script></code></pre>
<h3 id="SLinkedQueue-类"><a href="#SLinkedQueue-类" class="headerlink" title="SLinkedQueue 类"></a>SLinkedQueue 类</h3><p>“单向链表”</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.util.Iterator;
import java.util.function.Consumer;

public class SLinkedQueue<E> implements Queue<E> {
    SLinkedList<E> queue;

    public SLinkedQueue() {
        queue = new SLinkedList<>();
    }
    private SLinkedQueue(SLinkedList<E> queue) {
        this.queue = queue;
    }
    @SuppressWarnings("unchecked")
    public static <T> SLinkedQueue<T> of(T... elems) {
        return new SLinkedQueue<>(SLinkedList.of(elems));
    }

    public int size() {
        return queue.size();
    }
    public boolean isEmpty() {
        return queue.isEmpty();
    }
    public SLinkedQueue<E> clear() {
        queue.clear();
        return this;
    }

    public SLinkedQueue<E> enqueue(E elem) {
        queue.append(elem);
        return this;
    }
    public E dequeue() {
        return queue.delete(0);
    }
    public E peek() {
        return queue.get(0);
    }

    public boolean hasElem(E elem) {
        return queue.hasElem(elem);
    }

    public E[] toArray() {
        return queue.toArray();
    }

    @Override
    public String toString() {
        return queue.toString();
    }

    @Override
    public Iterator<E> iterator() {
        return queue.iterator();
    }
    @Override
    public void forEach(Consumer<? super E> action) {
        queue.forEach(action);
    }
}
</script></code></pre>
<h3 id="DLinkedQueue-类"><a href="#DLinkedQueue-类" class="headerlink" title="DLinkedQueue 类"></a>DLinkedQueue 类</h3><p>“双向链表”</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.util.Iterator;
import java.util.function.Consumer;

public class DLinkedQueue<E> implements Queue<E> {
    DLinkedList<E> queue;

    public DLinkedQueue() {
        queue = new DLinkedList<>();
    }
    private DLinkedQueue(DLinkedList<E> queue) {
        this.queue = queue;
    }
    @SuppressWarnings("unchecked")
    public static <T> DLinkedQueue<T> of(T... elems) {
        return new DLinkedQueue<>(DLinkedList.of(elems));
    }

    public int size() {
        return queue.size();
    }
    public boolean isEmpty() {
        return queue.isEmpty();
    }
    public DLinkedQueue<E> clear() {
        queue.clear();
        return this;
    }

    public DLinkedQueue<E> enqueue(E elem) {
        queue.append(elem);
        return this;
    }
    public E dequeue() {
        return queue.delete(0);
    }
    public E peek() {
        return queue.get(0);
    }

    public boolean hasElem(E elem) {
        return queue.hasElem(elem);
    }

    public E[] toArray() {
        return queue.toArray();
    }

    @Override
    public String toString() {
        return queue.toString();
    }

    @Override
    public Iterator<E> iterator() {
        return queue.iterator();
    }
    @Override
    public void forEach(Consumer<? super E> action) {
        queue.forEach(action);
    }
}
</script></code></pre>
<h3 id="Stack-接口"><a href="#Stack-接口" class="headerlink" title="Stack 接口"></a>Stack 接口</h3><p>“栈”，LIFO（后进先出），实现类：ArrayStack、SLinkedStack、DLinkedStack</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.util.Iterator;
import java.util.function.Consumer;

public interface Stack<E> extends Iterable<E> {
    int size();
    boolean isEmpty();
    Stack<E> clear();

    Stack<E> push(E elem);
    E pop();
    E peek();

    boolean hasElem(E elem);
    E[] toArray();

    Iterator<E> iterator();
    void forEach(Consumer<? super E> action);
}
</script></code></pre>
<h3 id="ArrayStack-类"><a href="#ArrayStack-类" class="headerlink" title="ArrayStack 类"></a>ArrayStack 类</h3><p>“动态数组”</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.util.Iterator;
import java.util.function.Consumer;

public class ArrayStack<E> implements Stack<E> {
    ArrayList<E> stack;

    public ArrayStack() {
        stack = new ArrayList<>();
    }
    public ArrayStack(int initCapacity) {
        stack = new ArrayList<>(initCapacity);
    }
    private ArrayStack(ArrayList<E> stack) {
        this.stack = stack;
    }
    @SuppressWarnings("unchecked")
    public static <T> ArrayStack<T> of(T... elems) {
        return new ArrayStack<>(ArrayList.of(elems));
    }

    public int size() {
        return stack.size();
    }
    public int capacity() {
        return stack.capacity();
    }
    public boolean isEmpty() {
        return stack.isEmpty();
    }
    public ArrayStack<E> clear() {
        stack.clear();
        return this;
    }

    public ArrayStack<E> ensureCapacity(int minCapacity) {
        stack.ensureCapacity(minCapacity);
        return this;
    }
    public ArrayStack<E> trimToSize() {
        stack.trimToSize();
        return this;
    }

    public ArrayStack<E> push(E elem) {
        stack.append(elem);
        return this;
    }
    public E pop() {
        return stack.pop();
    }
    public E peek() {
        return stack.get(stack.size() - 1);
    }

    public boolean hasElem(E elem) {
        return stack.hasElem(elem);
    }

    public E[] toArray() {
        return stack.toArray();
    }

    @Override
    public String toString() {
        return stack.toString();
    }

    @Override
    public Iterator<E> iterator() {
        return stack.iterator();
    }
    @Override
    public void forEach(Consumer<? super E> action) {
        stack.forEach(action);
    }
}
</script></code></pre>
<h3 id="SLinkedStack-类"><a href="#SLinkedStack-类" class="headerlink" title="SLinkedStack 类"></a>SLinkedStack 类</h3><p>“单向链表”</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.util.Iterator;
import java.util.function.Consumer;

public class SLinkedStack<E> implements Stack<E> {
    SLinkedList<E> stack;

    public SLinkedStack() {
        stack = new SLinkedList<>();
    }
    private SLinkedStack(SLinkedList<E> stack) {
        this.stack = stack;
    }
    @SuppressWarnings("unchecked")
    public static <T> SLinkedStack<T> of(T... elems) {
        return new SLinkedStack<>(SLinkedList.of(elems));
    }

    public int size() {
        return stack.size();
    }
    public boolean isEmpty() {
        return stack.isEmpty();
    }
    public SLinkedStack<E> clear() {
        stack.clear();
        return this;
    }

    public SLinkedStack<E> push(E elem) {
        stack.insert(0, elem);
        return this;
    }
    public E pop() {
        return stack.delete(0);
    }
    public E peek() {
        return stack.get(0);
    }

    public boolean hasElem(E elem) {
        return stack.hasElem(elem);
    }

    public E[] toArray() {
        return stack.toArray();
    }

    @Override
    public String toString() {
        return stack.toString();
    }

    @Override
    public Iterator<E> iterator() {
        return stack.iterator();
    }
    @Override
    public void forEach(Consumer<? super E> action) {
        stack.forEach(action);
    }
}
</script></code></pre>
<h3 id="DLinkedStack-类"><a href="#DLinkedStack-类" class="headerlink" title="DLinkedStack 类"></a>DLinkedStack 类</h3><p>“双向链表”</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.util.Iterator;
import java.util.function.Consumer;

public class DLinkedStack<E> implements Stack<E> {
    DLinkedList<E> stack;

    public DLinkedStack() {
        stack = new DLinkedList<>();
    }
    private DLinkedStack(DLinkedList<E> stack) {
        this.stack = stack;
    }
    @SuppressWarnings("unchecked")
    public static <T> DLinkedStack<T> of(T... elems) {
        return new DLinkedStack<>(DLinkedList.of(elems));
    }

    public int size() {
        return stack.size();
    }
    public boolean isEmpty() {
        return stack.isEmpty();
    }
    public DLinkedStack<E> clear() {
        stack.clear();
        return this;
    }

    public DLinkedStack<E> push(E elem) {
        stack.insert(0, elem);
        return this;
    }
    public E pop() {
        return stack.delete(0);
    }
    public E peek() {
        return stack.get(0);
    }

    public boolean hasElem(E elem) {
        return stack.hasElem(elem);
    }

    public E[] toArray() {
        return stack.toArray();
    }

    @Override
    public String toString() {
        return stack.toString();
    }

    @Override
    public Iterator<E> iterator() {
        return stack.iterator();
    }
    @Override
    public void forEach(Consumer<? super E> action) {
        stack.forEach(action);
    }
}
</script></code></pre>
<h3 id="Set-接口-1"><a href="#Set-接口-1" class="headerlink" title="Set 接口"></a>Set 接口</h3><p>“集合”，保证元素的唯一性（hashCode()、equals() 方法判定）</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.util.Iterator;
import java.util.function.Consumer;

public interface Set<E> extends Iterable<E> {
    int size();
    boolean isEmpty();
    Set<E> clear();

    boolean add(E elem);
    boolean delete(E elem);
    boolean hasElem(E elem);

    boolean addAll(Set<? extends E> set);
    boolean deleteAll(Set<? extends E> set);
    boolean retainAll(Set<? super E> set);
    boolean containsAll(Set<? extends E> set);

    E[] toArray();

    Iterator<E> iterator();
    void forEach(Consumer<? super E> action);
}
</script></code></pre>
<h3 id="HashSet-类-1"><a href="#HashSet-类-1" class="headerlink" title="HashSet 类"></a>HashSet 类</h3><p>普通的哈希表，遍历的顺序不保证为插入的顺序，并且该顺序也不保证永恒不变（自动扩容）</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.lang.reflect.Array;
import java.util.Iterator;
import java.util.function.Consumer;

public class HashSet<E> implements Set<E> {
    static class Node<E> {
        final int hash;
        final E data;
        Node<E> next;

        Node(int hash, E data, Node<E> next) {
            this.hash = hash;
            this.data = data;
            this.next = next;
        }
    }

    Node<E>[] table;
    static final int DEFAULT_INIT_CAPACITY = 32;

    final float loadFactor;
    static final float DEFAULT_LOAD_FACTOR = 0.75F;

    int size;

    @SuppressWarnings({"rawtypes", "unchecked"})
    public HashSet(int initCapacity, float loadFactor) {
        table = (Node<E>[]) new Node[initCapacity];
        this.loadFactor = loadFactor;
    }
    public HashSet(int initCapacity) {
        this(initCapacity, DEFAULT_LOAD_FACTOR);
    }
    public HashSet() {
        this(DEFAULT_INIT_CAPACITY, DEFAULT_LOAD_FACTOR);
    }
    @SuppressWarnings("unchecked")
    public static <T> HashSet<T> of(T... elems) {
        HashSet<T> set = new HashSet<>((int) (elems.length / DEFAULT_LOAD_FACTOR) + 1);
        for (T elem : elems)
            set.add(elem);
        return set;
    }

    public int size() {
        return size;
    }
    public int capacity() {
        return table.length;
    }
    public float loadFactor() {
        return loadFactor;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    public HashSet<E> clear() {
        for (int i = 0; i < table.length; i++)
            table[i] = null;
        size = 0;
        return this;
    }

    static int hash(Object key) {
        return key == null ? 0 : key.hashCode();
    }
    static int indexFor(int hash, int length) {
        while (hash < 0) hash += length;
        return hash % length;
    }
    int indexFor(int hash) {
        return indexFor(hash, table.length);
    }

    void manualExpansion(int minCapacity) {
        if (minCapacity <= table.length)
            return;
        @SuppressWarnings({"rawtypes", "unchecked"})
        Node<E>[] newTable = (Node<E>[]) new Node[minCapacity];
        Node<E> node; int index;
        for (int i = 0; i < table.length; i++) {
            while(table[i] != null) {
                node = table[i];
                table[i] = node.next;
                index = indexFor(node.hash, minCapacity);
                node.next = newTable[index];
                newTable[index] = node;
            }
        }
        table = newTable;
    }
    void autoExpansion(int numOfAddElem) {
        if (size + numOfAddElem > table.length * loadFactor)
            manualExpansion(table.length * 2);
    }

    public HashSet<E> ensureCapacity(int minCapacity) {
        manualExpansion(minCapacity);
        return this;
    }

    public boolean add(E elem) {
        int hash = hash(elem);
        int index = indexFor(hash);
        for (Node<E> node = table[index]; node != null; node = node.next) {
            if (hash == node.hash && (elem == null ? elem == node.data : elem.equals(node.data)))
                return false;
        }
        autoExpansion(1);
        table[index] = new Node<E>(hash, elem, table[index]);
        size++;
        return true;
    }
    public boolean delete(E elem) {
        int hash = hash(elem);
        int index = indexFor(hash);
        if (table[index] == null)
            return false;
        if (hash == table[index].hash &&
            (elem == null ? elem == table[index].data : elem.equals(table[index].data))) {
            table[index] = table[index].next;
            size--;
            return true;
        } else {
            for (Node<E> node = table[index]; node.next != null; node = node.next) {
                if (hash == node.next.hash &&
                    (elem == null ? elem == node.next.data : elem.equals(node.next.data))) {
                    node.next = node.next.next;
                    size--;
                    return true;
                }
            }
        }
        return false;
    }
    public boolean hasElem(E elem) {
        int hash = hash(elem);
        int index = indexFor(hash);
        for (Node<E> node = table[index]; node != null; node = node.next) {
            if (hash == node.hash && (elem == null ? elem == node.data : elem.equals(node.data)))
                return true;
        }
        return false;
    }

    public boolean addAll(Set<? extends E> set) {
        boolean modified = false;
        for (E elem : set)
            if (add(elem))
                modified = true;
        return modified;
    }
    public boolean deleteAll(Set<? extends E> set) {
        boolean modified = false;
        for (E elem : set)
            if (delete(elem))
                modified = true;
        return modified;
    }
    public boolean retainAll(Set<? super E> set) {
        boolean modified = false;
        for (E elem : toArray()) {
            if (!set.hasElem(elem)) {
                delete(elem);
                modified = true;
            }
        }
        return modified;
    }
    public boolean containsAll(Set<? extends E> set) {
        for (E elem : set)
            if (!hasElem(elem))
                return false;
        return true;
    }

    public E[] toArray() {
        if (size == 0)
            return null;
        Node<E> node = null;
        outer: for (int i = 0; i < table.length; i++)
            for (node = table[i]; node != null; node = node.next)
                if (node.data != null) break outer;
        @SuppressWarnings("unchecked")
        E[] array = (E[]) Array.newInstance(node.data.getClass(), size);
        int index = 0;
        for (int i = 0; i < table.length; i++)
            for (node = table[i]; node != null; node = node.next)
                array[index++] = node.data;
        return array;
    }

    @Override
    public String toString() {
        if (size == 0)
            return "[]";
        StringBuilder result = new StringBuilder("[");
        Node<E> node; int cnt = 0;
        for (int i = 0; i < table.length; i++) {
            for (node = table[i]; node != null; node = node.next) {
                result.append(node.data);
                if (++cnt != size)
                    result.append(", ");
            }
        }
        return result.append("]").toString();
    }

    @Override
    public Iterator<E> iterator() {
        return new IteratorImpl();
    }
    @Override
    public void forEach(Consumer<? super E> action) {
        Node<E> node;
        for (int i = 0; i < table.length; i++)
            for (node = table[i]; node != null; node = node.next)
                action.accept(node.data);
    }
    class IteratorImpl implements Iterator<E> {
        E[] array = toArray();
        int index = 0;

        @Override
        public boolean hasNext() {
            return index < size;
        }

        @Override
        public E next() {
            return array[index++];
        }

        @Override
        public void remove() {
            delete(array[index - 1]);
            array[index - 1] = null;
        }
    }
}
</script></code></pre>
<h3 id="LinkedHashSet-类-1"><a href="#LinkedHashSet-类-1" class="headerlink" title="LinkedHashSet 类"></a>LinkedHashSet 类</h3><p>与 HashSet 不同的是，它可以维护元素的插入顺序，并且支持按照访问顺序动态的排列</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.lang.reflect.Array;
import java.util.Iterator;
import java.util.function.Consumer;

public class LinkedHashSet<E> implements Set<E> {
    static class Node<E> {
        final int hash;
        final E data;
        Node<E> next;
        Node<E> before, after;

        Node(int hash, E data, Node<E> next, Node<E> before, Node<E> after) {
            this.hash = hash;
            this.data = data;
            this.next = next;
            this.before = before;
            this.after = after;
        }
        Node(int hash, E data, Node<E> next) {
            this(hash, data, next, null, null);
        }
    }

    Node<E>[] table;
    static final int DEFAULT_INIT_CAPACITY = 32;

    final float loadFactor;
    static final float DEFAULT_LOAD_FACTOR = 0.75F;

    int size;

    final Node<E> HEAD = new Node<>(0, null, null);
    final Node<E> TAIL = new Node<>(0, null, null);
    {
        HEAD.after = TAIL;
        TAIL.before = HEAD;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public LinkedHashSet(int initCapacity, float loadFactor) {
        table = (Node<E>[]) new Node[initCapacity];
        this.loadFactor = loadFactor;
    }
    public LinkedHashSet(int initCapacity) {
        this(initCapacity, DEFAULT_LOAD_FACTOR);
    }
    public LinkedHashSet() {
        this(DEFAULT_INIT_CAPACITY, DEFAULT_LOAD_FACTOR);
    }
    @SuppressWarnings("unchecked")
    public static <T> LinkedHashSet<T> of(T... elems) {
        LinkedHashSet<T> set = new LinkedHashSet<>((int) (elems.length / DEFAULT_LOAD_FACTOR) + 1);
        for (T elem : elems)
            set.add(elem);
        return set;
    }

    public int size() {
        return size;
    }
    public int capacity() {
        return table.length;
    }
    public float loadFactor() {
        return loadFactor;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    public LinkedHashSet<E> clear() {
        for (int i = 0; i < table.length; i++)
            table[i] = null;
        HEAD.after = TAIL;
        TAIL.before = HEAD;
        size = 0;
        return this;
    }

    static int hash(Object key) {
        return key == null ? 0 : key.hashCode();
    }
    static int indexFor(int hash, int length) {
        while (hash < 0) hash += length;
        return hash % length;
    }
    int indexFor(int hash) {
        return indexFor(hash, table.length);
    }

    void manualExpansion(int minCapacity) {
        if (minCapacity <= table.length)
            return;
        @SuppressWarnings({"rawtypes", "unchecked"})
        Node<E>[] newTable = (Node<E>[]) new Node[minCapacity];
        Node<E> node; int index;
        for (int i = 0; i < table.length; i++) {
            while (table[i] != null) {
                node = table[i];
                table[i] = node.next;
                index = indexFor(node.hash, minCapacity);
                node.next = newTable[index];
                newTable[index] = node;
            }
        }
        table = newTable;
    }
    void autoExpansion(int numOfAddElem) {
        if (size + numOfAddElem > table.length * loadFactor)
            manualExpansion(table.length * 2);
    }

    public LinkedHashSet<E> ensureCapacity(int minCapacity) {
        manualExpansion(minCapacity);
        return this;
    }

    public boolean add(E elem) {
        int hash = hash(elem);
        int index = indexFor(hash);
        for (Node<E> node = table[index]; node != null; node = node.next)
            if (hash == node.hash && (elem == null ? elem == node.data : elem.equals(node.data)))
                return false;
        autoExpansion(1);
        table[index] = new Node<E>(hash, elem, table[index], TAIL.before, TAIL);
        TAIL.before = table[index];
        TAIL.before.before.after = TAIL.before;
        size++;
        return true;
    }
    public boolean delete(E elem) {
        int hash = hash(elem);
        int index = indexFor(hash);
        if (table[index] == null)
            return false;
        if (hash == table[index].hash &&
            (elem == null ? elem == table[index].data : elem.equals(table[index].data))) {
            table[index].before.after = table[index].after;
            table[index].after.before = table[index].before;
            table[index] = table[index].next;
            size--;
            return true;
        } else {
            for (Node<E> node = table[index]; node.next != null; node = node.next) {
                if (hash == node.next.hash &&
                    (elem == null ? elem == node.next.data : elem.equals(node.next.data))) {
                    node.next.before.after = node.next.after;
                    node.next.after.before = node.next.before;
                    node.next = node.next.next;
                    size--;
                    return true;
                }
            }
        }
        return false;
    }
    public boolean hasElem(E elem) {
        int hash = hash(elem);
        int index = indexFor(hash);
        for (Node<E> node = table[index]; node != null; node = node.next)
            if (hash == node.hash && (elem == null ? elem == node.data : elem.equals(node.data)))
                return true;
        return false;
    }

    public boolean addAll(Set<? extends E> set) {
        boolean modified = false;
        for (E elem : set)
            if (add(elem))
                modified = true;
        return modified;
    }
    public boolean deleteAll(Set<? extends E> set) {
        boolean modified = false;
        for (E elem : set)
            if (delete(elem))
                modified = true;
        return modified;
    }
    public boolean retainAll(Set<? super E> set) {
        boolean modified = false;
        for (E elem : toArray()) {
            if (!set.hasElem(elem)) {
                delete(elem);
                modified = true;
            }
        }
        return modified;
    }
    public boolean containsAll(Set<? extends E> set) {
        for (E elem : set)
            if (!hasElem(elem))
                return false;
        return true;
    }

    public E[] toArray() {
        if (size == 0)
            return null;
        @SuppressWarnings("unchecked")
        E[] array = (E[]) Array.newInstance(HEAD.after.data.getClass(), size);
        int index = 0;
        for (Node<E> node = HEAD.after; node != TAIL; node = node.after)
            array[index++] = node.data;
        return array;
    }

    @Override
    public String toString() {
        if (size == 0)
            return "[]";
        StringBuilder result = new StringBuilder("[");
        for (Node<E> node = HEAD.after; node != TAIL; node = node.after) {
            result.append(node.data);
            if (node.after != TAIL)
                result.append(", ");
        }
        return result.append("]").toString();
    }

    @Override
    public Iterator<E> iterator() {
        return new IteratorImpl();
    }
    @Override
    public void forEach(Consumer<? super E> action) {
        for (Node<E> node = HEAD.after; node != TAIL; node = node.after)
            action.accept(node.data);
    }
    class IteratorImpl implements Iterator<E> {
        Node<E> node = HEAD.after;

        @Override
        public boolean hasNext() {
            return node != TAIL;
        }

        @Override
        public E next() {
            return (node = node.after).before.data;
        }

        @Override
        public void remove() {
            delete(node.before.data);
        }
    }
}
</script></code></pre>
<h3 id="Map-接口-1"><a href="#Map-接口-1" class="headerlink" title="Map 接口"></a>Map 接口</h3><p>“映射”，保证 key 的唯一性（hashCode()、equals() 方法判定）</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.util.Iterator;
import java.util.function.BiConsumer;

public interface Map<K, V> extends Iterable<Map.Entry<K, V>> {
    interface Entry<K, V> {
        K getKey();
        V getValue();
        V setValue(V newValue);
    }

    int size();
    boolean isEmpty();
    Map<K, V> clear();

    V put(K key, V value);
    V get(K key);
    V delete(K key);

    boolean hasKey(K key);
    boolean hasValue(V value);

    K[] keys();
    V[] values();
    Map.Entry<K, V>[] entries();

    Iterator<Map.Entry<K, V>> iterator();
    void forEach(BiConsumer<? super K, ? super V> action);
}
</script></code></pre>
<h3 id="HashMap-类-1"><a href="#HashMap-类-1" class="headerlink" title="HashMap 类"></a>HashMap 类</h3><p>普通的哈希表，遍历的顺序不保证为插入的顺序，并且该顺序也不保证永恒不变（自动扩容）</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.lang.reflect.Array;
import java.util.Iterator;
import java.util.function.BiConsumer;

public class HashMap<K, V> implements Map<K, V> {
    static class Entry<K, V> implements Map.Entry<K, V> {
        final int hash;
        final K key;
        V value;
        Entry<K, V> next;

        Entry(int hash, K key, V value, Entry<K, V> next) {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
        }

        @Override
        public K getKey() {
            return key;
        }

        @Override
        public V getValue() {
            return value;
        }
        @Override
        public V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        @Override
        public String toString() {
            return key + " = " + value;
        }
    }

    Entry<K, V>[] table;
    static final int DEFAULT_INIT_CAPACITY = 32;

    final float loadFactor;
    static final float DEFAULT_LOAD_FACTOR = 0.75F;

    int size;

    @SuppressWarnings({"rawtypes", "unchecked"})
    public HashMap(int initCapacity, float loadFactor) {
        table = (Entry<K, V>[]) new Entry[initCapacity];
        this.loadFactor = loadFactor;
    }
    public HashMap(int initCapacity) {
        this(initCapacity, DEFAULT_LOAD_FACTOR);
    }
    public HashMap() {
        this(DEFAULT_INIT_CAPACITY, DEFAULT_LOAD_FACTOR);
    }

    public int size() {
        return size;
    }
    public int capacity() {
        return table.length;
    }
    public float loadFactor() {
        return loadFactor;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    public HashMap<K, V> clear() {
        for (int i = 0; i < table.length; i++)
            table[i] = null;
        size = 0;
        return this;
    }

    static int hash(Object key) {
        return key == null ? 0 : key.hashCode();
    }
    static int indexFor(int hash, int length) {
        while (hash < 0) hash += length;
        return hash % length;
    }
    int indexFor(int hash) {
        return indexFor(hash, table.length);
    }

    void manualExpansion(int minCapacity) {
        if (minCapacity <= table.length)
            return;
        @SuppressWarnings({"rawtypes", "unchecked"})
        Entry<K, V>[] newTable = (Entry<K, V>[]) new Entry[minCapacity];
        Entry<K, V> entry; int index;
        for (int i = 0; i < table.length; i++) {
            while (table[i] != null) {
                entry = table[i];
                table[i] = entry.next;
                index = indexFor(entry.hash, minCapacity);
                entry.next = newTable[index];
                newTable[index] = entry;
            }
        }
        table = newTable;
    }
    void autoExpansion(int numOfAddElem) {
        if (size + numOfAddElem > table.length * loadFactor)
            manualExpansion(table.length * 2);
    }

    public HashMap<K, V> ensureCapacity(int minCapacity) {
        manualExpansion(minCapacity);
        return this;
    }

    public V put(K key, V value) {
        int hash = hash(key);
        int index = indexFor(hash);
        for (Entry<K, V> entry = table[index]; entry != null; entry = entry.next) {
            if (hash == entry.hash && (key == null ? key == entry.key : key.equals(entry.key))) {
                V oldValue = entry.value;
                entry.value = value;
                return oldValue;
            }
        }
        autoExpansion(1);
        table[index] = new Entry<K, V>(hash, key, value, table[index]);
        size++;
        return null;
    }
    public V get(K key) {
        int hash = hash(key);
        int index = indexFor(hash);
        for (Entry<K, V> entry = table[index]; entry != null; entry = entry.next) {
            if (hash == entry.hash && (key == null ? key == entry.key : key.equals(entry.key)))
                return entry.value;
        }
        return null;
    }
    public V delete(K key) {
        int hash = hash(key);
        int index = indexFor(hash);
        if (table[index] == null)
            return null;
        if (hash == table[index].hash &&
            (key == null ? key == table[index].key : key.equals(table[index].key))) {
            V value = table[index].value;
            table[index] = table[index].next;
            size--;
            return value;
        } else {
            for (Entry<K, V> entry = table[index]; entry.next != null; entry = entry.next) {
                if (hash == entry.next.hash &&
                    (key == null ? key == entry.next.key : key.equals(entry.next.key))) {
                    V value = entry.next.value;
                    entry.next = entry.next.next;
                    size--;
                    return value;
                }
            }
        }
        return null;
    }

    public boolean hasKey(K key) {
        int hash = hash(key);
        int index = indexFor(hash);
        for (Entry<K, V> entry = table[index]; entry != null; entry = entry.next) {
            if (hash == entry.hash && (key == null ? key == entry.key : key.equals(entry.key)))
                return true;
        }
        return false;
    }
    public boolean hasValue(V value) {
        Entry<K, V> entry;
        for (int i = 0; i < table.length; i++) {
            for (entry = table[i]; entry != null; entry = entry.next) {
                if (value == null ? value == entry.value : value.equals(entry.value))
                    return true;
            }
        }
        return false;
    }

    public K[] keys() {
        if (size == 0)
            return null;
        Entry<K, V> entry = null;
        outer: for (int i = 0; i < table.length; i++) {
            for (entry = table[i]; entry != null; entry = entry.next)
                if (entry.key != null) break outer;
        }
        @SuppressWarnings("unchecked")
        K[] keys = (K[]) Array.newInstance(entry.key.getClass(), size);
        int index = 0;
        for (int i = 0; i < table.length; i++) {
            for (entry = table[i]; entry != null; entry = entry.next)
                keys[index++] = entry.key;
        }
        return keys;
    }
    public V[] values() {
        if (size == 0)
            return null;
        Entry<K, V> entry = null;
        outer: for (int i = 0; i < table.length; i++) {
            for (entry = table[i]; entry != null; entry = entry.next)
                if (entry.value != null) break outer;
        }
        @SuppressWarnings("unchecked")
        V[] values = (V[]) Array.newInstance(entry.value.getClass(), size);
        int index = 0;
        for (int i = 0; i < table.length; i++) {
            for (entry = table[i]; entry != null; entry = entry.next)
                values[index++] = entry.value;
        }
        return values;
    }
    public Entry<K, V>[] entries() {
        if (size == 0)
            return null;
        @SuppressWarnings({"rawtypes", "unchecked"})
        Entry<K, V> entries[] = (Entry<K, V>[]) new Entry[size], entry;
        int index = 0;
        for (int i = 0; i < table.length; i++) {
            for (entry = table[i]; entry != null; entry = entry.next)
                entries[index++] = entry;
        }
        return entries;
    }

    @Override
    public String toString() {
        if (size == 0)
            return "{}";
        StringBuilder result = new StringBuilder("{");
        Entry<K, V> entry; int cnt = 0;
        for (int i = 0; i < table.length; i++) {
            for (entry = table[i]; entry != null; entry = entry.next) {
                result.append(entry.key + " = " + entry.value);
                if (++cnt != size) result.append(", ");
            }
        }
        return result.append("}").toString();
    }

    @Override
    public Iterator<Map.Entry<K, V>> iterator() {
        return new IteratorImpl();
    }
    public void forEach(BiConsumer<? super K, ? super V> action) {
        Entry<K, V> entry;
        for (int i = 0; i < table.length; i++) {
            for (entry = table[i]; entry != null; entry = entry.next)
                action.accept(entry.key, entry.value);
        }
    }
    class IteratorImpl implements Iterator<Map.Entry<K, V>> {
        Entry<K, V>[] entries = entries();
        int cursor = 0;

        @Override
        public boolean hasNext() {
            return cursor < size;
        }

        @Override
        public Entry<K, V> next() {
            return entries[cursor++];
        }

        @Override
        public void remove() {
            delete(entries[cursor - 1].key);
            entries[cursor - 1] = null;
        }
    }
}
</script></code></pre>
<h3 id="LinkedHashMap-类-1"><a href="#LinkedHashMap-类-1" class="headerlink" title="LinkedHashMap 类"></a>LinkedHashMap 类</h3><p>与 HashMap 不同的是，它可以维护 entry 的插入顺序，并且支持按照访问顺序动态的排列</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.lang.reflect.Array;
import java.util.Iterator;
import java.util.function.BiConsumer;

public class LinkedHashMap<K, V> implements Map<K, V> {
    static class Entry<K, V> implements Map.Entry<K, V> {
        final int hash;
        final K key;
        V value;
        Entry<K, V> next;
        Entry<K, V> before, after;

        Entry(int hash, K key, V value, Entry<K, V> next,
              Entry<K, V> before, Entry<K, V> after)
        {
            this.hash = hash;
            this.key = key;
            this.value = value;
            this.next = next;
            this.before = before;
            this.after = after;
        }
        Entry(int hash, K key, V value, Entry<K, V> next) {
            this(hash, key, value, next, null, null);
        }

        @Override
        public K getKey() {
            return key;
        }

        @Override
        public V getValue() {
            return value;
        }
        @Override
        public V setValue(V newValue) {
            V oldValue = value;
            value = newValue;
            return oldValue;
        }

        @Override
        public String toString() {
            return key + " = " + value;
        }
    }

    Entry<K, V>[] table;
    static final int DEFAULT_INIT_CAPACITY = 32;

    final float loadFactor;
    static final float DEFAULT_LOAD_FACTOR = 0.75F;

    int size;

    final boolean accessOrder;
    final Entry<K, V> HEAD = new Entry<>(0, null, null, null);
    final Entry<K, V> TAIL = new Entry<>(0, null, null, null);

    {
        HEAD.after = TAIL;
        TAIL.before = HEAD;
    }

    @SuppressWarnings({"rawtypes", "unchecked"})
    public LinkedHashMap(int initCapacity, float loadFactor, boolean accessOrder) {
        table = (Entry<K, V>[]) new Entry[initCapacity];
        this.loadFactor = loadFactor;
        this.accessOrder = accessOrder;
    }
    public LinkedHashMap(int initCapacity, float loadFactor) {
        this(initCapacity, loadFactor, false);
    }
    public LinkedHashMap(int initCapacity, boolean accessOrder) {
        this(initCapacity, DEFAULT_LOAD_FACTOR, accessOrder);
    }
    public LinkedHashMap(int initCapacity) {
        this(initCapacity, DEFAULT_LOAD_FACTOR, false);
    }
    public LinkedHashMap(boolean accessOrder) {
        this(DEFAULT_INIT_CAPACITY, DEFAULT_LOAD_FACTOR, accessOrder);
    }
    public LinkedHashMap() {
        this(DEFAULT_INIT_CAPACITY, DEFAULT_LOAD_FACTOR, false);
    }

    public int size() {
        return size;
    }
    public int capacity() {
        return table.length;
    }
    public float loadFactor() {
        return loadFactor;
    }
    public boolean accessOrder() {
        return accessOrder;
    }
    public boolean isEmpty() {
        return size == 0;
    }
    public LinkedHashMap<K, V> clear() {
        for (int i = 0; i < table.length; i++)
            table[i] = null;
        HEAD.after = TAIL;
        TAIL.before = HEAD;
        size = 0;
        return this;
    }

    static int hash(Object key) {
        return key == null ? 0 : key.hashCode();
    }
    static int indexFor(int hash, int length) {
        while (hash < 0) hash += length;
        return hash % length;
    }
    int indexFor(int hash) {
        return indexFor(hash, table.length);
    }

    void manualExpansion(int minCapacity) {
        if (minCapacity <= table.length)
            return;
        @SuppressWarnings({"rawtypes", "unchecked"})
        Entry<K, V>[] newTable = (Entry<K, V>[]) new Entry[minCapacity];
        Entry<K, V> entry; int index;
        for (int i = 0; i < table.length; i++) {
            while (table[i] != null) {
                entry = table[i];
                table[i] = entry.next;
                index = indexFor(entry.hash, minCapacity);
                entry.next = newTable[index];
                newTable[index] = entry;
            }
        }
        table = newTable;
    }
    void autoExpansion(int numOfAddElem) {
        if (size + numOfAddElem > table.length * loadFactor)
            manualExpansion(table.length * 2);
    }

    public LinkedHashMap<K, V> ensureCapacity(int minCapacity) {
        manualExpansion(minCapacity);
        return this;
    }

    public V put(K key, V value) {
        int hash = hash(key);
        int index = indexFor(hash);
        for (Entry<K, V> entry = table[index]; entry != null; entry = entry.next) {
            if (hash == entry.hash && (key == null ? key == entry.key : key.equals(entry.key))) {
                V oldValue = entry.value;
                entry.value = value;
                if (accessOrder) {
                    entry.before.after = entry.after;
                    entry.after.before = entry.before;
                    entry.before = HEAD;
                    entry.after = HEAD.after;
                    HEAD.after = entry;
                    entry.after.before = entry;
                }
                return oldValue;
            }
        }
        autoExpansion(1);
        table[index] = new Entry<K, V>(hash, key, value, table[index], TAIL.before, TAIL);
        TAIL.before = table[index];
        TAIL.before.before.after = TAIL.before;
        size++;
        return null;
    }
    public V get(K key) {
        int hash = hash(key);
        int index = indexFor(hash);
        for (Entry<K, V> entry = table[index]; entry != null; entry = entry.next) {
            if (hash == entry.hash && (key == null ? key == entry.key : key.equals(entry.key))) {
                if (accessOrder) {
                    entry.before.after = entry.after;
                    entry.after.before = entry.before;
                    entry.before = HEAD;
                    entry.after = HEAD.after;
                    HEAD.after = entry;
                    entry.after.before = entry;
                }
                return entry.value;
            }
        }
        return null;
    }
    public V delete(K key) {
        int hash = hash(key);
        int index = indexFor(hash);
        if (table[index] == null)
            return null;
        if (hash == table[index].hash &&
            (key == null ? key == table[index].key : key.equals(table[index].key))) {
            table[index].before.after = table[index].after;
            table[index].after.before = table[index].before;
            V value = table[index].value;
            table[index] = table[index].next;
            size--;
            return value;
        } else {
            for (Entry<K, V> entry = table[index]; entry.next != null; entry = entry.next) {
                if (hash == entry.next.hash &&
                    (key == null ? key == entry.next.key : key.equals(entry.next.key))) {
                    entry.next.before.after = entry.next.after;
                    entry.next.after.before = entry.next.before;
                    V value = entry.next.value;
                    entry.next = entry.next.next;
                    size--;
                    return value;
                }
            }
        }
        return null;
    }

    public boolean hasKey(K key) {
        int hash = hash(key);
        int index = indexFor(hash);
        for (Entry<K, V> entry = table[index]; entry != null; entry = entry.next) {
            if (hash == entry.hash && (key == null ? key == entry.key : key.equals(entry.key)))
                return true;
        }
        return false;
    }
    public boolean hasValue(V value) {
        for (Entry<K, V> entry = HEAD.after; entry != TAIL; entry = entry.after) {
            if (value == null ? value == entry.value : value.equals(entry.value))
                return true;
        }
        return false;
    }

    public K[] keys() {
        if (size == 0)
            return null;
        @SuppressWarnings("unchecked")
        K[] keys = (K[]) Array.newInstance(HEAD.after.key.getClass(), size);
        int index = 0;
        for (Entry<K, V> entry = HEAD.after; entry != TAIL; entry = entry.after)
            keys[index++] = entry.key;
        return keys;
    }
    public V[] values() {
        if (size == 0)
            return null;
        @SuppressWarnings("unchecked")
        V[] values = (V[]) Array.newInstance(HEAD.after.value.getClass(), size);
        int index = 0;
        for (Entry<K, V> entry = HEAD.after; entry != TAIL; entry = entry.after)
            values[index++] = entry.value;
        return values;
    }
    public Entry<K, V>[] entries() {
        if (size == 0)
            return null;
        @SuppressWarnings({"rawtypes", "unchecked"})
        Entry<K, V>[] entries = (Entry<K, V>[]) new Entry[size];
        int index = 0;
        for (Entry<K, V> entry = HEAD.after; entry != TAIL; entry = entry.after)
            entries[index++] = entry;
        return entries;
    }

    @Override
    public String toString() {
        if (size == 0)
            return "{}";
        StringBuilder result = new StringBuilder("{");
        for (Entry<K, V> entry = HEAD.after; entry != TAIL; entry = entry.after) {
            result.append(entry.key + " = " + entry.value);
            if (entry.after != TAIL)
                result.append(", ");
        }
        return result.append("}").toString();
    }

    @Override
    public Iterator<Map.Entry<K, V>> iterator() {
        return new IteratorImpl();
    }
    public void forEach(BiConsumer<? super K, ? super V> action) {
        for (Entry<K, V> entry = HEAD.after; entry != TAIL; entry = entry.after)
            action.accept(entry.key, entry.value);
    }
    class IteratorImpl implements Iterator<Map.Entry<K, V>> {
        Entry<K, V> entry = HEAD.after;

        @Override
        public boolean hasNext() {
            return entry != TAIL;
        }

        @Override
        public Entry<K, V> next() {
            return (entry = entry.after).before;
        }

        @Override
        public void remove() {
            delete(entry.before.key);
        }
    }
}
</script></code></pre>
<h3 id="BinaryTree-类"><a href="#BinaryTree-类" class="headerlink" title="BinaryTree 类"></a>BinaryTree 类</h3><p>二叉树的相关遍历方法：先序遍历、中序遍历、后序遍历、层次遍历</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.util.Queue;
import java.util.Deque;
import java.util.ArrayDeque;

public class BinaryTree {
    static class Node {
        int data;
        Node left;
        Node right;

        Node() {}
        Node(int data) {
            this.data = data;
        }
        Node(int data, Node left, Node right) {
            this.data = data;
            this.left = left;
            this.right = right;
        }

        @Override
        public String toString() {
            return String.valueOf(data);
        }
    }

    final Node ROOT;

    public BinaryTree() {
        // 第一层
        ROOT = new Node(1);
        // 第二层
        ROOT.left = new Node(2);
        ROOT.right = new Node(3);
        // 第三层
        ROOT.left.left = new Node(4);
        ROOT.left.right = new Node(5);
        ROOT.right.left = new Node(6);
        ROOT.right.right = new Node(7);
    }

    public void preOrderRecursion() {
        preOrderRecursion(ROOT);
        System.out.println("\b\b ");
    }
    private static void preOrderRecursion(Node node) {
        if (node != null) {
            System.out.print(node + ", ");
            preOrderRecursion(node.left);
            preOrderRecursion(node.right);
        }
    }

    public void inOrderRecursion() {
        inOrderRecursion(ROOT);
        System.out.println("\b\b ");
    }
    private static void inOrderRecursion(Node node) {
        if (node != null) {
            inOrderRecursion(node.left);
            System.out.print(node + ", ");
            inOrderRecursion(node.right);
        }
    }

    public void postOrderRecursion() {
        postOrderRecursion(ROOT);
        System.out.println("\b\b ");
    }
    private static void postOrderRecursion(Node node) {
        if (node != null) {
            postOrderRecursion(node.left);
            postOrderRecursion(node.right);
            System.out.print(node + ", ");
        }
    }

    public void preOrderTraversal() {
        Deque<Node> stack = new ArrayDeque<>(3);
        Node node = ROOT;
        while (node != null || !stack.isEmpty()) {
            while (node != null) {
                System.out.print(node + ", ");
                stack.push(node);
                node = node.left;
            }
            if (!stack.isEmpty()) {
                node = stack.pop().right;
            }
        }
        System.out.println("\b\b ");
    }

    public void inOrderTraversal() {
        Deque<Node> stack = new ArrayDeque<>(3);
        Node node = ROOT;
        while (node != null || !stack.isEmpty()) {
            while (node != null) {
                stack.push(node);
                node = node.left;
            }
            if (!stack.isEmpty()) {
                node = stack.pop();
                System.out.print(node + ", ");
                node = node.right;
            }
        }
        System.out.println("\b\b ");
    }

    public void postOrderTraversal() {
        Deque<Node> stack = new ArrayDeque<>(3);
        Node node = ROOT;
        Node visited = null;
        while (node != null || !stack.isEmpty()) {
            while (node != null) {
                stack.push(node);
                node = node.left;
            }
            node = stack.peek();
            if (node.right == null || node.right == visited) {
                System.out.print(node + ", ");
                visited = node;
                stack.pop();
                node = null;
            } else {
                node = node.right;
            }
        }
        System.out.println("\b\b ");
    }

    public void levelOrder() {
        if (ROOT == null) {
            return;
        }
        Queue<Node> queue = new ArrayDeque<>(4);
        Node node = ROOT;
        queue.add(node);
        while (!queue.isEmpty()) {
            node = queue.remove();
            System.out.print(node + ", ");
            if (node.left != null) {
                queue.add(node.left);
            }
            if (node.right != null) {
                queue.add(node.right);
            }
        }
        System.out.println("\b\b ");
    }

    public static void main(String[] args) {
        BinaryTree tree = new BinaryTree();

        tree.preOrderRecursion();
        tree.preOrderTraversal();

        tree.inOrderRecursion();
        tree.inOrderTraversal();

        tree.postOrderRecursion();
        tree.postOrderTraversal();

        tree.levelOrder();
    }
}
</script></code></pre>
<h3 id="ArrayAlgorithm-类"><a href="#ArrayAlgorithm-类" class="headerlink" title="ArrayAlgorithm 类"></a>ArrayAlgorithm 类</h3><p>数组的相关算法：数组查找、数组排序、数组洗牌、数组翻转</p>
<pre><code class="language-java line-numbers"><script type="text/plain">package com.zfl9.collection;

import java.util.Random;
import java.util.Comparator;
import java.lang.reflect.Array;

public class ArrayAlgorithm {
    /* 线性查找 */
    public static <T>
        int linearSearch(T[] array, int from, int to, T key)
    {
        for (int i = from; i < to; i++)
            if (key == null ? key == array[i] : key.equals(array[i]))
                return i;
        return -1;
    }
    public static <T>
        int linearSearch(T[] array, T key)
    {
        return linearSearch(array, 0, array.length, key);
    }

    /* 二分查找(自然排序) */
    public static <T extends Comparable<? super T>>
        int binarySearch(T[] array, int from, int to, T key)
    {
        int low = from;
        int high = to - 1;
        int mid;
        int cmp;

        while (low <= high) {
            mid = (low + high) / 2;
            cmp = key.compareTo(array[mid]);

            if (cmp == 0)
                return mid;
            else if (cmp < 0)
                high = mid - 1;
            else
                low = mid + 1;
        }

        return -1;
    }
    public static <T extends Comparable<? super T>>
        int binarySearch(T[] array, T key)
    {
        return binarySearch(array, 0, array.length, key);
    }

    /* 二分查找(自定义排序) */
    public static <T>
        int binarySearch(T[] array, int from, int to, T key, Comparator<? super T> comp)
    {
        int low = from;
        int high = to - 1;
        int mid;
        int cmp;

        while (low <= high) {
            mid = (low + high) / 2;
            cmp = comp.compare(key, array[mid]);

            if (cmp == 0)
                return mid;
            else if (cmp < 0)
                high = mid - 1;
            else
                low = mid + 1;
        }

        return -1;
    }
    public static <T>
        int binarySearch(T[] array, T key, Comparator<? super T> comp)
    {
        return binarySearch(array, 0, array.length, key, comp);
    }

    /* 插入排序(自然排序) */
    public static <T extends Comparable<? super T>>
        T[] insertSort(T[] array, int from, int to)
    {
        T curVal;
        for (int i = from + 1, j; i < to; i++) {
            curVal = array[i];
            for (j = i - 1; j >= from && array[j].compareTo(curVal) > 0; j--)
                array[j + 1] = array[j];
            array[j + 1] = curVal;
        }
        return array;
    }
    public static <T extends Comparable<? super T>>
        T[] insertSort(T[] array)
    {
        return insertSort(array, 0, array.length);
    }

    /* 插入排序(自定义排序) */
    public static <T>
        T[] insertSort(T[] array, int from, int to, Comparator<? super T> comp)
    {
        T curVal;
        for (int i = from + 1, j; i < to; i++) {
            curVal = array[i];
            for (j = i - 1; j >= from && comp.compare(array[j], curVal) > 0; j--)
                array[j + 1] = array[j];
            array[j + 1] = curVal;
        }
        return array;
    }
    public static <T>
        T[] insertSort(T[] array, Comparator<? super T> comp)
    {
        return insertSort(array, 0, array.length, comp);
    }

    /* 希尔排序(自然排序) */
    public static <T extends Comparable<? super T>>
        T[] shellSort(T[] array, int from, int to)
    {
        T curVal; int i, j;
        for (int gap = (to - from) / 2; gap > 0; gap /= 2) { // 步长
            for (i = gap + from; i < to; i++) { // 插入排序
                curVal = array[i];
                for (j = i - gap; j >= from && array[j].compareTo(curVal) > 0; j -= gap)
                    array[j + gap] = array[j];
                array[j + gap] = curVal;
            }
        }
        return array;
    }
    public static <T extends Comparable<? super T>>
        T[] shellSort(T[] array)
    {
        return shellSort(array, 0, array.length);
    }

    /* 希尔排序(自定义排序) */
    public static <T>
        T[] shellSort(T[] array, int from, int to, Comparator<? super T> comp)
    {
        T curVal; int i, j;
        for (int gap = (to - from) / 2; gap > 0; gap /= 2) { // 步长, 初始值为 len / 2
            for (i = gap + from; i < to; i++) {
                curVal = array[i];
                for (j = i - gap; j >= from && comp.compare(array[j], curVal) > 0; j -= gap)
                    array[j + gap] = array[j];
                array[j + gap] = curVal;
            }
        }
        return array;
    }
    public static <T>
        T[] shellSort(T[] array, Comparator<? super T> comp)
    {
        return shellSort(array, 0, array.length, comp);
    }

    /* 选择排序(自然排序) */
    public static <T extends Comparable<? super T>>
        T[] selectSort(T[] array, int from, int to)
    {
        T tmp;
        for (int i = from, min, j; i < to - 1; i++) { // 存储极值的位置
            min = i;
            for (j = i + 1; j < to; j++) // 遍历剩余序列, 找出最小元素所在的位置
                if (array[j].compareTo(array[min]) < 0)
                    min = j;
            if (min != i) {
                tmp = array[i];
                array[i] = array[min];
                array[min] = tmp;
            }
        }
        return array;
    }
    public static <T extends Comparable<? super T>>
        T[] selectSort(T[] array)
    {
        return selectSort(array, 0, array.length);
    }

    /* 选择排序(自定义排序) */
    public static <T>
        T[] selectSort(T[] array, int from, int to, Comparator<? super T> comp)
    {
        T tmp;
        for (int i = from, j, min; i < to - 1; i++) { // 存放极值的位置
            min = i;
            for (j = i + 1; j < to; j++)
                if (comp.compare(array[j], array[min]) < 0)
                    min = j;
            if (min != i) {
                tmp = array[min];
                array[min] = array[i];
                array[i] = tmp;
            }
        }
        return array;
    }
    public static <T>
        T[] selectSort(T[] array, Comparator<? super T> comp)
    {
        return selectSort(array, 0, array.length, comp);
    }

    /* 堆排序(自然排序) */
    // 最大堆(max-heap)构造
    static <T extends Comparable<? super T>>
        void maxHeapBuild(T[] array, int index, int from, int to)
    {
        int parent = index;
        int child = 2 * parent + 1 - from; // left-child
        T tmp;

        while (child < to) {
            if (child + 1 < to && array[child + 1].compareTo(array[child]) > 0)
                child++; // right-child

            if (array[parent].compareTo(array[child]) >= 0) {
                return;
            } else {
                tmp = array[parent];
                array[parent] = array[child];
                array[child] = tmp;

                parent = child;
                child = 2 * parent + 1 - from;
            }
        }
    }
    // 最大堆(max-heap)调整
    static <T extends Comparable<? super T>>
        void maxHeapAdjust(T[] array, int from, int to)
    {
        int parent = from;
        int child = 2 * parent + 1 - from; // left-child
        T tmp;

        while (child < to) {
            if (child + 1 < to && array[child + 1].compareTo(array[child]) > 0)
                child++; // right-child

            if (array[parent].compareTo(array[child]) >= 0) {
                return;
            } else {
                tmp = array[parent];
                array[parent] = array[child];
                array[child] = tmp;

                parent = child;
                child = 2 * parent + 1 - from;
            }
        }
    }
    // 最大堆排序
    public static <T extends Comparable<? super T>>
        T[] heapSort(T[] array, int from, int to)
    {
        // 构造最大堆(从最后一个非叶结点开始, 从右往左, 从下到上, 依次进行堆调整)
        for (int i = (to - from) / 2 - 1 + from; i >= from; i--)
            maxHeapBuild(array, i, from, to);

        // 将堆顶元素与尾部元素交换, 接着进行堆调整, 重复此步骤, 直到只剩一个元素为止
        T tmp;
        for (int i = to - 1; i > from; i--) {
            // swap
            tmp = array[i];
            array[i] = array[from];
            array[from] = tmp;
            // 堆调整
            maxHeapAdjust(array, from, i);
        }

        return array;
    }
    public static <T extends Comparable<? super T>>
        T[] heapSort(T[] array)
    {
        return heapSort(array, 0, array.length);
    }

    /* 堆排序(自定义排序) */
    static <T>
        void maxHeapBuild(T[] array, int index, int from, int to, Comparator<? super T> comp)
    {
        int parent = index;
        int child = 2 * parent + 1 - from; // left-child

        T tmp;
        while (child < to) {
            if (child + 1 < to && comp.compare(array[child + 1], array[child]) > 0)
                child++; // right-child

            if (comp.compare(array[parent], array[child]) >= 0) {
                return;
            } else {
                tmp = array[parent];
                array[parent] = array[child];
                array[child] = tmp;

                parent = child;
                child = 2 * parent + 1 - from;
            }
        }
    }
    static <T>
        void maxHeapAdjust(T[] array, int from, int to, Comparator<? super T> comp)
    {
        int parent = from;
        int child = 2 * parent + 1 - from; // left-child

        T tmp;
        while (child < to) {
            if (child + 1 < to && comp.compare(array[child + 1], array[child]) > 0)
                child++; // right-child

            if (comp.compare(array[parent], array[child]) >= 0) {
                return;
            } else {
                tmp = array[parent];
                array[parent] = array[child];
                array[child] = tmp;

                parent = child;
                child = 2 * parent + 1 - from;
            }
        }
    }
    public static <T>
        T[] heapSort(T[] array, int from, int to, Comparator<? super T> comp)
    {
        // 构造最大堆
        for (int i = (to - from) / 2 - 1 + from; i >= from; i--)
            maxHeapBuild(array, i, from, to, comp);

        // 取出最大元素, 然后调整最大堆
        T tmp;
        for (int i = to - 1; i > from; i--) {
            tmp = array[i];
            array[i] = array[from];
            array[from] = tmp;

            maxHeapAdjust(array, from, i, comp);
        }

        return array;
    }
    public static <T>
        T[] heapSort(T[] array, Comparator<? super T> comp)
    {
        return heapSort(array, 0, array.length, comp);
    }

    /* 冒泡排序(自然排序) */
    public static <T extends Comparable<? super T>>
        T[] bubbleSort(T[] array, int from, int to)
    {
        boolean sorted; T tmp;
        for (int i = 0, j; i < to - from - 1; i++) { // 进行 len - 1 轮比较
            sorted = true; // 假设已排好序
            for (j = from; j < to - 1 - i; j++) { // 进行本轮比较
                if (array[j].compareTo(array[j + 1]) > 0) {
                    sorted = false;
                    tmp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = tmp;
                }
            }
            if (sorted)
                break;
        }
        return array;
    }
    public static <T extends Comparable<? super T>>
        T[] bubbleSort(T[] array)
    {
        return bubbleSort(array, 0, array.length);
    }

    /* 冒泡排序(自定义排序) */
    public static <T>
        T[] bubbleSort(T[] array, int from, int to, Comparator<? super T> comp)
    {
        boolean sorted; T tmp;
        for (int i = 0, j; i < to - from - 1; i++) { // 最多进行 len - 1 轮循环
            sorted = true; // 先假设已排序
            for (j = from; j < to - 1 - i; j++) {
                if (comp.compare(array[j], array[j + 1]) > 0) {
                    sorted = false;
                    tmp = array[j];
                    array[j] = array[j + 1];
                    array[j + 1] = tmp;
                }
            }
            if (sorted) // 如果假设成立, 则排序完成
                break;
        }
        return array;
    }
    public static <T>
        T[] bubbleSort(T[] array, Comparator<? super T> comp)
    {
        return bubbleSort(array, 0, array.length, comp);
    }

    /* 快速排序(自然排序) */
    // 原地分区(in-place)
    static <T extends Comparable<? super T>>
        int partition(T[] array, int left, int right)
    {
        // 选择 mid 元素为 pivot 基准元素
        int pivotInd = (left + right) / 2;
        T pivotVal = array[pivotInd];

        // 交换 pivotVal 和最后一个元素
        array[pivotInd] = array[right];
        array[right] = pivotVal;

        int storeInd = left; T tmp;
        for (int i = left; i < right; i++) {
            if (array[i].compareTo(pivotVal) <= 0) {
                if (i != storeInd) {
                    tmp = array[i];
                    array[i] = array[storeInd];
                    array[storeInd] = tmp;
                }
                storeInd++;
            }
        }
        array[right] = array[storeInd];
        array[storeInd] = pivotVal;

        return storeInd;
    }
    // 递归分区(recursive partition)
    static <T extends Comparable<? super T>>
        void qSort(T[] array, int left, int right)
    {
        if (left < right) {
            int storeInd = partition(array, left, right);
            qSort(array, left, storeInd - 1);
            qSort(array, storeInd + 1, right);
        }
    }
    // 快速排序(quick sort)
    public static <T extends Comparable<? super T>>
        T[] quickSort(T[] array, int from, int to)
    {
        qSort(array, from, to - 1);
        return array;
    }
    public static <T extends Comparable<? super T>>
        T[] quickSort(T[] array)
    {
        return quickSort(array, 0, array.length);
    }

    /* 快速排序(自定义排序) */
    static <T>
        int partition(T[] array, int left, int right, Comparator<? super T> comp)
    {
        // 中间位置作为 pivot
        int pivotInd = (left + right) / 2;
        T pivotVal = array[pivotInd];

        // 交换 array[pivotInd] 与 array[right]
        array[pivotInd] = array[right];
        array[right] = pivotVal;

        // 将"小于" pivotVal 的元素交换至序列"开头"
        int storeInd = left; T tmp;
        for (int i = left; i < right; i++) {
            if (comp.compare(array[i], pivotVal) <= 0) {
                if (storeInd != i) {
                    tmp = array[storeInd];
                    array[storeInd] = array[i];
                    array[i] = tmp;
                }
                storeInd++;
            }
        }
        // 将 pivotVal 放回正确(已排序)的位置
        array[right] = array[storeInd];
        array[storeInd] = pivotVal;

        return storeInd;
    }
    static <T>
        void qSort(T[] array, int left, int right, Comparator<? super T> comp)
    {
        if (left < right) { // 至少两个元素
            int storeInd = partition(array, left, right, comp);
            qSort(array, left, storeInd - 1, comp);
            qSort(array, storeInd + 1, right, comp);
        }
    }
    public static <T>
        T[] quickSort(T[] array, int from, int to, Comparator<? super T> comp)
    {
        qSort(array, from, to - 1, comp);
        return array;
    }
    public static <T>
        T[] quickSort(T[] array, Comparator<? super T> comp)
    {
        return quickSort(array, 0, array.length, comp);
    }

    /* 归并排序(自然排序) */
    static <T extends Comparable<? super T>>
        void mSort(T[] arr, int beg, int end, T[] tmp)
    {
        if (beg < end) { // 至少两个元素才进行分割
            // 递归分解
            int mid = (beg + end) / 2;
            mSort(arr, beg, mid, tmp);
            mSort(arr, mid + 1, end, tmp);

            // 合并两个有序的子序列
            int i = beg,        // 左子序列
                j = mid + 1,    // 右子序列
                k = 0;          // 临时序列
            // 比较左右子序列, 依次放入
            while (i <= mid && j <= end) {
                if (arr[i].compareTo(arr[j]) <= 0)
                    tmp[k++] = arr[i++];
                else
                    tmp[k++] = arr[j++];
            }
            // 剩余的序列元素直接放进去
            while (i <= mid)
                tmp[k++] = arr[i++];
            while (j <= end)
                tmp[k++] = arr[j++];
            // 最后将 tmp 数组的内容放回 arr
            for (int m = 0; m < k; m++)
                arr[beg + m] = tmp[m];
        }
    }
    public static <T extends Comparable<? super T>>
        T[] mergeSort(T[] array, int from, int to)
    {
        @SuppressWarnings("unchecked")
        T[] tmp = (T[]) Array.newInstance(array[from].getClass(), to - from);
        mSort(array, from, to - 1, tmp);
        return array;
    }
    public static <T extends Comparable<? super T>>
        T[] mergeSort(T[] array)
    {
        return mergeSort(array, 0, array.length);
    }

    /* 归并排序(自定义排序) */
    static <T>
        void mSort(T[] arr, int beg, int end, T[] tmp, Comparator<? super T> comp)
    {
        if (beg < end) { // 至少两个元素
            int mid = (beg + end) / 2;
            mSort(arr, beg, mid, tmp, comp);
            mSort(arr, mid + 1, end, tmp, comp);

            int i = beg,     // left
                j = mid + 1, // right
                k = 0;       // temp

            while (i <= mid && j <= end) {
                if (comp.compare(arr[i], arr[j]) <= 0)
                    tmp[k++] = arr[i++];
                else
                    tmp[k++] = arr[j++];
            }

            while (i <= mid)
                tmp[k++] = arr[i++];
            while (j <= end)
                tmp[k++] = arr[j++];

            for (int m = 0; m < k; m++)
                arr[beg + m] = tmp[m];
        }
    }
    public static <T>
        T[] mergeSort(T[] array, int from, int to, Comparator<? super T> comp)
    {
        @SuppressWarnings("unchecked")
        T[] tmp = (T[]) Array.newInstance(array[from].getClass(), to - from);
        mSort(array, from, to - 1, tmp, comp);
        return array;
    }
    public static <T>
        T[] mergeSort(T[] array, Comparator<? super T> comp)
    {
        return mergeSort(array, 0, array.length, comp);
    }

    /* 翻转数组 */
    public static <T>
        T[] reverse(T[] array, int from, int to)
    {
        int mid = (from + to) / 2; T tmp;
        for (int i = from, off = 0; i < mid; i++, off++) {
            tmp = array[i];
            array[i] = array[to - 1 - off];
            array[to - 1 - off] = tmp;
        }
        return array;
    }
    public static <T>
        T[] reverse(T[] array)
    {
        return reverse(array, 0, array.length);
    }

    /* 随机洗牌 */
    public static <T>
        T[] shuffle(T[] array, int from, int to)
    {
        Random rnd = new Random(); T tmp;
        for (int i = to - 1, j; i > from; i--) {
            j = rnd.nextInt(i + 1 - from) + from;
            if (j != i) {
                tmp = array[i];
                array[i] = array[j];
                array[j] = tmp;
            }
        }
        return array;
    }
    public static <T>
        T[] shuffle(T[] array)
    {
        return shuffle(array, 0, array.length);
    }
}
</script></code></pre>
    </div>
    <div>
    </div>
    <div>
    </div>
    <div>
    </div>
    <footer class="post-footer">
        <div class="post-tags">
            <a href="/tags/java/" rel="tag"># java</a>
        </div>
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
              <a href="/java-ref.html" rel="next" title="Java 4种引用类型">
                <i class="fa fa-chevron-left"></i> Java 4种引用类型
              </a>
          </div>
          <span class="post-nav-divider"></span>
          <div class="post-nav-prev post-nav-item">
              <a href="/java-jdk7-jdk8.html" rel="prev" title="Java7 Java8 新特性">
                Java7 Java8 新特性 <i class="fa fa-chevron-right"></i>
              </a>
          </div>
        </div>
    </footer>
  </article>
    <div class="post-spread">
    </div>
  </div>
          </div>
  <div class="comments" id="comments">
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="https://disqus.com/?ref_noscript" rel="external nofollow noopener noreferrer" target="_blank">comments powered by Disqus.</a>
        </noscript>
      </div>
  </div>
        </div>
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>
  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Otokaze">
          <p class="site-author-name" itemprop="name">Otokaze</p>
              <p class="site-description motion-element" itemprop="description"></p>
        </div>
        <nav class="site-state motion-element">
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">170</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
            <div class="site-state-item site-state-categories">
              <a href="/categories/index.html">
                <span class="site-state-item-count">43</span>
                <span class="site-state-item-name">分类</span>
              </a>
            </div>
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">46</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
        </nav>
        <div class="links-of-author motion-element">
              <span class="links-of-author-item">
                <a href="https://github.com/zfl9" target="_blank" title="GitHub rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-github"></i>
                  GitHub
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="mailto:zfl9.com@gmail.com" target="_blank" title="Email rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-envelope"></i>
                  Email
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://gitlab.com/zfl9" target="_blank" title="GitLab rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-gitlab"></i>
                  GitLab
                </a>
              </span>
              <span class="links-of-author-item">
                <a href="https://t.me/Otokaze" target="_blank" title="Telegram rel=" external="" nofollow""="" rel="external nofollow noopener noreferrer">
                    <i class="fa fa-fw fa-telegram"></i>
                  Telegram
                </a>
              </span>
        </div>
      </section>
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#集合框架"><span class="nav-number">1.</span> <span class="nav-text">集合框架</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#主要接口"><span class="nav-number">2.</span> <span class="nav-text">主要接口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterable-接口"><span class="nav-number">2.1.</span> <span class="nav-text">Iterable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Iterator-接口"><span class="nav-number">2.2.</span> <span class="nav-text">Iterator 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Collection-接口"><span class="nav-number">2.3.</span> <span class="nav-text">Collection 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comparable-接口"><span class="nav-number">2.4.</span> <span class="nav-text">Comparable 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comparator-接口"><span class="nav-number">2.5.</span> <span class="nav-text">Comparator 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Cloneable-接口"><span class="nav-number">2.6.</span> <span class="nav-text">Cloneable 接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#List-列表"><span class="nav-number">3.</span> <span class="nav-text">List 列表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List-接口"><span class="nav-number">3.1.</span> <span class="nav-text">List 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ListIterator-接口"><span class="nav-number">3.2.</span> <span class="nav-text">ListIterator 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-类"><span class="nav-number">3.3.</span> <span class="nav-text">ArrayList 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedList-类"><span class="nav-number">3.4.</span> <span class="nav-text">LinkedList 类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Queue-队列"><span class="nav-number">4.</span> <span class="nav-text">Queue 队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue-接口"><span class="nav-number">4.1.</span> <span class="nav-text">Queue 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Deque-接口"><span class="nav-number">4.2.</span> <span class="nav-text">Deque 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayDeque-类"><span class="nav-number">4.3.</span> <span class="nav-text">ArrayDeque 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#PriorityQueue-类"><span class="nav-number">4.4.</span> <span class="nav-text">PriorityQueue 类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Map-映射"><span class="nav-number">5.</span> <span class="nav-text">Map 映射</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-接口"><span class="nav-number">5.1.</span> <span class="nav-text">Map 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SortedMap-接口"><span class="nav-number">5.2.</span> <span class="nav-text">SortedMap 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NavigableMap-接口"><span class="nav-number">5.3.</span> <span class="nav-text">NavigableMap 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-类"><span class="nav-number">5.4.</span> <span class="nav-text">HashMap 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap-类"><span class="nav-number">5.5.</span> <span class="nav-text">LinkedHashMap 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeMap-类"><span class="nav-number">5.6.</span> <span class="nav-text">TreeMap 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IdentityHashMap-类"><span class="nav-number">5.7.</span> <span class="nav-text">IdentityHashMap 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#WeakHashMap-类"><span class="nav-number">5.8.</span> <span class="nav-text">WeakHashMap 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EnumMap-类"><span class="nav-number">5.9.</span> <span class="nav-text">EnumMap 类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Set-集合"><span class="nav-number">6.</span> <span class="nav-text">Set 集合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-接口"><span class="nav-number">6.1.</span> <span class="nav-text">Set 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SortedSet-接口"><span class="nav-number">6.2.</span> <span class="nav-text">SortedSet 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#NavigableSet-接口"><span class="nav-number">6.3.</span> <span class="nav-text">NavigableSet 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet-类"><span class="nav-number">6.4.</span> <span class="nav-text">HashSet 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashSet-类"><span class="nav-number">6.5.</span> <span class="nav-text">LinkedHashSet 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#TreeSet-类"><span class="nav-number">6.6.</span> <span class="nav-text">TreeSet 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#EnumSet-抽象类"><span class="nav-number">6.7.</span> <span class="nav-text">EnumSet 抽象类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collections"><span class="nav-number">7.</span> <span class="nav-text">Collections</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Collection-总结"><span class="nav-number">8.</span> <span class="nav-text">Collection 总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#List-接口-1"><span class="nav-number">8.1.</span> <span class="nav-text">List 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayList-类-1"><span class="nav-number">8.2.</span> <span class="nav-text">ArrayList 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SLinkedList-类"><span class="nav-number">8.3.</span> <span class="nav-text">SLinkedList 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DLinkedList-类"><span class="nav-number">8.4.</span> <span class="nav-text">DLinkedList 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Queue-接口-1"><span class="nav-number">8.5.</span> <span class="nav-text">Queue 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayQueue-类"><span class="nav-number">8.6.</span> <span class="nav-text">ArrayQueue 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SLinkedQueue-类"><span class="nav-number">8.7.</span> <span class="nav-text">SLinkedQueue 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DLinkedQueue-类"><span class="nav-number">8.8.</span> <span class="nav-text">DLinkedQueue 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Stack-接口"><span class="nav-number">8.9.</span> <span class="nav-text">Stack 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayStack-类"><span class="nav-number">8.10.</span> <span class="nav-text">ArrayStack 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SLinkedStack-类"><span class="nav-number">8.11.</span> <span class="nav-text">SLinkedStack 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#DLinkedStack-类"><span class="nav-number">8.12.</span> <span class="nav-text">DLinkedStack 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Set-接口-1"><span class="nav-number">8.13.</span> <span class="nav-text">Set 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashSet-类-1"><span class="nav-number">8.14.</span> <span class="nav-text">HashSet 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashSet-类-1"><span class="nav-number">8.15.</span> <span class="nav-text">LinkedHashSet 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Map-接口-1"><span class="nav-number">8.16.</span> <span class="nav-text">Map 接口</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#HashMap-类-1"><span class="nav-number">8.17.</span> <span class="nav-text">HashMap 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LinkedHashMap-类-1"><span class="nav-number">8.18.</span> <span class="nav-text">LinkedHashMap 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BinaryTree-类"><span class="nav-number">8.19.</span> <span class="nav-text">BinaryTree 类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ArrayAlgorithm-类"><span class="nav-number">8.20.</span> <span class="nav-text">ArrayAlgorithm 类</span></a></li></ol></li></ol></div>
          </div>
        </section>
      <!--/noindex-->
    </div>
  </aside>
      </div>
    </main>
    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">
  &copy;  2016 - 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Otokaze</span>
</div>
<script src="/js/clipboard.min.js"></script>
<script src="/js/prism/prism.js" async></script>
      </div>
    </footer>
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
      </div>
  </div>
<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/affix.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.1"></script>
  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>
      <script id="dsq-count-scr" src="https://otokaze.disqus.com/count.js" async></script>
      <script type="text/javascript">
        var disqus_config = function () {
          this.page.url = 'https://www.zfl9.com/java-collection.html';
          this.page.identifier = 'java-collection.html';
          this.page.title = 'Java Collection框架';
        };
        var d = document, s = d.createElement('script');
        s.src = 'https://otokaze.disqus.com/embed.js';
        s.setAttribute('data-timestamp', '' + +new Date());
        (d.head || d.body).appendChild(s);
      </script>
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
  <script>AV.initialize("3hhdw6gOg9wavsharVwVjqI3-gzGzoHsz", "O5WfDffqFsgmAVPwNY9of3QU");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");
      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });
      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';
          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }
          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);
            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }
    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);
      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }
    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>
</body>
</html>
